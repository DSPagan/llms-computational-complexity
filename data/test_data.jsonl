{"src": "\"\"\"\n#If FastIO not needed, use this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\nimport time\n\nfrom types import GeneratorType\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport string\nfrom math import sqrt\n\n#start_time = time.time()\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\ndef isInt(s):\n    return '0' <= s[0] <= '9'\n\nMOD = 10**9 + 7 \n\n\"\"\"\nS = U T + 0.5 A T^2\nV^2 = U^2 + 2 A S\nV = U + A T\nS = V T - 0.5 A T^2\n\nIf V < W:\n    linearly accelerate to V, then cruise to the end\n\nIf V >= W:\n    If we can get to speed W in distance <= D:\n        cruise to W, then reach the max speed such that we can still decelerate to W. Then post camera, accelerate to V and then cruise\n    Else:\n        linearly accelerate all the way to speed V, then cruise to the end\n\n2*W*T + A * T^2 - 2*rem_dist = 0\n\"\"\"\n\ndef t_from_s_a_u(s,a,u):\n    return (-2*u + sqrt(4*u*u + 8*s*a))/(2*a)\n    \n\ndef solve():\n    A, V = getInts()\n    L, D, W = getInts()\n    if V <= W or W**2 >= 2*A*D: # this renders W irrelevant\n        #can we get to speed V before distance L?\n        if V**2 >= 2*A*L:\n            return sqrt(2*L/A)\n        else:\n            dist_1 = (V**2)/(2*A)\n            T1 = 2*dist_1/V\n            dist_2 = L - dist_1\n            T2 = dist_2/V\n            return T1+T2\n    else:\n        #V > W, and we reach W in time\n        dist_1 = (W**2)/(2*A)\n        T1 = sqrt(2*dist_1/A)\n        rem_dist = D - dist_1\n        dist_A = (V**2 - W**2)/(2*A)\n        if 2*dist_A >= rem_dist:\n            #accelerate then decelerate the whole time. Accelerate for rem_dist/2, decelerate for rem_dist/2\n            TA = 2*t_from_s_a_u(rem_dist/2,A,W)\n        else:\n            TA1 = 2*(V-W)/A\n            SA1 = (V+W)*(V-W)/A\n            SA2 = rem_dist - SA1\n            TA2 = SA2/V\n            TA = TA1 + TA2\n        T1 += TA\n        #now we are at speed W again, so we accelerate to V and then cruise\n        if V**2 - W**2 >= 2*A*(L-D):\n            #accelerate linearly from W to V\n            #print(T1,t_from_s_a_u(L-D,A,W))\n            return T1 + t_from_s_a_u(L-D,A,W)\n        else:\n            dist_2 = (V**2 - W**2)/(2*A)\n            T2 = 2*dist_2/(V+W)\n            dist_3 = L - D - dist_2\n            T3 = dist_3/V\n            #print(T1,T2,T3)\n            return T1+T2+T3\n    return\n    \n#for _ in range(getInt()):\nprint(solve())\n#solve()\n\n\n#print(time.time()-start_time)", "complexity": "constant"}
{"src": "a, v = list(map(int, input().split(\" \")))\nl, d, w = list(map(int, input().split(\" \")))\n \nif(v <= w or w * w > 2 * a * d):\n    if(v * v > 2 * a * l):\n        print((2 * l / a) ** 0.5)\n    else:\n        print(l / v + v / 2 / a)\nelse:\n    u = (w * w / 2 + a * d) ** 0.5\n    if(u > v):\n        m =  v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v\n    else:\n        m = (2 * u - w) / a\n        \n    if(v * v > 2 * a * (l - d + w * w / 2 / a)):\n        print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5)\n    else:\n        print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)", "complexity": "constant"}
{"src": "import decimal\ndecimal.getcontext().prec = 100\n\na, v = map(decimal.Decimal, input().split())\nl, d, w = map(decimal.Decimal, input().split())\n\ndef DecimalPow(a, b):\n    return decimal.Decimal(a) ** decimal.Decimal(b)\n\ndef getLastT(v1, dist):\n    t1 = (v - v1) / a\n    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)\n    if d1 >= dist:\n        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a\n    t2 = (dist - d1) / v\n    return t1 + t2\n\nif w >= v:\n    t1 = v / a\n    if decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2)) <= l:\n        t2 = (l - decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2))) / v\n    else:\n        t1 = (decimal.Decimal(2) * l / a) ** decimal.Decimal(0.5)\n        t2 = 0\n    t = t1 + t2\n    print('{t:.5f}'.format(t = t))\n\nelif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:\n    t = getLastT(0, l)\n    print('{t:.5f}'.format(t = t))\n\nelif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:\n    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)\n    t1 = w / a + t2\n    t3 = getLastT(w, l - d)\n    t = t1 + t2 + t3\n    print('{t:.5f}'.format(t = t))\n\nelse:\n    t1 = v / a\n    t3 = (v - w) / a\n    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v\n    t4 = getLastT(w, l - d)\n    t = t1 + t2 + t3 + t4\n    print('{t:.5f}'.format(t = t))", "complexity": "constant"}
{"src": "import math\n\ndef getdt():\n    return map(int,input().split())\ndef calc(v0,v,a,x):\n    t = (v - v0)/a\n    x0 = v0 * t + 0.5*a*t*t\n    if x0>=x:\n        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)\n    return (x0,t)\ndef go(v0,v,a,x):\n    x0,t = calc(v0,v,a,x)\n    return t + (x-x0)/v\n\na,v = getdt()\nl,d,w = getdt()\nif w>v:\n    w = v\nx,t = calc(0,w,a,d)\nif x==d:\n    print(go(0,v,a,l))\nelse:\n    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))", "complexity": "constant"}
{"src": "n=int(input())\ng=n//2\nprint(g+n)", "complexity": "constant"}
{"src": "# -*- coding: utf-8 -*-\n\nn = int(input())\n\nlucky = [\"1\",\"2\",\"3\",\"5\",\"6\",\"8\",\"9\",\"0\"]\n\n\nye = False\nfor i in range(1,n+1):\n    luck=True\n    for char in str(i):\n        if char in lucky:\n            luck = False\n            break\n            \n    if luck == True and n % i == 0:\n        print(\"YES\")\n        ye = True\n        break\n    else:\n        continue\nif ye != True:\n    print(\"NO\")", "complexity": "constant"}
{"src": "n = int(input())\nl = [4,7,47,74,444,447,474,477,747,744,774,777]\n\nfor i in l:\n    if n % i == 0:\n        print('YES')\n        break\n    else:\n        pass\nelse:\n    print('NO')\n    \n        \n\n\n\n            \n", "complexity": "constant"}
{"src": "import sys,os,io,time,copy\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\nimport math\n\ndef main():\n    # start=time.time()\n    n=int(input())\n    print(0,0,n)\n\n    # end=time.time()\nmain()", "complexity": "constant"}
{"src": "n = int(input())\nif n==0:\n    print(*[0,0,0])\nelif n==1:\n    print(*[0,0,1])\nelse:\n    prev2 = 0\n    prev1 = 1\n    prev = 1\n    while prev!=n:\n        curr = prev+prev1\n        prev2 = prev1\n        prev1 = prev\n        prev = curr\n    print(*[0,prev2,prev1])\n", "complexity": "constant"}
{"src": "def gcd(a,b):\n    if b==0:\n        return a\n    else:\n        return gcd(b,a%b)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    ans = 0\n    if n==1:\n        ans = 1\n    elif n==2:\n        ans = 2\n    else:\n        if n%2!=0:\n            ans = n*(n-1)*(n-2)\n        else:\n            if gcd(n,(n-3)) ==1:\n                ans = n*(n-1)*(n-3)\n            else:\n                ans = (n-1)*(n-2)*(n-3)\n    print(ans)", "complexity": "constant"}
{"src": "n=int(input())\nif n==1 or n==2 :\n    print(n)\nelif n%2!=0 :\n    m=n*(n-1)*(n-2)\n    print(m)\nelif n%3!=0 :\n    m=n*(n-1)*(n-3)\n    print(m)\nelse :\n    m=(n-1)*(n-2)*(n-3)\n    print(m)", "complexity": "constant"}
{"src": "for _ in range(int(input())):\n    a,b = map(int, input().split())\n    c = 0\n    while (a!=0 and b!=0):\n        if (a>b) : \n            c+= a//b\n            a = a%b\n        elif (b>a):\n            c+= b//a\n            b = b%a\n        else :\n            c+=1\n            break\n    print(c)", "complexity": "constant"}
{"src": "def operations(a, b):\n    less = min(a, b)\n    more = max(a, b)\n    ops = 0\n    while less > 0 and more > 0:\n        ops += more // less\n        more -= less * (more // less)\n        less, more = more, less\n    return ops\n\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(operations(a, b))\n", "complexity": "constant"}
{"src": "n=int(input())\nif n%2==0:\n    print(4,n-4)\nelse:\n    print(9,n-9)\n    ", "complexity": "constant"}
{"src": "import sys, collections, math, itertools, random, bisect\nINF = sys.maxsize\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\nmod = 1000000007\n\nl,r = get_ints()\nif r-l < 2:\n    print(-1)\nelif l%2 == 0:\n    print(l, l+1, l+2)\nelif r-l > 2:\n    print(l+1, l+2, l+3)\nelse:\n    print(-1)", "complexity": "constant"}
{"src": "from math import gcd\n# region fastio\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\ndef func(l,r):\n    if l==1:\n        l+=1\n    if r-l<2:\n        return -1\n\n    if l&1:\n        if r-l>2:\n            l+=1\n            return '{} {} {}'.format(l,l+1,l+2)\n        else:\n            if gcd(l,l+2)!=1:\n                return '{} {} {}'.format(l,l+1,l+2)\n            return -1\n    return '{} {} {}'.format(l, l + 1, l + 2)\n\n\n\ndef main():\n    l,r=map(int,input().split())\n    print(func(l,r))\n    return\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "constant"}
{"src": "import math\n\nl, r = (map(int, input().split()))\na = l\nif a % 2:\n    a += 1\n\nif a + 2 > r:\n    print(-1)\nelse:\n    print(a, a + 1, a + 2)", "complexity": "constant"}
{"src": "a,b=map(int,input().split())\nif max(a,b)-min(a,b) +1<=2:\n    print(-1)\nelif max(a,b)-min(a,b) +1==3:\n    if a % 2==1 and b %2==1:\n        print(-1)\n    else:\n        print(min(a,b),min(a,b)+1,min(a,b)+2)\nelse:\n    ans=0\n    for i in range(a,b+1):\n        if i%2==0:\n            ans=i\n            break\n    print(ans,ans+1,ans+2)", "complexity": "constant"}
{"src": "n = int(input())\nif n == 1:\n    print(5)\nelse:\n    print(25)\n\t \t    \t \t\t \t    \t\t \t \t\t\t     \t", "complexity": "constant"}
{"src": "n = int(input())\nprint(25)", "complexity": "constant"}
{"src": "n = int(input())\n\nif n>=2:\n    print(25)\n", "complexity": "constant"}
{"src": "a = list(map(int,input().split()))\nif a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "constant"}
{"src": "n = int(input())\nm = int(input())\nif(n<=26):\n    print(m%(2**n))\nelse:\n    print(m)\n    ", "complexity": "constant"}
{"src": "n=int(input())\nm=int(input())\nprint(m%2**n)\n", "complexity": "constant"}
{"src": "x=list(map(int,input().split()))\npos=x[1]\nn=x[0]\nl=x[2]\nr=x[3]\nstep=0\nif pos<l :\n    step=l-pos+1\n    \n    if r< n :\n        step+=r-l+1\nelif pos>r:\n    step=pos-r+1\n    \n    if l> 1 :\n        step+=r-l+1\nelse:\n    if l>1 and n>r:\n        step+=min(pos-l,r-pos)+r-l+2\n    elif l==1 and n>r:\n        step=r-pos+1\n    elif l>1 and n==r:\n        step+=pos-l+1\n    else:\n        step=0\n\n\n\nprint(step)", "complexity": "constant"}
{"src": "n = int(input())\nprint(n // 2 + 1)", "complexity": "constant"}
{"src": "# A. Paper Airplanes\n\nk, n, s, p = map(int, input().split())\n\nsheets = (n + s - 1) // s\n\nprint((sheets * k + p - 1) // p)\n\n", "complexity": "constant"}
{"src": "import math\nk, n, s, p = map(int, input().split())\nsheets = math.ceil(n/s) * k\nprint(math.ceil(sheets/p))\n \t  \t\t\t\t\t\t\t\t\t\t  \t \t\t \t\t\t\t", "complexity": "constant"}
{"src": "\nstones = list(map(int,input().split())) \ninitial_sum = 0\n\ndef even_sum(arr):\n    temp_sum = 0\n    for each in arr:\n        if(each%2 == 0):\n            temp_sum += each \n        \n    return temp_sum   \n    \ninitial_sum = even_sum(stones)            \ndup_sum = initial_sum \n\nfor i in range(14):\n    duplicate = list(stones)\n    temp = stones[i]\n    duplicate[i] = 0\n    j = i\n    \n    for each in range(14):\n        duplicate[each] += temp//14\n    temp = temp%14 \n    while temp > 0 :\n        if( j == 13):\n            j = -1 \n        j += 1 \n        duplicate[j] += 1\n        temp -= 1 \n    \n    ts = even_sum(duplicate)\n    if(ts > initial_sum ):\n        initial_sum = ts\n        \nprint(initial_sum)\n", "complexity": "constant"}
{"src": "n = int(input())\nn+=1\nif n==1:\n\tprint(0)\nelif n%2==0:\n\tprint(n//2)\nelif n%2!=0 and n!=1:\n\tprint(n)", "complexity": "constant"}
{"src": "n = int(input())\nif n==0:\n    print(0)\nelif n%2==1:\n    print((n+1)//2)\nelse:\n    print(n+1)", "complexity": "constant"}
{"src": "n = int(input())\nif n % 2 == 1:\n    print((n + 2) // 2)\nelif n > 0:\n    print(n + 1)\nelse:\n    print(0)\n    ", "complexity": "constant"}
{"src": "from sys import stdin\nn = int(stdin.readline()) + 1\nif n == 1:\n    print(0)\nelse:\n    print(n//2 if n%2 == 0 else n)", "complexity": "constant"}
{"src": "d={'purple':'Power','green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}\nfor _ in[0]*int(input()):d.pop(input())\nprint(len(d),*d.values(),sep='\\n')", "complexity": "constant"}
{"src": "from sys import stdin\na, b, c, n = map(int, stdin.readline().split())\nif c > a or c > b:\n    print(-1)\nelse:\n    val = n - ((a - c) + (b - c)) - c\n    print(val if val <= n and val > 0 else -1)", "complexity": "constant"}
{"src": "from math import inf\n\na=[0,0]\na[0]=[str(c)for c in list(input().strip()) ]\na[1]=[str(X) for X in list(input().strip())]\n\nan = [-inf,-inf,-inf]\nif a[0][0]==a[1][0]=='0':\n    an[0]=0\nelif  a[0][0]!=a[1][0]:\n    an[1]=0\nx=0\nfor i in range(1,len(a[0])) :\n  #  print(a[0][i],a[1][i],an,x)\n    if an[0]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n\n            an=[-inf,0 ,-inf]\n        elif a[0][i]!=a[1][i]:\n            x+=1\n            an=[-inf]*3\n        else:\n            an = [-inf, -inf, -inf]\n    elif an[1]==0:\n        if a[0][i]==a[1][i]=='0':\n            x+=1\n            an=[-inf,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            pass\n        else:\n            an=[-inf,-inf ,-inf]\n    else:\n        if a[0][i]==a[1][i]=='0':\n\n            an=[0,-inf ,-inf]\n        elif a[0][i]!=a[1][i]:\n            an=[-inf,0,-inf]\n        else:\n            an=[-inf,-inf ,-inf]\n\nprint(x)", "complexity": "constant"}
{"src": "s = [list(input()), list(input())]\nans = 0\nl = len(s[0])\ni = 0\nwhile i < l - 1:\n    a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1])\n    if a.count(\"0\") == 4:\n        ans += 1\n        s[0][i + 1] = \"X\"\n        i+=1\n    elif a.count(\"0\") == 3:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)\n", "complexity": "constant"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef isPrime(x):\n    for i in range(2,x):\n        if i*i>x:\n            break\n        if (x%i==0):\n            return False\n    return True\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    return list(set(l))\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef si():\n    return input()\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\ndef power_set(L):\n    \"\"\"\n    L is a list.\n    The function returns the power set, but as a list of lists.\n    \"\"\"\n    cardinality=len(L)\n    n=2 ** cardinality\n    powerset = []\n    \n    for i in range(n):\n        a=bin(i)[2:]\n        subset=[]\n        for j in range(len(a)):\n            if a[-j-1]=='1':\n                subset.append(L[j])\n        powerset.append(subset)\n        \n    #the function could stop here closing with\n    #return powerset\n\n    powerset_orderred=[]\n    for k in range(cardinality+1):\n        for w in powerset:\n            if len(w)==k:\n                powerset_orderred.append(w)\n        \n    return powerset_orderred\ndef fastPlrintNextLines(a):\n    # 12\n    # 3\n    # 1\n    #like this\n    #a is list of strings\n    print('\\n'.join(map(str,a)))\n\ndef sortByFirstAndSecond(A):\n    A = sorted(A,key = lambda x:x[0])\n    A = sorted(A,key = lambda x:x[1])\n    return list(A)\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nt = 1\n# t = int(input())\nfor _ in range(t):\n    n,k = li()\n    if k<=n:\n        print((k-1)//2)\n    else:\n        print(max((2*n-k+1)//2,0))\n    \n    \n", "complexity": "constant"}
{"src": "n,k = map(int,input().split())\nif k>n+n-1:\n    print(0)\n    exit(0)\nif k-1<=n:\n    ml = 1\n    mr = k-1\n    print((mr-ml+1)//2)\nelse:\n    mr = n\n    ml = k-n\n    print((mr-ml+1)//2)", "complexity": "constant"}
{"src": "n,m=[int(x) for x in input().split(' ')]\nprint((n-1)*'4'+'5')\nprint(n*'5')\n#\n#sum a+b less than m .. so sum a+b will be of form 1000000....000\n\n#so it will be 1, that condition is always satisfied\n#condition of mn will always be satisfied because it is 5times n\n#always greater than n", "complexity": "constant"}
{"src": "n=int(input())\na,b=map(int,input().split())\nb1,b2=map(int,input().split())\nc1,c2=map(int,input().split())\nb1-=a\nb2-=b\nc1-=a\nc2-=b\nif b1==0 or b2==0 or c1==0 or c2==0:print('NO')\nelse:\n    if b1*c1<0 or b2*c2<=0:print('NO')\n    else:print('YES')", "complexity": "constant"}
{"src": "n = int(input())\nbx, by = map(int, input().split())\nax, ay = map(int, input().split())\ncx, cy = map(int, input().split())\nnum1 = ax > bx\nnum3 = cx > bx\nnum2 = ay > by\nnum4 = cy > by\nif num1 == num3 and num2 == num4:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant"}
{"src": "n,k = map(int,input().split())\nprint(-(-k//n))\n", "complexity": "constant"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, K = getIntList()\n\nr=  K//N\nif K%N!=0: r+=1\n\nprint(r)\n\n\n\n\n\n\n", "complexity": "constant"}
{"src": "[n, k]=[int(i) for i in input().split()]\nprint((k+n-1)//n)", "complexity": "constant"}
{"src": "n = int(input())\nfor q in range(n):\n    x, y, k = map(int, input().split())\n    if max(x, y) > k:\n        print(-1)\n    else:\n        if 0 == (x + y) % 2:\n            if k % 2 == max(x, y) % 2:\n                print(k)\n            else:\n                print(k - 2)\n        else:\n            print(k - 1)\n", "complexity": "constant"}
{"src": "x, y, z, t1, t2, t3 = map(int, input().split())\nladder = abs(x - y) * t1\nelevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2\nif elevator > ladder:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")", "complexity": "constant"}
{"src": "x, y, z, t1, t2, t3 = list(map(int, input().split()))\nprint(\"YES\" if 3 * t3 + abs(x - z) * t2 + abs(x - y) * t2 <= abs(x - y) * t1 else \"NO\")", "complexity": "constant"}
{"src": "x, y, z, t1, t2, t3 = map(int, input().split())\n\ntp = abs(x - y) * t1\npt = (abs(x - y) + abs(x - z)) * t2 + t3 + t3 + t3\nif tp >= pt:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "constant"}
{"src": "x, y, z, t1, t2, t3 = map( int, input().split() )\nelevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3\nstairs = t1 * abs( x - y )\nif elevator > stairs:\n    print( 'NO' )\nelse:\n    print( 'YES' )\n", "complexity": "constant"}
{"src": "n, s = map(int, input().split())\nprint((s + n - 1) // n)\n", "complexity": "constant"}
{"src": "n, m, k, l = map(int, input().split())\nk += l\nx = (k + m - 1) // (m);\nif m * x > n:\n    print(-1)\nelse:\n    print(x)", "complexity": "constant"}
{"src": "n = int(input())\nx,y = map(int,input().split())\nif max(x-1,y-1) > max(n-x,n-y):\n    print(\"Black\")\nelse:\n    print(\"White\")\n", "complexity": "constant"}
{"src": "n = int(input())\nx, y = [int(i) for i in input().split()]\n\nd1 = abs(x - 1) + abs(y - 1)\nd2 = abs(n - x) + abs(n - y)\n\nprint(\"White\" if d1 <= d2 else \"Black\")\n", "complexity": "constant"}
{"src": "n = int(input())\n\nx, y = map(int, input().split())\n\nans = (x - 1) + (y - 1) <= (n - x) + (n - y)\nprint('White' if ans else 'Black')\n", "complexity": "constant"}
{"src": "n = int(input())\nx, y = list(map(int, input().strip().split()))\n\nif n-x + n-y >= x-1 + y-1:\n\tprint(\"White\")\nelse:\n\tprint(\"Black\")", "complexity": "constant"}
{"src": "n,k=map(int,input().split())\nprint((-(-n*2//k))+(-(-n*5//k))+(-(-n*8//k)))\n#2,5,8\n", "complexity": "constant"}
{"src": "from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\n\n\ndef get(l, r):\n    if l > r:\n        return 0\n    \n    if l & 1:\n        return (-l - r) * (r - l + 2) // 4\n    else:\n        return (l + r) * (r - l + 2) // 4\n\n\ndef solution(l, r):\n    l1, l2, r1, r2 = l, l, r, r\n    \n    if l & 1:\n        l2 += 1\n    else:\n        l1 += 1\n    \n    if r & 1:\n        r2 -= 1\n    else:\n        r1 -= 1\n    \n    return get(l1, r1) + get(l2, r2)\n\n\nq = int(stdin.readline())\nfor i in range(q):\n    l, r = map(int, stdin.readline().split())\n    stdout.write(str(solution(l, r)) + '\\n')", "complexity": "constant"}
{"src": "import math\nn  = int(input())\n\nfor i in range(n):\n    l,r = [*map(int, input().split())]\n    l-=1\n    war1 = math.ceil(l/2)\n    if(l%2 == 1):\n        war1 = -1*war1\n    \n    war2 = math.ceil(r/2)\n    if(r%2 == 1):\n        war2 = -1*war2\n\n    print(war2-war1)", "complexity": "constant"}
{"src": "def color(x, y):\n\t# print(f'color(x = {x}, y = {y}) called')\n\treturn 'white' if (x + y) % 2 == 0 else 'black'\n\n\ndef white(x1, y1, x2, y2):\n\t\"\"\" x1 <= x2, y1 <= y2 \"\"\"\n\t# print(f'white(x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}) called')\n\tif x1 > x2 or y1 > y2:\n\t\treturn 0\n\n\tif color(x1, y1) != color(x2, y2):\n\t\treturn (x2 - x1 + 1) * (y2 - y1 + 1) // 2\n\telse:\n\t\tif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':\n\t\t\treturn ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2\n\t\telif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':\n\t\t\treturn ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2\n\t\telse:\n\t\t\treturn (x2 - x1 + 1) * (y2 - y1 + 1) // 2\t\n\n\ndef black(x1, y1, x2, y2):\n\t\"\"\" x1 <= x2, y1 <= y2 \"\"\"\n\tif x1 > x2 or y1 > y2:\n\t\treturn 0\n\n\treturn (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)\n\n\ndef intersect_1D(x1, x2, x3, x4):\n\t\"\"\" x1 <= x2, x3 <= x4 \"\"\"\n\treturn max(x1, x3), min(x2, x4)\n\n\ndef intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):\n\t\"\"\" x1 <= x2, x3 <= x4, y1 <= y2, y3 <= y4 \"\"\"\n\txl, xr = intersect_1D(x1, x2, x3, x4)\n\tyl, yr = intersect_1D(y1, y2, y3, y4)\n\treturn xl, yl, xr, yr\n\n\nfor i in range(int(input())):\n\tn, m = map(int, input().split())\n\t# print(f'n = {n}, m = {m}')\n\tx1, y1, x2, y2 = map(int, input().split())\n\t# print(f'x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}')\n\tx3, y3, x4, y4 = map(int, input().split())\n\t# print(f'x3 = {x3}, y3 = {y3}, x4 = {x4}, y4 = {y4}')\n\n\tw0, b0 = white(1, 1, m, n), black(1, 1, m, n)\n\t# print(f'w0 = {w0}, b0 = {b0}')\n\n\t_b0 = black(x1, y1, x2, y2)\n\t# print(f'_b0 = {_b0}')\n\tw1, b1 = w0 + _b0, b0 - _b0\n\n\t_w1 = white(x3, y3, x4, y4)\n\t# print(f'_w1 = {_w1}')\n\tw2, b2 = w1 - _w1, b1 + _w1\n\n\txl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)\n\t# print(f'xl = {xl}, yl = {yl}, xr = {xr}, yr = {yr}')\n\t_b2 = black(xl, yl, xr, yr)\n\t# print(f'_b2 = {_b2}')\n\tw3, b3 = w2 - _b2, b2 + _b2\n\n\tprint(w3, b3)\n", "complexity": "constant"}
{"src": "def wb(n,m,flip=False):\n    w = b = n*m // 2\n    if n%2 == 1 and m %2 == 1:\n        w += 1\n    if flip:\n        return b,w\n    else:\n        return w,b\n\nt = int(input())\nfor tt in range(t):\n    n,m = map(int, input().split())\n    x1,y1,x2,y2 = map(int, input().split())\n    x3,y3,x4,y4 = map(int, input().split())\n    x5 = max(x1,x3)\n    x6 = min(x2,x4)\n    y5 = max(y1,y3)\n    y6 = min(y2,y4)\n    ov = False\n    if x6-x5 >= 0 and y6-y5 >= 0:\n        ov = True\n    w,b = wb(n,m)\n    wm,bm = wb(x2-x1+1, y2-y1+1, (x1+y1)%2==1)\n    wd,bd = wb(x4-x3+1, y4-y3+1, (x3+y3)%2==1)\n    if ov:\n        wo,bo = wb(x6-x5+1, y6-y5+1, (x5+y5)%2==1)\n    else:\n        wo,bo = 0,0\n    # print('w, b', w, b)\n    # print('wm, bm', wm, bm)\n    # print('wd, bd', wd, bd)\n    # print('wo, bo', wo, bo)\n    w = w+bm-wd-bo\n    b = b-bm+wd+bo\n    print(w,b)", "complexity": "constant"}
{"src": "xa, ya = map(int, input().split())\nxb, yb = map(int, input().split())\nxc, yc = map(int, input().split())\nif (xb, yb) < (xa, ya):\n    xa, ya, xb, yb = xb, yb, xa, ya\nif (xc, yc) < (xa, ya):\n    xa, ya, xc, yc = xc, yc, xa, ya\nif xb > xc:\n    xb, yb, xc, yc = xc, yc, xb, yb\nd = 1 if ya <= yc else -1\nif ya <= yb <= yc or ya >= yb >= yc:\n    print(xc - xa + abs(yc - ya) + 1)\n    for x in range(xa, xb):\n        print(x, ya)\n    for y in range(ya, yc, d):\n        print(xb, y)\n    for x in range(xb, xc + 1):\n        print(x, yc)\nelif yb < min(ya, yc):\n    print(xc - xa + max(ya, yc) - yb + 1)\n    for x in range(xa, xc + 1):\n        print(x, min(ya, yc))\n    for y in range(yb, min(ya, yc)):\n        print(xb, y)\n    if ya < yc:\n        for y in range(ya + 1, yc + 1):\n            print(xc, y)\n    else:\n        for y in range(yc + 1, ya + 1):\n            print(xa, y)\nelse:\n    print(xc - xa + yb - min(ya, yc) + 1)\n    for x in range(xa, xc + 1):\n        print(x, max(ya, yc))\n    for y in range(max(ya, yc) + 1, yb + 1):\n        print(xb, y)\n    if ya < yc:\n        for y in range(ya, yc):\n            print(xa, y)\n    else:\n        for y in range(yc, ya):\n            print(xc, y)\n", "complexity": "constant"}
{"src": "import sys\n\n\ndef ask(c, d):\n    print(\"? {} {}\".format(c, d))\n    return int(input())\n\n\nc = d = 0\n\n\ndef solve(mi, base):\n    def solve_same():\n        global c, d\n        print(\"# solve_same\", file=sys.stderr)\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d)\n            res2 = ask(c, d ^ bit)\n            if res1 == -1 and res2 == 1:\n                c |= bit\n                d |= bit\n\n    def solve1():\n        global c, d\n        print(\"# solve1\", file=sys.stderr)\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d ^ bit)\n            if res1 == -1:\n                # a[i] == 1, b[i] == 0\n                c |= bit\n                return solve(i - 1, ask(c, d))\n            else:\n                # a[i] == b[i]\n                res2 = ask(c ^ bit, d)\n                if res2 == -1:\n                    # a[i] == b[i] == 1\n                    c |= bit\n                    d |= bit\n\n    def solve2():\n        global c, d\n        print(\"# solve2\", file=sys.stderr)\n        for i in range(mi, -1, -1):\n            print(f\">> {i=} {c=} {d=}\", file=sys.stderr)\n            bit = 1 << i\n            res1 = ask(c ^ bit, d ^ bit)\n            if res1 == 1:\n                # a[i] == 0, b[i] == 1\n                d |= bit\n                return solve(i - 1, ask(c, d))\n            else:\n                # a[i] == b[i]\n                res2 = ask(c, d ^ bit)\n                if res2 == 1:\n                    # a[i] == b[i] == 1\n                    c |= bit\n                    d |= bit\n\n    if base == 0:\n        solve_same()\n    elif base == 1:\n        solve1()\n    else:\n        solve2()\n\n\nsolve(29, ask(0, 0))\nprint(\"! {} {}\".format(c, d))\n", "complexity": "constant"}
{"src": "import sys\ndef ask(x,y,rev):\n\tif (rev==0):\n\t\tprint(\"? %d %d\"%(x,y))\n\telse:\n\t\tprint(\"? %d %d\"%(y,x))\n\tsys.stdout.flush()\n\tif (rev==1):\n\t\treturn -int(input())\n\telse:\n\t\treturn int(input())\n\ncomp=ask(0,0,0)\nnowa=0\nnowb=0\nrev=0\nfor i in range(29,-1,-1):\n\tif (comp<0):\n\t\trev^=1\n\t\tnowa,nowb=nowb,nowa\n\t\tcomp=-comp\n\tif comp>=0:\n\t\tcomp=ask(nowa|(1<<i),nowb|(1<<i),rev)\n\t\tif (comp<0):\n\t\t\tnowa|=1<<i\n\t\t\tcomp=ask(nowa,nowb,rev)\n\t\telse:\n\t\t\ttmp=ask(nowa|(1<<i),nowb,rev)\n\t\t\tif (tmp<0):\n\t\t\t\tnowa|=1<<i\n\t\t\t\tnowb|=1<<i\nif (rev==1):\n\tnowa,nowb=nowb,nowa\nprint(\"! %d %d\"%(nowa,nowb))\n\t\t\t\n\t\t", "complexity": "constant"}
{"src": "print(\"? 0 0\", flush=True)\nres = input()\ni = 1\na = 0\nb = 0\nfor i in range(29,-1,-1):\n\tprint(\"?\",(a^(1<<i)), b, flush=True)\n\tres1 = input()\n\tprint(\"?\",a, (b^(1<<i)), flush=True)\n\tres2 = input()\n\tif res1 == res2:\n\t\tif res == '1':\n\t\t\ta ^= (1<<i)\n\t\telse:\n\t\t\tb ^= (1<<i)\n\t\tres = res1\n\telif res1 == '-1':\n\t\ta ^= (1<<i)\n\t\tb ^= (1<<i)\nprint(\"!\", a, b, flush=True)", "complexity": "constant"}
{"src": "import math\nn, r = list(map(int, input().split(' ')))\nl = 2 * r * math.sin(math.pi/n)\nR = l * r / (-l + 2*r)\nprint(R)", "complexity": "constant"}
{"src": "import math\nn,r=map(int,input().split())\nprint(r/( 1/math.cos(math.pi*(n-2)/2/n)-1))", "complexity": "constant"}
{"src": "k = int(input())\nch = 0\ni = 0\nr = 1\nwhile k > r - 1:\n    r += 9 * (i + 1) * 10 ** i\n    i += 1\nr -= 9 * i * 10 ** (i - 1)\n#print(r, i)\nprint(str((k - r) // i + 10 ** (i - 1))[(k - r) % i]  )\n", "complexity": "constant"}
{"src": "n=input()\ni=0\nwhile(True):\n    if (n-9*10**i*(i+1))<=0:\n        break\n    n-=9*10**i*(i+1)\n    i+=1\n\na=n/(i+1)\nb=n%(i+1)\nif(b!=0):\n    print(str(10**i+a)[b-1])\nelse:\n    print(str(10**i+a-1)[-1])\n", "complexity": "constant"}
{"src": "def mp():\n    return map(int, input().split())\n\ndef f(i):\n    return (10 ** i - 10 ** (i - 1)) * i\n\nn = int(input())\n\ni = 1\nsum = 0\nwhile n - f(i) >= 0:\n    n -= f(i)\n    sum += f(i) // i\n    i += 1\n\nprint(str(sum + (n + i - 1) // i)[n % i - 1])", "complexity": "constant"}
{"src": "#!/usr/bin/env python3\nfrom sys import stdin\n\n\ndef solve(tc):\n    k = int(stdin.readline().strip())\n    cmp = 9\n    ndigit = 1\n\n    while k>(cmp*ndigit):\n        k -= cmp*ndigit\n        cmp *= 10\n        ndigit += 1\n    \n    num = (10**(ndigit-1)) + ((k-1) // ndigit)\n    pos = (k-1) % ndigit\n\n    print(str(num)[pos])\n    pass\n\n\nLOCAL_TEST = not __debug__\nif LOCAL_TEST:\n    infile = __file__.split('.')[0] + \"-test.in\"\n    stdin = open(infile, 'r')\n\ntcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)\ntc = 1\nwhile tc <= tcs:\n    solve(tc)\n    tc += 1", "complexity": "constant"}
{"src": "index = int(input())\n\ntotal = 9\nn = 1\n\nwhile index > total:\n    total += (n + 1) * (10**n) * 9\n    n += 1\nlast = 10**(n - 1)\ntotal -= n * 9 * last\nindex = index - total\n\n\nr = index % (n)\nk = index // n\n\nnumber = last + k\n\n\nif r == 0:\n    print(str(number - 1)[n-1])\nelse:\n    print(str(number)[r - 1])\n", "complexity": "constant"}
{"src": "a = int(input())\nprint(a * (a - 1) * 2 + 1)", "complexity": "constant"}
{"src": "n = int(input())\nprint(n**2 + (n-1)**2)\n", "complexity": "constant"}
{"src": "n = int(input().strip())\nprint(n**2+(n-1)**2)", "complexity": "constant"}
{"src": "n, k = map(int, input().split())\n\na = 1\nb = -(2*n+3)\nc = (n*n+n-2*k)\n\nd = int((b*b - 4*a*c) ** 0.5)\n\ns1 = (-b + d) // (2 * a)\ns2 = (-b - d) // (2 * a)\nif s1 >= 0 and s1 <= n:\n    print(s1)\nelse:\n    print(s2)\n", "complexity": "constant"}
{"src": "def chk(n):\n    return int(n**0.5+0.1)**2 == n\nfor _ in range(int(input())):\n    n = int(input())\n    if n % 2 == 0 and chk(n//2) or n % 4 == 0 and chk(n//4):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "complexity": "constant"}
{"src": "a, b = map(int, input().split())\n\nbitxor = a^b\n\nres = 1\nwhile bitxor:\n    bitxor >>= 1\n    res <<= 1\n\nprint(res-1)\n\n \t\t   \t\t  \t\t  \t\t   \t \t \t\t\t \t\t\t", "complexity": "logn"}
{"src": "l, r = map(int, input().split())\n\nif l == r:\n    print(0)\n    exit()\nbinr, binl = list(bin(r)[2:]), list(bin(l)[2:])\nbinl = ['0'] * (len(binr) - len(binl)) + binl\n# print(binl, binr)\nfor i in range(len(binl)):\n    if binl[i] != binr[i]:\n        del (binl[0:i])\n        del (binr[0:i])\n        break\n\nx = '1' * len(binl)\n# print(x)\nl = int(x, 2)\nprint(l)\n", "complexity": "logn"}
{"src": "a, b  = map(int, input().split())\n\nk = 2**(a^b).bit_length()\nprint(k-1)", "complexity": "logn"}
{"src": "a, b  = map(int, input().split())\n\nk = 2**(a^b).bit_length()-1\nprint(k)", "complexity": "logn"}
{"src": "def main():\n\tl, r = map(int , input().split())\n\tif l == r :\n\t\tprint(0)\n\telse :\n\t\trs = \"\"\n\t\twhile (r):\n\t\t\trs += '1' if r%2 else '0'\n\t\t\tr //= 2\n\t\tfor i in range(len(rs), 65):\n\t\t\trs += '0' \n\t\t# rs = rs[::-1]\n\t\tls = \"\"\n\t\twhile (l):\n\t\t\tls += '1' if l%2 else '0'\n\t\t\tl //= 2\n\t\tfor i in range(len(ls), 65):\n\t\t\tls += '0'\n\t\t# ls = ls[::-1]\n\t\tpos = -1\n\t\tfor i in range(64, -1, -1):\n\t\t\t# print(rs[i], '#', ls[i])\n\t\t\tif (rs[i] == '1' and ls[i] == '0'):\n\t\t\t\tpos = i\n\t\t\t\tbreak\n\n\t\tans = 2**(pos+1) - 1\n\t\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()", "complexity": "logn"}
{"src": "ii=lambda:int(input())\nkk=lambda:map(int, input().split())\nll=lambda:list(kk())\n\nfrom math import log\nl,r=kk()\ni=msb = int(max(log(l,2),log(r,2)))\nwhile ((2**i)&l) == ((2**i)&r):\n\ti-=1\n\tif i == -1:\n\t\tbreak\ni+=1\nprint(2**i-1)", "complexity": "logn"}
{"src": "l, r = map(int, input().split())\n\nprint(0 if l == r else 2 ** len(bin(l ^ r)[2:]) - 1)", "complexity": "logn"}
{"src": "l, r = map(int, input().split())\n\nans = 0\nfor i in range(63, -1, -1):\n    if r & (1 << i) > 0 and l & (1 << i) == 0:\n        ans = (1 << (i + 1)) - 1\n        break\nprint(ans)\n", "complexity": "logn"}
{"src": "entrada = input().split()\n\nl = int(entrada[0])\nr = int(entrada[1])\n\npop = l ^ r\nresult = 1\n\nwhile (result <= pop):\n    result = result << 1\n\nprint(result - 1)\n\t\t  \t\t\t\t  \t\t \t  \t    \t\t\t\t\t \t\t", "complexity": "logn"}
{"src": "string = input()\nl, r = string.split()\nl = int(l)\nr = int(r)\np = l ^ r\nx = 1\nwhile x <= p:\n    x = x << 1\nprint(x-1)\n\n\t\t\t    \t\t \t\t \t   \t\t\t \t\t\t\t\t \t", "complexity": "logn"}
{"src": "def solve():\n  l, r = map(int, input().split())\n  if l==r:\n    print(0)\n    return\n  mx = str(bin(l^r))\n  x = len(mx[2:])\n  print(2**x-1)\nsolve()", "complexity": "logn"}
{"src": "from math import ceil, sqrt, log\n\t\ndef mod_expo(n, p, m):\n\t\"\"\"find (n^p)%m\"\"\"\n\tresult = 1\n\twhile p != 0:\n\t\tif p%2 == 1:\n\t\t\tresult = (result * n)%m\n\t\tp //= 2\n\t\tn = (n * n)%m\n\treturn result\n\t\ndef is_square(n):\n\treturn int(sqrt(n))*int(sqrt(n)) == n\n\ndef find_div(n):\n\td = []\n\tfor i in range(2, int(sqrt(n))+1):\n\t\tif n%i == 0:\n\t\t\tif i*i != n:\n\t\t\t\td.append(i)\n\t\t\t\td.append(n/i)\n\t\t\telse:\n\t\t\t\td.append(i)\n\treturn d\t\t\t\t\n\ndef find_x(n):\n\td = find_div(2*n)\n\tfor div in d:\n\t\tx2 = div*(div + 2*n)\n\t\tif is_square(x2):\n\t\t\treturn sqrt(x2)\n\treturn -1\n\ndef find_base_side(n):\n\tsquares = [x*x for x in range(ceil(sqrt(n)))]\n\tfor i in range(len(squares)):\n\t\tfor j in range(len(squares)):\n\t\t\tif squares[i] + squares[j] == n*n:\n\t\t\t\treturn squares[i]\n\treturn -1\n\t\ndef str_add(n):\n\tn = list(n)\n\tfor i in range(1, len(n)+1):\n\t\tif n[-i] == '9':\n\t\t\tn[-i] = '0'\n\t\telse:\n\t\t\tn[-i] = int(int(n[-i]) + 1)\n\t\t\tbreak\n\tn = str(n)\n\treturn n\t\n\t\ndef str_sub(n):\n\tn = list(n)\n\tfor i in range(1, len(n)+1):\n\t\tif n[-i] == '0':\n\t\t\tn[-i] = '9'\n\t\telse:\n\t\t\tn[-i] = int(int(n[-i]) - 1)\n\t\t\tbreak\n\tn = str(n)\n\treturn n\t\t\n\t\ndef find_massive_x(n):\n\tif n%2 == 0:\n\t\tn2 = str(int(pow(n/2, 2)))\n\t\tx = str_sub(n2)\n\t\ty = str_add(n2)\n\telse:\n\t\tn2 = str(int(pow(n, 2)/2))\n\t\tx = str_sub(n2)\n\t\ty = str_add(n2)\n\tx = str(x)\n\ty = str(y)\n\tprint(x, y)\t\ndef find_triples(n):\n\tif n <= 2:\n\t\tprint(-1)\n\t\treturn \n\telse:\n\t\t#x = find_x(n)\n\t\t#if x != -1:\n\t\t#\tprint(int(x), int(sqrt(n*n + x*x)))\n\t\t#\treturn \n\t\t#x = find_base_side(n)\n\t\t#if x != -1:\n\t\t#\tprint(int(x), int(sqrt(n*n - x*x)))\n\t\t#\treturn \n\t\tx = find_massive_x(n)\n\n\tprint(-1)\n\ndef find_max_xor(l, r):\n\tlxr = l^r\n\tmsb_pos = 0\n\twhile lxr > 0:\n\t\tmsb_pos += 1\n\t\tlxr //= 2\n\treturn pow(2, msb_pos)-1 \t\n\t\n\t\n\t\n\t\nt = 1 \n# t = int(input())\nwhile t:\n\tt = t - 1\n\t#n = int(input())\n\t# s = input()\n\t# a, b, m = map(int, input().split())\n\t#\n\tl, r = map(int, input().split())\n\t#l = list(map(int, input().strip().split()))[:n]\n\t#str1 = input()\n\t#find_massive_x(n)\n\t#result = find_min(n, l)\n\tprint(find_max_xor(l, r))\n\t# find_arr(u, v)\n", "complexity": "logn"}
{"src": "#Problem A - Little Girl and Maximum XOR\n\nnumeros = [int(i) for i in input().split(' ')]\n\nl = bin(numeros[0])\nr = bin(numeros[1])\n\np = -1\n\nif (len(r) == len(l)):\n    for i in range (len(l)):\n        if (l[i] != r[i]):\n            p = i\n            break\n    if(numeros[0] != numeros[1]):\n        saida = 2**(len(r) - p) - 1\n        print(saida)\n    else:\n        print(0)\n\nelse:\n    if(numeros[0] != numeros[1]):\n        saida = 2**(len(r) - 2) - 1\n        print(saida)\n    else:\n        print(0)\n \t\t   \t  \t\t\t\t\t\t \t \t  \t\t\t  \t", "complexity": "logn"}
{"src": "#import random\n\ndef max_xor_naive(l, r):\n    max_xor = 0\n    xor = 0\n\n    for a in range(l, r+1):\n        for b in range(a+1, r+1):\n            xor = a^b\n            if xor>max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef max_xor_efficient(l, r):\n    s1 = bin(l)[2:]\n    s2 = bin(r)[2:]\n    l1 = len(s1)\n    l2 = len(s2)\n    if l1<l2:\n        return pow(2, l2) - 1\n    x = 0\n    for i in range(0, l1):\n        if s1[i]!=s2[i]:\n            return pow(2, l1-i) - 1\n\n    return 0\n\n#while True:\nl, r = map(int, input().split())\n#l = int(input())\n#r = int(input())\n#    l = random.randint(1, 1000)\n#    r = random.randint(l, 1000)\n    #print(max_xor_naive(l, r))\n    #print(max_xor_efficient(l, r))\n    #print(\"Input: \", l, r)\n    #ans1 = max_xor_naive(l, r)\nans2 = max_xor_efficient(l, r)\nprint(ans2)\n    #print(\"Ans Naive:\", ans1)\n    #print(\"Ans Efficient: \", ans2)\n\n'''\n    if ans1==ans2:\n        print(\"Verified OK\")\n    else:\n        print(\"Wrong Answer\")\n        break\n'''\n", "complexity": "logn"}
{"src": "a, b= list(map(int, input().split()))\nc = 1\nresult = a^b\nwhile c <= result:\n    c *= 2\nc -= 1\n \nprint(c)\n \t\t \t   \t\t\t\t \t\t   \t\t   \t  \t  \t", "complexity": "logn"}
{"src": "import io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nl,r=list(map(int,input().split()))\nif l==r:\n    print(0)\nelse:\n    a=bin(l)[2:]\n    b=bin(r)[2:]\n    x=len(a)\n    y=len(b)\n    if x!=y:\n        ans=0\n        for i in range(y):\n            ans+=(2**i)\n        print(ans)\n    else:\n        for i in range(x):\n            if a[i]!=b[i]:\n                ind=i\n                break\n        l=x-ind\n        ans=0\n        for i in range(l):\n            ans+=(2**i)\n        print(ans)\n                \n                ", "complexity": "logn"}
{"src": "n , k = map(int , input().split())\nn , k = n-1 , k-1\n\nl = 0\nr = k\ng = k*(k+1)//2\nans = -1\n\nwhile l <= r:\n \tm = (l+r)//2\n \tif g-m*(m+1)//2>=n:\n \t\tans = k-m\n \t\tl = m+1\n \telse:\n \t\tr = m-1\n\nprint(ans)", "complexity": "logn"}
{"src": "def valid(k, mid):\n    return (2*k - mid - 1) * mid // 2 + 1\n    \ndef binary_search(n, k):\n    l, r = 0, k-1\n    while (l <= r):\n        mid = l+r >> 1\n        if (valid(k, mid) < n):\n            l = mid+1\n        else:\n            r = mid-1\n    return r+1\n\ndef main():\n    n, k = map(int, input().split())\n    res = binary_search(n, k)\n    print(-1 if res == k else res)\n\nmain()\n", "complexity": "logn"}
{"src": "n, k = map(int, input().split())\n\nm = 2 * (n - 1) - k * (k - 1)\n\nif m > 0: print(-1)\n\nelse:\n\n    x = int((1 + (1 - 4 * m) ** 0.5) / 2)\n\n    if x * (x - 1) + m > 0: x -= 1\n\n    print(k - x)\n\n\n\n# Made By Mostafa_Khaled", "complexity": "logn"}
{"src": "import math\nfrom decimal import Decimal, ROUND_FLOOR\n\ndef sum2(s, e):\n    return sum1(e) - sum1(s - 1) - (e - s)\n\ndef sum1(i):\n    return i * (i + 1) / 2\n\nn, k = map(Decimal, input().split())\n\nif(n == 1):\n    print(0)\nelif(k > n):\n    print(1)\nelif(sum2(Decimal(2),k) < n):\n    print(-1)\nelse:\n    c = 2 * n + k - k * k\n    discriminant = (9 - 4 * c).sqrt()\n    res1 = int(((3 + discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res2 = int(((3 - discriminant) / 2).to_integral_exact(rounding=ROUND_FLOOR))\n    res1 = max(res1, res2)\n    print(k - res1 + 1);", "complexity": "logn"}
{"src": "import sys\ndef getSum(a):\n    sum1 = a * (a + 1) // 2\n    return sum1\ndef getSumOfTwo(a, b):\n    if a <= 1:\n        return getSum(b)\n    return getSum(b) - getSum(a - 1)\n\nn, k = [int(elem) for elem in input().split()]\nif n == 1:\n    print(0)\n    sys.exit(0)\nif n <= k:\n    print(1)\n    sys.exit(0)\nif getSum(k - 1) < n - 1:\n    print(-1)\n    sys.exit(0)\n\nn -= 1\nk -= 1\nleft, right = 1, k\nwhile left < right:\n    mid = (left + right) // 2\n    sum1 = getSumOfTwo(mid, k)\n    if sum1 == n:\n        print(k - mid + 1)\n        sys.exit(0)\n    if sum1 > n :\n        left = mid + 1\n    else:\n        right = mid\nprint(k - left + 2)\n\t\t \t\t\t  \t\t\t  \t\t\t \t  \t\t\t\t    \t\t", "complexity": "logn"}
{"src": "def lower_bound(n, k):\n    low = 1\n    high = k\n    while low < high:\n        mid = low + (high - low) // 2\n        pipes = mid * k - (mid + 2) * (mid - 1) // 2\n        if pipes >= n:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n\ndef main():\n    n, k = map(int, input().split())\n    if n == 1:\n        print(0)\n    else:\n        ans = lower_bound(n, k)\n        if ans == k:\n            print(-1)\n        else:\n            print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "complexity": "logn"}
{"src": "n, k = map(int, input().split())\n\ndef prod(n):\n\tif n%2:\n\t\treturn n*((n+1)//2)\n\telse:\n\t\treturn (n//2)*(n+1)\n\ndef total_count(n, k):\n\tif k >= n:\n\t\treturn (0, 0, 1)\n\telse:\n\t\tcount = 0\n\t\tl = 1; r = k\n\t\ts = prod(k)\n\t\twhile l <= r:\n\t\t\tmid = (l+r)//2\n\t\t\tif n > s - prod(mid) + mid:\n\t\t\t\tr = mid-1\n\t\t\telse:\n\t\t\t\tl = mid+1\n\n\t\tn = n - (s - prod(l) + l)\n\t\tcount += (k-l+1)\n\t\tk = l-1\n\t\treturn (n, k, count)\t\t\n\nif prod(k) - (k-1) < n:\n\tprint(-1)\nelif n == 1:\n\tprint(0)\nelif k >= n:\n\tprint(1)\nelse:\n\tn = n-k\n\tk = k-2\n\tcount = 1\n\twhile n > 0:\n\t\t(n, k, temp) = total_count(n, k)\n\t\tcount += temp\n\tprint(count)", "complexity": "logn"}
{"src": "n,m,k=map(int,input().split())\n\nMOD=1000000009\n\nx=m-(n//k*(k-1)+(n%k))\n\nif (x<=0):exit(print(m%MOD))\n\nprint(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)", "complexity": "logn"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nfrom io import BytesIO, IOBase\nimport sys\nfrom collections import defaultdict, deque, Counter\nfrom math import sqrt, pi, ceil, log, inf, gcd, floor\nfrom itertools import combinations, permutations\nfrom bisect import *\nfrom fractions import Fraction\nfrom heapq import *\nfrom random import randint\n\ndef main():\n    n, s = map(int, input().split())\n    lo, hi = s, n\n    ans = n + 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        z = sum(map(int, str(mid)))\n        if mid >= s + z:\n            ans = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    print(n - ans + 1)\n\n\n\n# region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "logn"}
{"src": "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left,bisect\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nn,k=map(int,input().split())\nx,y=1,n\nf=0\nwhile(x<=y):\n    m=(x+y)//2\n    s=0\n    p=m\n    while(p>0):\n        s+=p%10\n        p=p//10\n    m1=m-1\n    s1=0\n    p=m1\n    while(p>0):\n        s1+=p%10\n        p=p//10\n    if m==0 or (m-s>=k and m1-s1<k):\n        f=1\n        break\n    elif m-s<k:\n        x=m+1\n    else:\n        y=m-1\nif f:\n    print(n-m+1)\nelse:\n    print(0)\n        ", "complexity": "logn"}
{"src": "n, s = map(int, input().split())\n\ndef binsearch(n, s):\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        digits = sum([int(i) for i in list(str(mid))])\n        if mid - digits >= s:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return right\n#print(binsearch(n, s))\nprint(max(0, n - binsearch(n, s)))\n\n", "complexity": "logn"}
{"src": "import sys\ninput=sys.stdin.readline\nn,s=map(int,input().split())\nl=0;r=n+1\nwhile r-l>1:\n    x=(l+r)//2\n    cs=0\n    m=x\n    while m>0:\n        cs+=m%10\n        m//=10\n    if x-cs>=s:\n        r=x\n    else:\n        l=x\nprint(n-l)", "complexity": "logn"}
{"src": "def nine(p) :\n    \n    s=''\n    for i in range(p) :\n        s+='9'\n    return int(s)\ndef prosh(p) :\n    ans=0\n    for i in range(1,p+1) :\n        ans+=nine(i)*9\n    return ans\n        \nn,k=map(int,input().split())\nl=[0]*29\nfor i in range(19) :\n    \n    e=nine(19-i)\n    \n    l[i]=k//e\n    \n    k-=l[i]*e\n    \n    if k==0 :\n        \n        break\n    if i==18  or k%e>prosh(19-i-1) :\n        \n        l[i]+=1\n        break\notv=0\nfor i in range(19) :\n    \n    otv+=10**(19-i)*l[i]\n\nprint(max(n-otv+1,0))\n    \n    \n    \n        \n", "complexity": "logn"}
{"src": "n, s = map(int, input().split())\n \na, b, c = 0, n + 1, 0\n \nwhile a < b:\n    c = (a + b) // 2\n    if c - sum([int(x) for x in str(c)]) < s:\n        a = c + 1\n    else:\n        b = c\n \nprint(n - b + 1)", "complexity": "logn"}
{"src": "n,s=map(int,input().split())\nif s>=n:\n    print(\"0\")\n    exit()\nfor i in range(s,n+2):\n    cur=int(0)\n    for j in str(i):\n        cur+=int(j)\n    if i-cur>=s:\n        break\nprint(n-i+1)\n", "complexity": "logn"}
{"src": "n, s = map(int, input().split())\nmult_10 = s if not (s%10) else s+10-(s%10)\nfor i in range(mult_10, mult_10+100000, 10):\n\tif i - sum([int(c) for c in str(i)]) >= s:\n\t\tlow = i\n\t\tbreak\nprint(max(n-low+1, 0))\n\t\t   \t\t \t \t  \t  \t \t\t\t     \t\t\t\t", "complexity": "logn"}
{"src": "x, k = map(int, input().split())\nif x == 0:\n    print(0)\n    exit()\nmod = 10**9+7\nans = 1+(2*x-1)*pow(2, k, mod)\nprint(ans%mod)\n", "complexity": "logn"}
{"src": "from sys import stdin\n\nline = stdin.readline().rstrip().split()\nx = int(line[0])\nk = int(line[1])\n\nif x == 0:\n    print(0)\nelse:\n    nn = pow(2, k, 1000000007)\n    result = (nn*2*x - nn + 1) % 1000000007\n    print(result)\n\n\n\n", "complexity": "logn"}
{"src": "m = 1000000007\nx, k = map(int, input().split())\nup = (x * pow(2, k + 1, m)) % m\ndown = pow(2, k, m) - 1\nif (x == 0):\n    print(0)\nelse:\n    print((up - down) % m)", "complexity": "logn"}
{"src": "mod = 1000000000 + 7\n\nn, m = map(int, input().split())\n\nif n == 0:\n    print(0)\n    exit()\n\nans = n * 2\nans %= mod\n\nif m:\n    t = 1\n    x = 2\n    while m > 0:\n        if m & 1:\n            t = t * x % mod\n        x = x * x % mod\n        m >>= 1\n    ans -= 1\n    ans = (t * ans + 1) % mod\n\nprint(ans)", "complexity": "logn"}
{"src": "n,k=map(int,input().split())\nmod=int(1e9+7)\n\n'''\n_2k=2**k\n\nn2k=n*_2k\n\ns=(n2k*(n2k+1))/2\nn2k_2k=n2k-_2k\n\ns=s-((n2k_2k)*(n2k_2k+1))/2\n\ns=2*s\n\ns=s/_2k\n\ns=s%mod\nprint(int(s))\n'''\n\n#simplifying above we get:-\n\n\nif n>0: \n    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1\nelse: \n    ans=0\nprint(ans%mod)", "complexity": "logn"}
{"src": "import sys\n\nMOD = 10**9 + 7\n\nx,k = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = x*pow(2,k+1,MOD) % MOD \nb = (a - pow(2,k,MOD) + 1) % MOD\nprint(b if x != 0 else 0)", "complexity": "logn"}
{"src": "modulo = 1000 ** 3 + 7\n\n\ndef mat_oz(x, k):\n    if k == 0:\n        return (2 * x) % modulo\n    if x == 0:\n        return 0\n    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo\n    return b\n\n\ny, m = [int(i) for i in input().split()]\nprint(mat_oz(y, m))\n", "complexity": "logn"}
{"src": "M = 1000000007\nx, k  = map(int,input().split())\nif x==0:\n    print(0)\nelse:\n    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)    \n", "complexity": "logn"}
{"src": "import sys\n\ndef ask(x):\n    print('? %d'%x)\n    sys.stdout.flush()\n    x=int(input())\n    return x\n\nn=int(input())\nt=n//2\nif t&1:\n    print('! -1')\n    sys.stdout.flush()\n    sys.exit()\nl=1\nr=n\nwhile l<r:\n    mid=(l+r)>>1\n    if ask(mid)>=ask((mid+t-1)%n+1):\n        r=mid\n    else:\n        l=mid+1\nprint('! %d'%l)\nsys.stdout.flush()\n", "complexity": "logn"}
{"src": "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\nfrom sys import stdout\n\nask_count = 0\n#a = [0,1,0,1,2,3,4,5,4,3,2,1,0,1,2,1]\n#a = [-1, -2, -1, -2, -3, -2, -1, 0, 1, 0, -1, 0, 1, 0, 1, 2, 1, 0, 1, 0, 1, 0, 1, 0, -1, -2, -1, -2, -3, -4, -5, -6, -5, -6, -7, -6, -5, -4, -3, -2, -1, -2, -3, -4, -3, -4, -3, -4, -3, -2, -3, -4, -5, -6, -7, -6, -7, -6, -5, -6, -7, -6, -5, -6, -7, -6, -7, -8, -7, -6, -7, -6, -5, -6, -5, -4, -3, -4, -3, -2, -1, -2, -1, 0, 1, 2, 1, 0, -1, -2, -1, 0, 1, 2, 1, 0, 1, 0, 1, 0]\n#n = len(a)\n#print(\"n\", n)\nn = int(input())\n\n\n\ndef ask(num):\n    global ask_count\n    print(\"? \" + str(num))\n    stdout.flush()\n    ask_count += 1\n    return int(input())\n    #return a[num-1]\n\ndef ans(num):\n    print(\"! \" + str(num))\n    stdout.flush()\n\ndef opposite(num):\n    return num + n // 2\n\nlow = 1\nhigh = opposite(low)\nlval = ask(low)\nhval = ask(high)\nprev_l_less_h = (lval < hval)\n#print(prev_l_less_h)\n\n\nwhile high - low > 1:\n    #print(\"low\", low, \";high\", high)\n    mid = (low + high) // 2\n\n    lval = ask(mid)\n    hval = ask(opposite(mid))\n    l_less_h = (lval < hval)\n\n    if abs(lval - hval) % 2 == 1:\n        ans(-1)\n        exit(0)\n    elif hval == lval:\n        ans(mid)\n        exit(0)\n    else:\n        if l_less_h == prev_l_less_h:\n            low = mid\n        else:\n            high = mid\nans(-1)", "complexity": "logn"}
{"src": "t=int(input())\nfor ca in range(t):\n    asd=input().split()\n    n=int(asd[0])\n    k=int(asd[1])\n    if n>=40:\n        print(\"YES \"+str(n-1))\n    else:\n        ans=-1\n        for m in range(1,n+1):\n            asd=(4**m-1)//3\n            asd2=(2**m-1)**2\n            asd2*=(4**(n-m)-1)//3\n            asd+=asd2\n            if asd>=k and m*m<=k:\n                ans=n-m\n                break\n        if ans==-1:\n            print(\"NO\")\n        else:\n            print(\"YES \"+str(ans))\n", "complexity": "logn"}
{"src": "MAX = 1000\nf = [0]\nfor i in range(1, MAX):\n    f.append(f[i - 1] + (1 << (2 * i - 2)))\n\ng = [0]\nfor i in range(1, MAX):\n    g.append(g[i - 1] + (1 << i) - 1)\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split(' '))\n    ans = False\n    for i in range(1, n + 1):\n        if k >= g[i]:\n            if n >= MAX:\n                print(\"YES %d\" % (n - i))\n                ans = True\n            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:\n                print(\"YES %d\" % (n - i))\n                ans = True\n        if ans == True:\n            break\n    if ans == False:\n        print(\"NO\")\n        \n    ", "complexity": "logn"}
{"src": "T = int(input())\n\nwhile (T != 0):\n    T -= 1\n\n    N, K = map(int, input().split())\n    cur_usage = 0\n    reslog = 0\n    cnts = dict()\n\n    while True:\n        reslog += 1\n        cur_usage +=  (1 << reslog) - 1\n        if reslog != N:\n            cnts[reslog] = (((1 << reslog)-2)<<1) + 1\n\n        if cur_usage + (1 << (reslog+1))-1 > K or reslog == N:\n            break\n\n    K -= cur_usage\n\n    while K > 0:\n        if len(cnts) == 0:\n            break\n        for key in cnts:\n            K -= cnts[key]\n            if key+1 >= N:\n                del cnts[key]\n                break\n            if (key+1 not in cnts):\n                cnts[key+1] = 0\n            cnts[key+1] += cnts[key] * 4\n            del cnts[key]\n            break\n\n\n\n\n    if K <= 0:\n        print('YES %d' % (N-reslog))\n    else:\n        print('NO')\n        \n\n\n\n\n", "complexity": "logn"}
{"src": "from sys import stdin,stdout\nstdout.flush()\ndef qu(a,b):\n    print(\"?\",a,b)\n    return int(input())\na=0\nb=0\nbig=qu(a,b)\nfor i in range(29,-1,-1):\n    x=2**i\n    f=qu(a+x,b)\n    l=qu(a,b+x)\n    if l==f:\n        if big==1:\n            a+=x\n        else:\n            b+=x\n        big=f\n    elif f==-1:\n        a+=x\n        b+=x   \nprint(\"!\",a,b)\n\n", "complexity": "logn"}
{"src": "#a, b = map(int, input().split())\ndef interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)\n\ndef main():\n\tdef ask(c, d):\n\t\t#return interact(c, d)\n\t\tprint(\"?\", c, d, flush = True)\n\t\treturn int(input())\n\n\trelative = ask(0, 0)\n\tcurA = 0\n\tcurB = 0\n\n\tfor i in range(29, -1, -1):\n\t\tq1 = ask(curA ^ 2 ** i, curB)\n\t\tq2 = ask(curA, curB ^ 2 ** i)\n\t\n\t\tif q1 == q2:\n\t\t\tif relative == 1:\n\t\t\t\tcurA ^= 2 ** i\n\t\t\telse:\n\t\t\t\tcurB ^= 2 ** i\n\t\t\trelative = q1\n\t\telif q2 == 1:\n\t\t\tcurA ^= 2 ** i\n\t\t\tcurB ^= 2 ** i\n\treturn curA, curB\nprint(\"!\", *main())", "complexity": "logn"}
{"src": "from sys import stdout\nm = 30\na, b = 0, 0\nfle = 1\nfor i in range(m):\n    if fle:\n        print('? {} {}'.format(a, b))\n        stdout.flush()\n        resp1 = int(raw_input())\n        fle = 0\n    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))\n    stdout.flush()\n    resp2 = int(raw_input())\n    #print(resp1,resp2,a,b)\n    if resp1 == -1 and resp2 == 1:\n        b += 2**(m-1-i)\n        fle = 1\n    elif resp1 == 1 and resp2 == -1:\n        a += 2**(m-1-i)\n        fle = 1\n    else:\n        fle = 0\n        print('? {} {}'.format(a + 2**(m-1-i), b))\n        stdout.flush()\n        resp3 = int(raw_input())\n        if resp3 == -1:\n            b += 2**(m-1-i)\n            a += 2**(m-1-i)\n        #print(resp1,resp2,resp3,a,b)\nprint('! {} {}'.format(a,b))\nstdout.flush()", "complexity": "logn"}
{"src": "n, x, y = int(input())-1, 1, 9\nwhile n > x*y :\n\tn, x, y = n-x*y, x+1, 10*y\nprint(str(10**(x-1)+n//x)[n%x])", "complexity": "logn"}
{"src": "import math\nn=int(input())\n# 99-9\n# 999-99\na=[9]\nfor i in range(2,20):\n    a.append(10**i   - 10**(i-1) )\nb=[0]\nfor i in range(1,20):\n    b.append(b[-1]+ i*a[i-1])\nfor i in range(20):\n    if n<=b[i]:\n        break\np=b[i-1]\nk=n-p\n# print(p,k)\nans=10**(i-1) - 1 + math.ceil(k/(i))\n# print(k,p,i)\n# print(ans,i,k)\nif k%i==0:\n    print(('0'+str(ans))[i])\nelse:\n    print(('0'+str(ans))[k%i])", "complexity": "logn"}
{"src": "def mp():\n    return map(int, input().split())\n\ndef f(i):\n    return (10 ** i - 10 ** (i - 1)) * i\n\nn = int(input())\n\ni = 1\nsum = 0\nwhile n - f(i) >= 0:\n    n -= f(i)\n    sum += f(i) // i\n    i += 1\n\nprint(str(sum + (n + i - 1) // i)[n % i - 1])", "complexity": "logn"}
{"src": "\n\nn=int(input())\n\nx=1\n\nwhile n>(10**(len(str(x))-1)*9*len(str(x))):\n    n-=10**(len(str(x))-1)*9*len(str(x))\n\n    x*=10\n    \nt=len(str(x))\nnadighe=False\nwhile nadighe==False:\n    qw=1\n    nadighe=True\n    while n>(10**(len(str(qw))-1)*9*t):\n        n-=10**(len(str(qw))-1)*9*t\n        nadighe=False\n        qw*=10\n    x+=qw-1\n   \n    \nwhile n>len(str(x)):\n    n-=len(str(x))\n    x+=1\nfor i in range(len(str(x))):\n    if n!=0:\n        s=str(x)[i]\n        n-=1\nprint(s)\n    \n", "complexity": "logn"}
{"src": "n = int(input())\nlimit_int = limit = decimal = 9\ncount = 0\nwhile True:\n    count += 1\n    if n <= limit:\n        difference = limit - n\n        position = difference % count\n        difference = difference // count\n        difference = decimal - difference\n        print(''.join(list(reversed(str(difference))))[position])\n        break\n    else:\n        decimal = int(str(limit_int) * (count + 1))\n        limit += int(str(limit_int) + '0' * count) * (count + 1)\n", "complexity": "logn"}
{"src": "T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)\nk = int(input())\na = 0\nfor i in T:\n    if i - k > 0:\n        a = T.index(i)\n        break\ntemp = T[a] - k\nx = temp % a\nres = (10 ** a) - 1 - int(temp / a)\nans = int((res % (10 ** (x+1))) / (10 ** x))\nprint(ans)\n", "complexity": "logn"}
{"src": "n = int(input())-1\nx, y = 1, 9\nwhile n > x * y: n,x,y = n-x*y,x+1,y*10\na = str(10 ** (x - 1) + n // x)[n%x]\nprint(a)", "complexity": "logn"}
{"src": "k = int(input())\nx = [0,9]\ni = 2\ny = 90\nwhile x[-1] < 10**12:\n    x.append(x[-1]+y*i)\n    y *= 10\n    i += 1\nif k in x:\n    print(9)\nelse:\n    for t in range(len(x)):\n        if k < x[t]:\n            break\n    e = k-x[t-1]\n    if t == 1:q=str(e)\n    else:q =str(10**(t-1)+e//t-1)\n    if e%t == 0:\n        print(q[-1])\n    else:\n        q = str(int(q)+1)\n        print(q[e%t-1])\n", "complexity": "logn"}
{"src": "import math\nk = int(input())\n\n\ndef cnt_digit_order(X):\n    res = 0\n    if X == 0:\n        return 0\n    for i in range(1, X+1):\n        res += i*(9*pow(10, i-1))\n    return res\n\n\nL = -1\nleftcnt = 0\nfor length in range(1, 100):\n    if cnt_digit_order(length - 1) < k <= cnt_digit_order(length):\n        L = length\n        leftcnt = k - cnt_digit_order(length - 1)\n        break\n\n#L = digits/length\nM = str(math.ceil(leftcnt/L) + (10**(L-1) - 1))\nleftcnt -= 1\nleftcnt %= L\nprint(M[leftcnt])\n", "complexity": "logn"}
{"src": "def maximum_candies_after_n_movies(n):\n    return n * (n + 1) // 2\n\n\ndef solve1():\n    n,k = list(map(lambda x: int(x), input().split()))\n    m = maximum_candies_after_n_movies(n)\n    current_candies = n\n    eaten_candies = 0\n    while m != k:\n        m = m - current_candies - 1\n        current_candies -= 1\n        eaten_candies += 1\n\n    print(eaten_candies)\n\n\ndef solve():\n    n, k = list(map(lambda x: int(x), input().split()))\n    upper_bound = n\n    lower_bound = 0\n    while upper_bound > lower_bound:\n        if upper_bound == lower_bound + 1:\n            u_c = maximum_candies_after_n_movies(upper_bound)\n            if u_c == k:\n                print(n - upper_bound)\n                break\n\n        middle = (upper_bound + lower_bound) // 2\n        m_candies = maximum_candies_after_n_movies(middle) - (n - middle)\n        if m_candies == k:\n            print(n - middle)\n            break\n        elif m_candies < k:\n            lower_bound = middle\n        else :\n            upper_bound = middle\n\nsolve()\n\n", "complexity": "logn"}
{"src": "import math\n\ndef valid(n, k, c1, c2):\n    if c1 > n:\n        return c2\n    elif c2 > n:\n        return c1\n    ans_one = ((n - c1) * (n - c1 + 1) // 2) - c1\n    if ans_one == k:\n        return c1\n    return c2\n\n\ndef f(n, k):\n    b2 = (2 * n + 3)\n    delta = int(math.sqrt(8 * n + 8 * k + 9))\n    return valid(n, k, (b2 + delta) // 2, (b2 - delta) // 2)\n\n\nn, k = map(int, input().strip().split(' '))\nprint(f(n, k))\n", "complexity": "logn"}
{"src": "n,k = map(int,input().split())\n\ndef sumTillN (n) :\n    return (n*(n+1))//2\n\nminEat = 0\nmaxEat = n\nmidEat = 0\n\nwhile (minEat<=maxEat):\n    midEat = (minEat+maxEat)//2\n    x = sumTillN(n-midEat)\n    if (x==k+midEat):\n        break\n    elif (x>k+midEat):\n        minEat = midEat+1\n    else:\n        maxEat = midEat-1\n\nprint(midEat)\n", "complexity": "logn"}
{"src": "n,m=list(map(int,input().split()))\nfor i in range(1,n+1):\n    j=i*(i+1)//2\n#     print(j)\n    if j>=m:\n        if j==m and i==n:\n            print(0)\n            break\n        else:\n            t=n-i\n            if j-t==m:\n                print(t)\n                break\n            elif j-t<m:\n                \n                continue\n                \n            ", "complexity": "logn"}
{"src": "import math\n\ndef gaosi(x):\n    if (x==1):\n        return 1\n    else:\n        return ((1+x)*x)/2\n\ndef calc(mid, total, left):\n    return gaosi(mid) - (total - mid) - left\n\ndef main(): \n    x, left = map(int, input().split())\n    if (x == 1 and left == 1):\n        print(0)\n    else:\n        l = 1\n        r = x\n        while (True):\n            mid = math.floor((l + r) / 2)\n            result = calc(mid, x, left)\n            if (result == 0):\n                print(x - mid)\n                break\n            elif (result > 0):\n                r = mid\n            elif (result  < left):\n                l = mid\n\n    \nif __name__ == \"__main__\":\n    main()", "complexity": "logn"}
{"src": "import sys\nimport math\n#import random\n#sys.setrecursionlimit(100000000)\ninput = sys.stdin.readline\n \n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\ndef inp():\n    return(int(input()))\ndef inara():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\n################################################################\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\n\nn,k=invr()\n\nans=0\nlo=0\nhi=n\n\ndef possible(a,b):\n\tkoyta=a*(a+1)//2\n\treturn koyta>=b+k\n\nwhile hi>=lo:\n\tmid=(hi+lo)//2\n\t\n\tif possible(n-mid,mid):\n\t\tlo=mid+1\n\t\tans=mid\n\telse:\n\t\thi=mid-1\n\nprint(ans)\n\n", "complexity": "logn"}
{"src": "n , k = map(int, input().split())\n#K-\u041e\u0421\u0422\u0410\u041b\u041e\u0421\u042c, N-\u041a\u041e\u041b-\u0412\u041e \u0425\u041e\u0414\u041e\u0412\n# x - \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u043d\u0444\u0435\u0442 \u0441\u044a\u0435\u043b\u0438, n - x \u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043e\u043d\u0444\u0435\u0442\u044b \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u043b\u0438\n# x = n, \u0442\u043e \u043e\u0441\u0442\u0430\u043d\u0435\u0442\u0441\u044f -n \u043a\u043e\u043d\u0444\u0435\u0442, \u044d\u0442\u043e < k\n# x = 0, \u043e\u0441\u0442\u0430\u043d\u0435\u0442\u0441\u044f (1 + n) * n / 2 >= k\nl = 0\nr = n\nwhile r - l > 1:\n    mid = (r + l) // 2\n    a = n - mid\n    if ((1 + a) * a) // 2 >= k + mid:\n        l = mid\n    else:\n        r = mid\nprint(l)", "complexity": "logn"}
{"src": "#! /usr/bin/python3\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n, k = map(int, input().split())\n    print(n-int(((9+8*(n+k))**0.5-3)/2))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "logn"}
{"src": "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n % 2 == 1:\n        print('NO')\n        continue\n    n //= 2\n    l, r = 0, n + 2\n    while r - l > 1:\n        m = (l + r) // 2\n        if m * m <= n:\n            l = m\n        else:\n            r = m\n    if l * l == n:\n        print('YES')\n        continue\n    l, r = 0, n + 2\n    while r - l > 1:\n        m = (l + r) // 2\n        if m * m * 2 <= n:\n            l = m\n        else:\n            r = m\n    if l * l * 2 == n:\n        print('YES')\n        continue\n    print('NO')", "complexity": "logn"}
{"src": "def numtostr(a):\n    var=[]\n    while a>0:\n \n       if a%26==0:\n          var.append(\"Z\")\n          a=a//26-1\n       else:\n          var.append(chr(a%26-1+ord(\"A\")))\n          a=a//26\n    var.reverse()\n    return \"\".join(var)\n \ndef strtonum(b):\n    par=len(b)\n    result=0\n    for i in range(1,par):\n        result+=(26**i)\n    par=len(b)-1\n    for elem in b:\n        if par!=0:\n             result+=((ord(elem)-ord(\"A\"))*((26)**par))\n        else:\n            result += ((ord(elem) - ord(\"A\"))+1)\n \n        if par==0:\n            break\n        par -= 1\n    return result\n \ndef method1(par1):\n    C=par1.index(\"C\")\n    result=numtostr(int(par1[C+1:]))+str(par1[1:C])\n    return result\n \ndef method2(par2):\n    c=0\n    for elem in par2:\n        try:\n            if int(elem):\n                break\n        except:\n            c+=1\n    return \"R\"+par2[c:]+\"C\"+str(strtonum(par2[:c]))\n \ni=input()\ninp=[]\nfor j in range(int(i)):\n     x=input()\n     inp.append(x)\nfor key in range(len(inp)):\n    if \"R\" in inp[key] and \"C\" in inp[key]:\n        try:\n            if int(inp[key][1:inp[key].index(\"C\")]) and int(inp[key][inp[key].index(\"C\")+1:]):\n                print(method1(inp[key]))\n        except:\n            print(method2(inp[key]))\n    else:\n        print(method2(inp[key]))", "complexity": "linear"}
{"src": "def solution():\n    v = list()\n\n    n = int(input())\n    for _ in range(n):\n        s = input()\n        p = s.find('C')\n\n        # R23C55 -> BC23\n        if s[0] == 'R' and s[1].isdigit() and p > 1:\n            r = int(s[1:p])\n            c = int(s[(p + 1):])\n\n            v.clear()\n            while c > 0:\n                if c % 26 == 0:\n                    v.append('Z')\n                    c = (c - 1) // 26\n                else:\n                    v.append(chr(ord('A') + (c % 26 - 1)))\n                    c //= 26\n\n            v.reverse()\n            print(\"%s%d\" % (\"\".join(v), r))\n\n        else:\n            c = 0\n            p = 0\n            while p < len(s):\n                if s[p].isdigit():\n                    break\n                c = c * 26 + (ord(s[p]) - ord('A') + 1)\n                p += 1\n\n            print(\"R%sC%d\" % (s[p:], c))\n\n\nif __name__ == \"__main__\":\n    solution()\n", "complexity": "linear"}
{"src": "''' 25A - IQ test '''\ntry:\n    odd, even, oddIndex, evenIndex = 0, 0, 0, 0\n    n = int(input())\n    s = list(map(int, input().split()))\n    counter = 0\n    for i in s:\n        if i % 2 == 0:\n            even += 1\n            evenIndex = counter\n        else:\n            odd += 1\n            oddIndex = counter\n        counter += 1\n    ans = evenIndex + 1 if even == 1 else oddIndex + 1\n    print(ans)\nexcept EOFError as e:\n    pass", "complexity": "linear"}
{"src": "n, s = int(input()), input() * 2\nh = s.count('H') // 2\nprint(h - max(s[i:i + h].count('H') for i in range(n)))", "complexity": "linear"}
{"src": "# your code goes here\nimport sys\nn=int(input())\ns=input()\ns+=s\nh=0\nfor i in range(n):\n\tif s[i]=='H':\n\t\th+=1\nans=h\nfor i in range(n):\n\tc=0\n\tfor j in range(i,i+h):\n\t\tif s[j]=='T':\n\t\t\tc+=1\n\tans=min(ans,c)\nprint(ans)\n\t\n\n\t\n\t\n\t\n\n \t\t \t \t  \t\t\t \t \t  \t\t \t\t  \t  \t\t", "complexity": "linear"}
{"src": "\nn=int(input())\ns=list(input())\nt=list(input())\nd={}\nans=0\nx,y=-1,-1\nfor i in range(n):\n\tif s[i]!=t[i]:\n\t\td[(s[i],t[i])]=i\n\t\tans+=1\nl=[chr(i+97) for i in range(26)]\nfor i in l:\n\tfor j in l:\n\t\tif (i,j) in d and (j,i) in d:\n\t\t\tans-=2\n\t\t\tx=d[(i,j)]+1\n\t\t\ty=d[(j,i)]+1\n\t\t\tbreak\n\tif x!=-1:\n\t\tbreak\nif x==y==-1:\n\tfor i in l:\n\t\tfor j in l:\n\t\t\tfor k in l:\n\t\t\t\tif (i,j) in d and (j,k) in d:\n\t\t\t\t\tans-=1\n\t\t\t\t\tx=d[(i,j)]+1\n\t\t\t\t\ty=d[(j,k)]+1\n\t\t\t\t\tbreak\n\t\tif x!=-1:\n\t\t\tbreak\nprint(ans)\nprint(x,y)", "complexity": "linear"}
{"src": "from sys import stdin\nfrom bisect import *\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\nn, mem, pos, power = int(input()), [1], [], []\na = sorted(rints_2d(n))\n\nfor x, y in a:\n    pos.append(x)\n    power.append(y)\n\nfor i in range(1, n):\n    ix = bisect_left(pos, pos[i] - power[i]) - 1\n    if ix == -1:\n        mem.append(1)\n    else:\n        mem.append(mem[ix] + 1)\n\nprint(n - max(mem))\n", "complexity": "linear"}
{"src": "\nM = {}\n\nN = int(input())\nS = input().strip()\n\ns = set()\nfor c in S:\n    s.add(c)\n    M[c] = 0\n\ni = 0; j = -1; aux = 0; ans = 1e10\nwhile j < N - 1:\n    j += 1\n\n    M[S[j]] += 1\n    if M[S[j]] == 1:\n        aux += 1\n    while M[S[i]] > 1:\n        M[S[i]] -= 1\n        i += 1\n\n    if aux == len(s):\n        ans = min(ans, j - i + 1)\n\nprint(ans)\n", "complexity": "linear"}
{"src": "str1,str2=map(str,input(\"\").split())\nlst=[]\nlst_ans=[]\nl_count=0\ncount=0\nfor i in str2:\n    if(count<1):\n        lst.append(i)\n    else:\n        break\nfor i in str1:\n    if(count==0):\n        lst_ans.append(i)\n        count+=1\n    elif(ord(i)<ord(lst[0])):\n        lst_ans.append(i)\n    else:\n        lst_ans.append(lst[0])\n        break\nelse:\n    lst_ans.append(lst[0])\nprint(''.join(lst_ans))  ", "complexity": "linear"}
{"src": "def if_Spruce(n,l,m):\n    d=[0]*(n+1)\n    for i in range(1, n + 1):\n        if m[i] == 0:\n            d[l[i]] += 1\n    for i in range(1, n + 1):\n        if m[i] > 0 and d[i] < 3:\n            return \"No\"\n    return \"Yes\"\n\n\nn=int(input())\nl,m,a=[0]*2,[0]*(n+1),0\nfor _ in range(n-1):\n    a=int(input())\n    l.append(a)\n    m[a]+=1\nprint(if_Spruce(n,l,m))\n", "complexity": "linear"}
{"src": "s0=input()\nk=int(input())\ns1=s0[::-1]\nlens1=len(s1)\nmaxnum=1005\nmod=1000000007\ndp=[[0]*maxnum for tmpi in range(maxnum)]\nf=[0]*maxnum\nc=[[0]*maxnum for tmpi in range(maxnum)]\n\ndef cntone(num):\n    tmps=bin(num)[2:]\n    cnt=0\n    for i in range(len(tmps)):\n        if(tmps[i]=='1'):\n            cnt+=1\n    return cnt\n\nfor i in range(1,maxnum):\n    if(i==1):\n        f[i]=0\n    else:\n        f[i]=f[cntone(i)]+1\n\nfor i in range(maxnum):\n    if(i==0):\n        c[i][0]=1\n        continue\n    for j in range(i+1):\n        if(j==0):\n            c[i][j]=1\n        else:\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod\n\nfor i in range(lens1):\n    if(i==0):\n        dp[i][0] = 1\n        if(s1[i]=='1'):\n            dp[i][1]=1\n        else:\n            dp[i][1]=0\n        continue\n    else:\n        for j in range(0,i+2):\n            if(j==0):\n                dp[i][j]=1\n                continue\n            if(s1[i]=='1'):\n                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod\n            else:\n                dp[i][j]=dp[i-1][j]%mod\n\nans=0\n\nfor i in range(1,lens1+1):\n    if(f[i]==k-1):\n        ans=(ans+dp[lens1-1][i])%mod\n\nif(k==0):\n    ans=1\nelif(k==1):\n    ans-=1\nelse:\n    ans=ans\nprint(ans)", "complexity": "linear"}
{"src": "n=int(input())\na=list(map(int,input().split()))\nb=[]\nmaxi=0\nfor i in range(n):\n    maxi=max(maxi,a[i]+1)\n    b.append(maxi)\nc=[]\ncount=b[-1]\nfor i in range(n-1,-1,-1):\n    if count-1>=b[i]:\n        count-=1\n        c.append(count)\n    else:\n        c.append(count)\nc=c[::-1]\nans=0\nfor i in range(n):\n    ans+=(c[i]-a[i]-1)\nprint(ans)", "complexity": "linear"}
{"src": "n = int(input())\nAb = input().split()\nUn = []\nAl = [0]\nr = 0\nfor i in range(n):\n    Ab[i] = int(Ab[i])\n    Al.append(max(Ab[i]+1,Al[i]))\nfor i in range(n,-1,-1):\n    if Al[i-1] < Al[i] - 1:\n        Al[i-1] = Al[i] - 1\nfor i in range(n):\n    Un.append(Al[i+1]-Ab[i]-1)\n    r += Un[-1]\nprint(r)\n", "complexity": "linear"}
{"src": "n, p=map(int, input().split())\narr=list(map(int, input().split()))\nsu=0\nfor i in range(n):\n\tsu+=arr[i]\nmaxi, f=0, 0\nfor i in range(n-1):\n\tf+=arr[i]\n\tmaxi=max(maxi, f%p+(su-f)%p)\nprint(maxi)", "complexity": "linear"}
{"src": "from collections import defaultdict\nfrom sys import stdin\n\ninput = stdin.readline\n\ndct = defaultdict(int)\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    t = input().strip()\n    a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('/') + 1:]))\n    x = (a + b) / c\n    lst[i] = x\n    dct[x] += 1\nfor i in lst:\n    print(dct[i], end=' ')\n", "complexity": "linear"}
{"src": "import sys\ninput = sys.stdin.readline\nn = int(input())\nif n < 6:\n    print(-1)\n\nelse:\n    l = []\n    o = []\n    x = (3+n)//2\n    for i in range(3,x+1):\n        l.append((1,i))\n\n    for i in range(x+1,n+1):\n        o.append((2,i))\n\n    sys.stdout.write(\"1\"+\" \"+\"2\"+\"\\n\")\n    for x in l:\n        sys.stdout.write(str(x[0]) + \" \" + str(x[1]) + \"\\n\")\n\n    for x in o:\n        sys.stdout.write(str(x[0]) + \" \" + str(x[1]) + \"\\n\")\n\nsys.stdout.write(\"1\"+\" \"+\"2\"+\"\\n\")\np = 2\nfor i in range(3,n+1):\n    sys.stdout.write(str(p) + \" \" + str(i) + \"\\n\")\n    p = i\n\n", "complexity": "linear"}
{"src": "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dc\nfrom collections import Counter\nfrom bisect import bisect_right, bisect_left\nimport math\nfrom operator import itemgetter\nfrom heapq import heapify, heappop, heappush\nfrom queue import PriorityQueue as pq\nn=int(input())\nif n<=5:\n    print(-1)\nelse:\n    for i in range(2,5):\n        print(1,i)\n    for i in range(5,n+1):\n        print(2,i)\nfor i in range(2,n+1):\n    print(1,i)", "complexity": "linear"}
{"src": "from sys import stdin, stdout\nfrom itertools import accumulate\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):#nmbr()):\n    n,k=lst()\n    a=lst()\n    b=lst()\n    ps=list(accumulate(a))\n    dp=[[0 for _ in range(2)] for _ in range(1+n)]\n    for i in range(1,n+1):\n        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]\n        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])\n    # print(dp)\n    print(max(max(v) for v in dp))", "complexity": "linear"}
{"src": "from sys import stdin, stdout\nfrom itertools import accumulate\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int, stdin.readline().split()))\nfor _ in range(1):#nmbr()):\n    n,k=lst()\n    a=lst()\n    b=lst()\n    ps=list(accumulate(a))\n    dp=[[0 for _ in range(2)] for _ in range(1+n)]\n    for i in range(1,n+1):\n        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]\n        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])\n    # print(dp)\n    print(max(dp[n]))", "complexity": "linear"}
{"src": "import bisect\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    return bisect.bisect_left(p, p[-1] / 2)\n\nprint(solve())", "complexity": "linear"}
{"src": "#########################################################################################################\\\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\nimport sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nimport math \n\n\n\n\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\n\n\n#for deep recursion__________________________________________-\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef ncr(n, r, p):  \n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\ndef primeFactors(n): \n    l = []\n    while n % 2 == 0: \n        l.append(2)\n        n = n / 2\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0: \n            l.append(int(i))\n            n = n / i \n    if n > 2: \n        l.append(n)\n    c = dict(Counter(l))\n    return list(set(l))\n    # return c\n\ndef power(x, y, p) : \n\tres = 1\n\tx = x % p \n\tif (x == 0) : \n\t\treturn 0\n\twhile (y > 0) : \n\t\tif ((y & 1) == 1) : \n\t\t\tres = (res * x) % p \n\t\ty = y >> 1\t # y = y/2 \n\t\tx = (x * x) % p \t\t\n\treturn res \n\n#____________________GetPrimeFactors in log(n)________________________________________\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i): \n                if (spf[j] == j):\n                    spf[j] = i\n    return spf\ndef getPrimeFactorizationLOGN(x):\n    spf = sieveForSmallestPrimeFactor()\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x // spf[x]  \n    return ret\n#____________________________________________________________\n\n\n\ndef SieveOfEratosthenes(n): \n    #time complexity = nlog(log(n))\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\ndef si():\n    return input()\ndef divideCeil(n,x):\n    if (n%x==0):\n        return n//x\n    return n//x+1\ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\n\n#__________________________TEMPLATE__________________OVER_______________________________________________________\n\n\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef solve():\n    n,a,b,c,t = li()\n    ti = li()\n    if b>c:\n        print(n*a)\n    else:\n        ans = 0\n        ti.sort()\n        for i in ti:\n            ans+=(t-i)*(c-b)+a \n        print(ans)\n\n\nt = 1\n# t = ii()\nfor _ in range(t):\n    solve()\n", "complexity": "linear"}
{"src": "from __future__ import division\nfrom sys import stdin, stdout\nfrom collections import *\n\nrstr = lambda: stdin.readline().strip()\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\nrstr_2d = lambda n: [rstr() for _ in range(n)]\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrint_2d = lambda n: [rint() for _ in range(n)]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nceil1, out = lambda a, b: (a + b - 1) // b, []\n\nn, s = rints()\na, ans = rints_2d(n), -1\n\nfor i in range(26):\n    for j in range(60):\n        tem = i * 60 + j\n        ans = (i, j)\n        for h, m in a:\n            tem2 = h * 60 + m\n            if tem <= tem2:\n                if tem2 - (tem + 1) < s:\n                    ans = -1\n                    break\n            else:\n                if tem - (tem2 + 1) < s:\n                    ans = -1\n                    break\n\n        if ans != -1:\n            print('%d %d' % (ans[0], ans[1]))\n            exit()\n", "complexity": "linear"}
{"src": "I=lambda:map(int,input().split())\nn,s=I()\nl=[0]\nfor i in range(n):\n    q,w=I()\n    q=q*60+w\n    l+=[q]\nif l[1]-l[0]>s:exit(print(0, 0))\nfor i in range(n):\n    if l[i+1]-l[i]>2*s+1:\n        l[i]+=s+1\n        exit(print(l[i]//60,l[i]%60))\nl[-1]+=s+1\nprint(l[-1]//60,l[-1]%60)", "complexity": "linear"}
{"src": "import atexit\nimport io\nimport sys\n\n# Buffering IO\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n    \n\ndef main():\n    n, a, b = [int(x) for x in input().split()]\n    dc = {}\n    for i in range(n):\n        x, vx, vy = [int(x) for x in input().split()]\n        nx = x + vx\n        ny = a*x+b + vy\n        dd = a*nx - ny + b\n        if dd not in dc:\n            dc[dd] = {}\n        if (vx,vy) not in dc[dd]:\n            dc[dd][(vx,vy)] = 0\n        dc[dd][(vx,vy)] += 1\n    \n    tot = 0\n    for v,k in dc.items():\n        tt = 0\n        pp =0\n        for _,cc in k.items():\n            tt -= cc * (cc+1) // 2\n            pp += cc\n        tt += pp * (pp+1) // 2\n        tot += tt*2\n    print(tot)\n        \n\n    \nif __name__ == '__main__':\n    main()\n        ", "complexity": "linear"}
{"src": "import atexit\nimport io\nimport sys\n\n# Buffering IO\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n\ndef main():\n    n, a, b = [int(x) for x in input().split()]\n    dc = {}\n    for i in range(n):\n        x, vx, vy = [int(x) for x in input().split()]\n        nx = x + vx\n        ny = a * x + b + vy\n        dd = a * nx - ny + b\n        if dd not in dc:\n            dc[dd] = {}\n        if (vx, vy) not in dc[dd]:\n            dc[dd][(vx, vy)] = 0\n        dc[dd][(vx, vy)] += 1\n\n    tot = 0\n    for v, k in dc.items():\n        tt = 0\n        pp = 0\n        for _, cc in k.items():\n            tt -= cc * (cc + 1) // 2\n            pp += cc\n        tt += pp * (pp + 1) // 2\n        tot += tt * 2\n    print(tot)\n\n\nif __name__ == '__main__':\n    main()", "complexity": "linear"}
{"src": "num=int(input())\n\nb=input()\n\nif b=='0' or b=='1':\n    print(b)\n\nelse:\n    s=len(list(filter(lambda x:x=='0',b)))\n\n    print('1'+'0'*s)", "complexity": "linear"}
{"src": "import re\ninput()\nprint(sum(len(f)-2 for f in re.findall('x{3,}',input())))", "complexity": "linear"}
{"src": "from collections import Counter\n\ndef f(x):\n    return max(list(Counter(x).values()))\n\nn=int(input())\nz=input()\nl=len(z)\na=f(z)\nb=f(input())\nc=f(input())\n\ndef v(x):\n    if x==l:\n        return x-1\n    else:\n        return x+1\n\nif n==1:\n    a, b, c=v(a), v(b), v(c)\n    if a>b and a>c:\n        print(\"Kuro\")\n    elif b>a and b>c:\n        print(\"Shiro\")\n    elif c>a and c>b:\n        print(\"Katie\")\n    else:\n        print(\"Draw\")\nelif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:\n    print(\"Draw\")\nelif a>b and a>c:\n    print(\"Kuro\")\nelif b>a and b>c:\n    print(\"Shiro\")\nelif c>a and c>b:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")\n#print((l-a<=n)+(l-b<=n)+(l-c<=n))\n#print(a, b, c)", "complexity": "linear"}
{"src": "n,m,a,b=[int(x) for x in input().split()]\nif n>m:\n\tif n%m==0:\n\t\tprint(0)\n\telse:\n\t\tt1=n%m\n\t\tprint(min(t1*b,(m-t1)*a))\nelif n==m:\n\tprint(0)\nelse:\n\tprint(min(n*b,(m-n)*a))", "complexity": "linear"}
{"src": "n,m,a,b=map(int, input().split())\nprint(min(n%m*b, (m-n%m)*a))", "complexity": "linear"}
{"src": "inf=10**9\n\nn=int(input())\nt=[0]*n\nm={}\nfor j in range(n):\n\n\n    s=input()\n\n\n    bal=0\n    req=0\n\n    for i in s:\n        if i==\")\":\n            bal-=1\n        else:\n            if bal<0:\n                req+=bal\n                bal=1\n            else:\n                bal+=1\n\n    if req<0:\n        if bal>0:\n            req=inf\n        else:\n            req+=bal\n    else:\n        req=bal\n\n    t[j]=req\n\n    if req not in m:\n        m[req]=1\n    else:\n        m[req]+=1\n\nres=0\n\nfor i in t:\n    if i>=0:\n        if -i in m:\n            res+=m[-i]\n\nprint(res)\n", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nd = set(a)\nif (0 in a): \n    print(len(d)-1)\nelse:\n    print(len(d))", "complexity": "linear"}
{"src": "n=int(input())\nl=list(map(int,input().split()))\ns=set(l)\nx=0\nif x in s:\n    print(len(s)-1)\nelse:\n    print(len(s))", "complexity": "linear"}
{"src": "num = int(input())\nlayne = input()\nlayne = layne.split()\nlayne = [int(i) for i in layne]\nmx = max(layne)\ndorf = mx * 2 * num\nindx = 1\nfor i in range(num):\n    dor = (layne[i] // num) * num\n    if (layne[i] % num) - i > 0:\n        dor = dor + num + i + 1\n    else:\n        dor = dor + i + 1\n    if dor < dorf:\n        dorf = dor\n        indx = i + 1\nprint(indx)", "complexity": "linear"}
{"src": "n,m=map(int, input().split())\na=list(map(int, input().split()))\nt=n//m\nremain=[[] for i in range(m)]\nfor i in range(n):\n    x=a[i]%m\n    remain[x].append(i)\nans=0\nf=[]\nfor i in range(2*m):\n    cur=i%m\n    while len(remain[cur])>t:\n        elm=remain[cur].pop()\n        f.append([elm,i])\n    while len(remain[cur])<t and len(f)!=0:\n        elm,j=f.pop()\n        remain[cur].append(elm)\n        a[elm]+=abs(i-j)\n        ans+=abs(i-j)\nprint(ans)\nprint(*a)\n", "complexity": "linear"}
{"src": "n, M = map(int, input().split())\nA = list(map(int, input().split()))\nA = [0]+A+[M]\nD = []\nfor i in range(n+1):\n    D.append(A[i+1]-A[i])\n#print(D)\nE = []\nO = []\nfor i, d in enumerate(D):\n    if i%2 == 0:\n        E.append(d)\n        O.append(0)\n    else:\n        O.append(d)\n        E.append(0)\nfrom itertools import accumulate\nCE = [0]+E\nCE = list(accumulate(CE))\nCO = [0]+O\nCO = list(accumulate(CO))\n\n#print(CE)\n#print(CO)\nans = CE[-1]\nfor i in range(n+1):\n    if D[i] == 1:\n        continue\n    temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1]\n    #print(i, temp)\n    ans = max(ans, temp)\nprint(ans)\n", "complexity": "linear"}
{"src": "#Winners never quit, quiters never win............................................................................\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \n\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n\n   \n#here we go......................\n#winners never quit, quitters never win\nn,d=map(int,input().split())\nx=list(map(int,input().split()))\nans=0\nfor i in range(1,n):\n    diff=x[i]-x[i-1]\n    #print(x[i]-d)\n    #print(x[i-1]+d,\"xnwxnwisj\")\n    if diff >= 2*d:\n        ans+=min(2,(x[i]-d)-(x[i-1]+d)+1)\n        #print(ans,\"ans\")\nans+=2\nprint(ans)", "complexity": "linear"}
{"src": "import math\nn,k=map(int,input().split())\nfor _ in range(k):\n    l,r=map(int,input().split())\nfor i in range(1,n+1):\n    if i%2==0:\n        print('0',end='')\n    else:\n        print('1',end='')\nprint()\n\n", "complexity": "linear"}
{"src": "n,m = map(int,input().split())\nfor _ in range(m):\n    x,y = map(int,input().split())\n\ncnt = 0\nans = []\nfor i in range(n):\n    if cnt%2 == 0:\n        ans.append(\"0\")\n\n    else:\n        ans.append(\"1\")\n\n    cnt += 1\n\nprint(\"\".join(ans))", "complexity": "linear"}
{"src": "n,m=map(int,input().split())\nc=0;ans=str()\nfor i in range(n):\n  ans+=str(c^1)\n  c=c^1\nprint(ans)\n", "complexity": "linear"}
{"src": "import sys\nfrom math import sqrt,log2\nfrom collections import Counter\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn=input()\nct=0\ni=0\ns=[]\nwhile i <len(n):\n    if not int(n[i])%3:\n        ct+=1\n        s.clear()\n    else:\n        t=int(n[i])%3\n        if 3-t in s:\n            ct+=1\n            s.clear()\n        else:\n            s.append(t)\n    if len(s)==3:\n        ct+=1\n        s.clear()\n    i+=1\n\nprint(ct)", "complexity": "linear"}
{"src": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        stime = time.perf_counter()\n        res = func(*args, **kwargs)\n        elapsed = time.perf_counter() - stime\n        print(f\"{func.__name__} in {elapsed:.4f} secs\")\n        return res\n    return wrapper\n\nclass solver:\n    # @timer\n    def __init__(self):\n        pass\n\n    def __call__(self):\n        MOD = 998244353\n        N = 1000007\n        pow2 = [0] * N        \n\n        n = int(input())\n        a = list(map(int, input().strip().split()))\n\n        pow2[0] = 1\n        for i in range(n):\n            pow2[i + 1] = (2 * pow2[i]) % MOD\n\n        res = 0\n        for i in range(1, n):\n            tmp = (a[i - 1] * (n + 2 - i)) % MOD\n            res += (pow2[n - 1 - i] * tmp) % MOD\n            res %= MOD\n        res += a[n - 1]\n        res %= MOD            \n        print(res)        \n\nsolver()()", "complexity": "linear"}
{"src": "# import os\n\nn = int(input())\n\nr = []\nfor _ in range(n):\n    a,b,c,d = map(int,input().split())\n    r.append(sum([a,b,c,d]))\n\nthomas = r[0]\nprint(sorted(r, reverse=True).index(thomas)+1)\n", "complexity": "linear"}
{"src": "import math\nn = int(input())\nA = [i + 1 for i in range(n)]\nx = int(math.sqrt(n))\nX = [A[i:i + x] for i in range(0, len(A), x)]\nX = X[::-1]\nf = [item for sublist in X for item in sublist]\nprint(*f)", "complexity": "linear"}
{"src": "a=input()\nn=len(a)\nb=[]\nc=0\nd=0\nfor i in range(1,n):\n    if a[i]==a[i-1]:\n        b.append(['bw'.find(a[c]),i-c])\n        d=max(d,i-c)\n        c=i\nb.append(['bw'.find(a[c]),n-c])\nd=max(d,n-c)\nif d<n and b[0][0]==(b[-1][0]+b[-1][1])%2:\n    d=max(d,b[-1][1]+b[0][1])\nprint(d)", "complexity": "linear"}
{"src": "from collections import defaultdict, deque, Counter\nfrom sys import stdin, stdout\nfrom heapq import heappush, heappop\nimport math\nimport io\nimport os\nimport math\nimport bisect\n\n#?############################################################\n\n\ndef isPrime(x):\n    for i in range(2, x):\n        if i*i > x:\n            break\n        if (x % i == 0):\n            return False\n    return True\n\n#?############################################################\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n\n\n#?############################################################\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n))+1, 2):\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\n#?############################################################\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n#?############################################################\n\n\ndef sieve(n):\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\n#?############################################################\n\ndef digits(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n#?############################################################\n\n\ndef ceil(n, x):\n    if (n % x == 0):\n        return n//x\n    return n//x+1\n\n#?############################################################\n\n\ndef mapin():\n    return map(int, input().split())\n\n#?############################################################\n\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# python3 15.py<in>\n\ns = list(input())\nn = len(s)\nl = [1]\nfor i in range(n-1):\n    if(s[i]!= s[i+1]):\n        l[-1]+=1\n    else:\n        l.append(1)\n\nans = max(l)\nif(len(l)>1):\n    if(s[0]!= s[-1]):\n        ans = max(ans, l[0]+l[-1])\n# print(l)\nprint(ans)\n\n    \n\n\n\n", "complexity": "linear"}
{"src": "n = int(input())\nc = [0] + [int(j) for j in input().split()]\na = [0] + [int(j) for j in input().split()]\nvis = [0] * (n + 1)\nans = 0\nfor i in range(1, n + 1):\n    x = i\n    while vis[x] == 0:\n        vis[x] = i\n        x = a[x]\n    if vis[x] != i:\n        continue\n    v = x\n    mn = c[x]\n    while a[x] != v:\n        x = a[x]\n        mn = min(mn, c[x])\n    ans += mn\nprint(ans)\n", "complexity": "linear"}
{"src": "from sys import stdin\ninput=stdin.readline\n\ndef intersec(arr):\n    a=sorted(arr,key=lambda s:s[0],reverse=True)\n    b=sorted(arr,key=lambda s:s[1])\n\n    x, y = 0, 0\n    if a[0]==b[0]:\n        return max(b[1][1]-a[1][0],0)\n    else:\n        x=b[0][1]-a[1][0]\n        y=b[1][1]-a[0][0]\n    return max(x,y,0)\nblanck=[]\nfor i in range(int(input())):\n    a,b=map(int,input().strip().split())\n    blanck.append([a,b])\nprint(intersec(blanck))", "complexity": "linear"}
{"src": "# import itertools\n# import bisect\n# import math\nfrom collections import defaultdict\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n# sys.setrecursionlimit(10 ** 5)\nii = lambda: int(input())\nlmii = lambda: list(map(int, input().split()))\nslmii = lambda: sorted(map(int, input().split()))\nli = lambda: list(input())\nmii = lambda: map(int, input().split())\nmsi = lambda: map(str, input().split())\n\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b): return (a * b) // gcd(a, b)\n\n\ndef main():\n    # for _ in \" \" * int(input()):\n    n = ii()\n    d = defaultdict(int)\n    ll = defaultdict(list)\n    rr = defaultdict(list)\n    llst = []\n    rlst = []\n    lst = []\n    for i in range(n):\n        l, r = mii()\n        lst.append([l,r])\n        llst.append(l)\n        rlst.append(r)\n        ll[l].append(r)\n        rr[r].append(l)\n    left = max(llst)\n    right = min(rlst)\n    lleft = min(ll[left])\n    lright = max(rr[right])\n    lst.remove([left,lleft])\n    pl = max(i[0] for i in lst)\n    pr = min(i[1] for i in lst)\n    mx = max(0,pr-pl)\n    lst.append([left,lleft])\n    lst.remove([lright,right])\n    pl = max(i[0] for i in lst)\n    pr = min(i[1] for i in lst)\n    print(max(mx, max(0,pr-pl)))\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nres = []\nif n == 1:\n    print(1)\n    exit(0)\n\ni = 0\nif a[0] < a[1]:\n\n    if i >= n - 2:\n        res = [1]\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [1]\n            cur = 2\n        elif a[i + 1] > a[i + 2]:\n            res = [1]\n            cur = 5\n        else:\n            res = [1]\n            cur = 2\n\n    # res = [1]\n    # cur = 2\nelif a[0] > a[1]:\n\n    if i >= n - 2:\n        res = [5]\n        cur = 4\n    else:\n        if a[i + 1] < a[i + 2]:\n            res = [5]\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res = [5]\n            cur = 4\n        else:\n            res = [5]\n            cur = 4\n\n    # res = [5]\n    # cur = 4\nelse:\n    if i >= n - 2:\n        res.append(1)\n        cur = 2\n    else:\n        if a[i + 1] < a[i + 2]:\n            res.append(2)\n            cur = 1\n        elif a[i + 1] > a[i + 2]:\n            res.append(4)\n            cur = 5\n        else:\n            res.append(2)\n            cur = 3\n\nfor i in range(1, n - 1):\n    if not (1 <= cur <= 5):\n        # print(i, res)\n        print(-1)\n        exit(0)\n    res.append(cur)\n    if a[i] > a[i + 1]:\n\n        if i >= n - 2:\n            cur -= 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur = min(cur - 1, 1)\n            elif a[i + 1] > a[i + 2]:\n                cur -= 1\n            else:\n                cur -= 1\n\n        # cur -= 1\n    elif a[i] < a[i + 1]:\n\n        if i >= n - 2:\n            cur += 1\n        else:\n            if a[i + 1] < a[i + 2]:\n                cur += 1\n            elif a[i + 1] > a[i + 2]:\n                cur = max(cur + 1, 5)\n            else:\n                cur += 1\n\n        # cur += 1\n    else:\n        if i >= n - 2:\n            if cur != 3:\n                cur = 3\n            else:\n                cur = 2\n        else:\n            if a[i + 1] < a[i + 2]:\n                if cur == 1:\n                    cur = 2\n                else:\n                    cur = 1\n            elif a[i + 1] > a[i + 2]:\n                if cur == 5:\n                    cur = 4\n                else:\n                    cur = 5\n            else:\n                if cur != 3:\n                    cur = 3\n                else:\n                    cur = 2\nif not (1 <= cur <= 5):\n    # print(i, res)\n    print(-1)\n    exit(0)\nres.append(cur)\nprint(*res)\n", "complexity": "linear"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n\ns1 = input() +'0'\ns2 = input() +'0'\n\nres = 0\n\ni = 0\nwhile i<N:\n    if s1[i] != s2[i]:\n        if s1[i+1] == s2[i] and s2[i+1] == s1[i]:\n            res+=1\n            i+=2\n            continue\n        res+=1\n    i+=1\nprint(res)\n\n    \n\n\n\n\n\n\n", "complexity": "linear"}
{"src": "n = int(input())\na = list(input())\nb = list(input())\n\nans = 0\ni = 0\nwhile i < n:\n    if a[i] != b[i]:\n        ans += 1\n        if i < n - 1 and a[i] == b[i + 1] and b[i] == a[i + 1]:\n            i += 1\n    i += 1\nprint(ans)\n", "complexity": "linear"}
{"src": "from math import *\n#n,k=map(int,input().split())\n#A = list(map(int,input().split()))\nn=int(input())\nA = list(map(int,input().split()))\nans =-1\nmaxs = 0\nfor j in range(n):\n    if(A[j] > maxs):\n        ans = j+1\n        break\n    else:\n        maxs = max(maxs,A[j]+1)\nprint(ans)", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nmax_el = -1;\ner = -1;\nfor i in range(len(a)):\n    if a[i] - max_el > 1:\n        er = i + 1;\n        break\n    if a[i] > max_el:\n        max_el = a[i]\n\nprint(er)\n", "complexity": "linear"}
{"src": "n, k = map(int, raw_input().split())\na = map(int, raw_input().split())\nfor i in range(n):\n    ai = a[i]\n    nai = ((1<<k) - 1)^ai\n    if nai < ai:\n        a[i] = nai\n\nfrom collections import Counter\nC = Counter()\nC[0] += 1\nS = 0\ncnt = 0\nfor j, ai in enumerate(a):\n    nai = ((1<<k) - 1)^ai\n    v1, v2 = C[S^ai], C[S^nai]\n    if v1 <= v2:\n        cnt += j + 1 - v1\n        S ^= ai\n        C[S] += 1\n    else:\n        cnt += j + 1 - v2\n        S ^= nai\n        C[S] += 1\nprint(cnt)\n    \n", "complexity": "linear"}
{"src": "from sys import stdin\nfrom collections import Counter\n\nclass Node:\n    def __init__(self,val):\n        self.val=val\n        self.forw=set()\n        self.cou=0\n\n    def __str__(self):\n        return f'{self.val} {self.forw} {self.cou}'\n\nn=int(stdin.readline())\narr=[Node(i) for i in range(1,n+1)]\nc=2\nfor x in map(int,stdin.readline().split()):\n    arr[x-1].forw.add(c)\n    c+=1\n\n\ndct=Counter()\nlst = [1]\nwhile len(lst):\n    fl = 0\n    for i in arr[lst[-1]-1].forw:\n        lst.append(i)\n        fl = 1\n        break\n    if fl:\n        arr[lst[-2]-1].forw.remove(i)\n    if not fl:\n        if arr[lst[-1]-1].cou ==0:\n            arr[lst[-1]-1].cou=1\n        dct[arr[lst[-1]-1].cou]+=1\n        k=arr[lst.pop()-1].cou\n        if len(lst):arr[lst[-1]-1].cou+=k\n\ny=1\nfor _ in range(n):\n    while not dct[y]:\n        y+=1\n    dct[y]-=1\n    print(y,end=' ')", "complexity": "linear"}
{"src": "n, s = map(int, input().split())\nres = 0\nfor i in range(n, 0, -1):\n    res += s//i\n    s = s % i\nprint(res)", "complexity": "linear"}
{"src": "def init_input():\n    import os\n    from sys import stdin\n    it = iter(os.read(stdin.fileno(), 10 ** 7).split())\n    return lambda: next(it).decode(), lambda: int(next(it)), lambda: float(next(it))\nns, ni, nf = init_input()\n\nMOD = 10 ** 9 + 7\n\nn, q = ni(), ni()\ns = 'x' + ns()\nc = [0] * (n + 1)\nfor i in range(1, n + 1):\n    c[i] = c[i - 1] + (s[i] == '1')\n\np2 = [1] * (2 * n + 1)\nfor i in range(1, 2 * n + 1):\n    p2[i] = p2[i - 1] * 2 % MOD\n\nout = []\nfor qq in range(q):\n    l, r = ni(), ni()\n    o = c[r] - c[l - 1]\n    z = (r - l + 1) - o\n    ans = (p2[o + z] - 1 - p2[z] + 1) % MOD\n    out.append(ans)\nprint(*out, sep='\\n')\n", "complexity": "linear"}
{"src": "n=int(input())\nc=0\nfor j in range(2,1+n//2):\n\te=0\n\ti=n//j\n\te+=(i*(i+1))//2\n\te-=1\n\tif e>0:\n\t\tc+=e\nprint(c*4)", "complexity": "linear"}
{"src": "n= int(input())\nfor i in range(n//3):\n    print(-2,1+i*2)\nfor i in range(n-n//3):\n    print(1,i)", "complexity": "linear"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = li()\n\ndone = set()\nj = 0\nans = []\nfor i in range(n):\n    if b[i] in done:\n        ans.append(0)\n    else:\n        c = 0\n        while a[j] != b[i]:\n            done.add(a[j])\n            j += 1\n            c += 1\n        done.add(a[j])\n        j += 1\n        ans.append(c + 1)\nprint(*ans)", "complexity": "linear"}
{"src": "n, m = map(int, input().split())\ndist = [int(x) for x in input().split()]\ntaxi = [int(x) for x in input().split()]\ndists = {}\nd = []\nfor person in range(len(taxi)):\n    if taxi[person]:\n        dists[dist[person]] = 0\n        d.append(dist[person])\nstart = 0\nd.append(10**11)\nfor person in range(len(taxi)):\n    if taxi[person] == 0:\n        while dist[person] > d[start + 1]:\n            start += 1\n        if abs(dist[person] - d[start]) <= abs(dist[person] - d[start + 1]):\n            dists[d[start]] += 1\n        else:\n            dists[d[start + 1]] += 1\nfor d in dists:\n    print(dists[d] if d!=10**11 else '', end=' ')\n\n", "complexity": "linear"}
{"src": "n , s = map(int, input().split())\nd = [0] * (n + 1)\ncnt = 0\nfor i in range(0 , n - 1):\n    a , b = map(int, input().split())\n    d[a - 1] += 1\n    d[b - 1] += 1\nfor i in range(0 , n):\n    if(d[i] == 1):\n        cnt += 1\nprint(2.0 * s / cnt)\n        \n", "complexity": "linear"}
{"src": "n,s = [int(x) for x in input().split()]\nv=[ [] ]\nfor i in range(n):\n\tv.append([])\n\t\nfor i in range(n-1):\n\ta, b =[int(x) for x in input().split()]\n\tv[a].append(b)\n\tv[b].append(a)\n\nans =0\nfor i in range(1,n+1):\n\tif len(v[i])==1:\n\t\tans+=1\n\t\nprint(2*s/ans)\n", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nb = []\nfor i in range(n):\n    a[i] %= 2\n    if len(b) != 0:\n        if b[-1] == a[i]:\n            b.pop()\n        else:\n            b.append(a[i])\n    else:\n        b.append(a[i])\nif len(b) > 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n", "complexity": "linear"}
{"src": "n = int(input())\nb = list(map(int, input().split()))\na = [0] * (2 * (len(b)))\na[-1] = b[0]\nfor i in range(1, len(b)):\n    if b[i] - a[i - 1] <= a[-i]:\n        a[i] = a[i - 1]\n        a[-i - 1] = b[i] - a[i - 1]\n    else:\n        a[-i - 1] = a[-i]\n        a[i] = b[i] - a[-i - 1]\nprint(*a)\n", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int, input().split()))\nmax1 = float('inf')\nfor q in range(len(a)):\n    if q >= n-q-1:\n        max1 = min(max1, min(a[q], a[0])//q)\n    if q <= n-q-1:\n        max1 = min(max1, min(a[q], a[-1]) // (n-q-1))\nprint(max1)\n", "complexity": "linear"}
{"src": "import sys\n\n\ndef second_largest(numbers):\n    count = 0\n    m1 = m2 = float('-inf')\n    for x in numbers:\n        count += 1\n        if x > m2:\n            if x >= m1:\n                m1, m2 = x, m1\n            else:\n                m2 = x\n    return m2 if count >= 2 else None\n\n\nn, m = map(int, input().split())\nboys = list(map(int, input().split()))\ngirls = list(map(int, input().split()))\nfirstMax = max(boys)\nsecondMax = second_largest(boys)\nminGrills = min(girls)\nminSum = 0\nif firstMax > minGrills:\n    print(-1)\n    sys.exit()\nelif firstMax == minGrills:\n    minSum = m * (sum(boys) - firstMax) + sum(girls)\nelif n == 1:\n    print(-1)\n    sys.exit()\nelse:\n    minSum = m * sum(boys) + sum(girls) - (m-1) * firstMax - secondMax\nprint(minSum)\n", "complexity": "linear"}
{"src": "n, k = list(map(int,input().split()))\nchuj_twojej_starej = (n - k) // 2 + 1\ni = 1\nwhile True:\n\tif i % chuj_twojej_starej == 0:\n\t\tprint(0, end = \"\")\n\telse:\n\t\tprint(1, end = \"\")\n\tif i == n:\n\t\tbreak\n\ti += 1", "complexity": "linear"}
{"src": "# import sys\n# input = sys.stdin.readline\nn,queries = list(map(int,input().split()))\nl = list(map(int,input().split()))\nif(queries==0):\n\texit()\nmaxval = max(l)\npairs = []\ncount = 0\nf = l[0]\nsecix = 1\nwhile(f!=maxval):\n\t# print(l)\n\tcount+=1\n\tf = l[0]\n\ts = l[secix]\n\tpairs.append([f,s])\n\tf,s= max(f,s), min(f,s)\n\tl[0] = f\n\tl.append(s)\n\tsecix+=1\n# print(secix)\nl = [l[0]]+l[secix:]\n# print(l)\nfor i in range(n-1):\n\tpairs.append([maxval,l[1+i]])\n# print(pairs)\nfor m in range(queries):\n\tq = int(input())\n\tif(q<=count):\n\t\tprint(str(pairs[q-1][0]),str(pairs[q-1][1]))\n\telse:\n\t\tq-=(count+1)\n\t\tpos = count+(q%(n-1))\n\t\tprint(str(pairs[pos][0]),str(pairs[pos][1]))", "complexity": "linear"}
{"src": "n = int(input())\nans = 1\nfor i in range(1, n):\n    ans += i * 4\nprint(ans)", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int, input().split()))\n\nmax_mod = 0\nmax_i = -1\nfor i in range(n):\n\tif a[i] >= 0:\n\t\ta[i] = -a[i] - 1\n\tif -a[i] > max_mod:\n\t\tmax_mod = -a[i]\n\t\tmax_i = i\n\nif n % 2 == 1:\n\ta[max_i] = -a[max_i] - 1\n\nprint(' '.join(list(map(str, a))))\n", "complexity": "linear"}
{"src": "n = int(input())\na = list(map(int,input().split()))\n\nfor i in range(n):\n    if a[i] >= 0:\n        a[i] = -a[i]-1\n\nif n%2:\n    m = min(a)\n    for i in range(n):\n        if a[i] == m:\n            a[i] = -a[i]-1\n            break\n\nprint(*a)\n", "complexity": "linear"}
{"src": "#import resource\nimport sys\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n#import threading\n#threading.Thread(target=main).start()\n#threading.stack_size(2**26)\n#sys.setrecursionlimit(10**6)\nmod=(10**9)+7\n#fact=[1]\n#for i in range(1,100001):\n#    fact.append((fact[-1]*i)%mod)\n#ifact=[0]*100001\n#ifact[100000]=pow(fact[100000],mod-2,mod)\n#for i in range(100000,0,-1):\n#    ifact[i-1]=(i*ifact[i])%mod\nfrom sys import stdin, stdout\nimport bisect\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport itertools\nimport collections\nimport math\nimport heapq\nfrom random import randint as rn\nfrom Queue import Queue as Q\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p\n    return t\ndef ain():\n    return map(int,sin().split())\ndef sin():\n    return stdin.readline().strip()\ndef GCD(x,y):\n    while(y):\n        x, y = y, x % y\n    return x\ndef isprime(x):\n    if(x==1):\n        return False\n    elif(x<4):\n        return True\n    for i in range(2,int(math.sqrt(x))+1):\n        if(x%i==0):\n            return False\n    return True\n\"\"\"**************************************************************************\"\"\"\nn,q=ain()\na=ain()\ng=max(a)\nd=collections.deque(a)\nf=0\nan1=[]\nwhile(d[0]!=g):\n    f+=1\n    x=d.popleft()\n    y=d.popleft()\n    an1.append(str(x)+\" \"+str(y))\n    if(y==g):\n        d.appendleft(y)\n        d.append(x)\n        break\n    if(x<y):\n        d.appendleft(y)\n        d.append(x)\n    else:\n        d.appendleft(x)\n        d.append(y)\nr=[]\nans=[]\nfor i in range(n):\n    r.append(str(d.popleft()))\nfor i in range(q):\n    b=int(sin())\n    if(b<=f):\n        ans.append(an1[b-1])\n    else:\n        b-=f\n        b-=1\n        b%=(n-1)\n        ans.append(r[0]+\" \"+r[b+1])\nstdout.write(\"\\n\".join(ans))\n", "complexity": "linear"}
{"src": "n, q = map(int,input().split())\nai = list(map(int,input().split()))\nar  = []\nar3 = []\nnum = 1\nnummm = max(ai)\nif ai[0] != nummm:\n    num2 = ai[0]\n    for i in range(1,n):\n        ar3 += [[num2,ai[i]]]\n        if ai[i] == nummm:\n            ar += [num2]\n            num = i+1\n            break\n        if ai[i] > num2:\n            ar += [num2]\n            num2 = ai[i]\n        else:\n            ar += [ai[i]]\nar2 = []\nfor i in range(num,n):\n    ar2 += [ai[i]]\nfor i in range(len(ar)):\n    ar2 += [ar[i]]\nnum = len(ar3)\nfor i in range(q):\n    m = int(input())\n    if m <= num:\n        print(ar3[m-1][0],ar3[m-1][1])\n    else:\n        m -= num\n        m -= 1\n        print(nummm,ar2[m % (n-1)])\n", "complexity": "linear"}
{"src": "n,m,k=map(int,input().split())\np=list(map(int,input().split()))\ncount=0\ndelete=0\nnow=0\nwhile now<m:\n    up=((p[now]-delete-1)//k+1)*k+delete\n    while now<m and p[now]<=up:\n        now+=1\n        delete+=1\n    count+=1\nprint(count)", "complexity": "linear"}
{"src": "n, m, k = map(int, input().split())\nmi = list(map(int, input().split()))\n\nans = 0\nitems_to_del = 0\nshift = 1\nc_page = None\nfor el in mi:\n    if c_page is None:\n        c_page = (el - shift) // k\n        items_to_del = 1\n    else:\n        page = (el - shift) // k\n        if page != c_page:\n            shift += items_to_del\n            ans += 1\n            c_page = (el - shift) // k\n            items_to_del = 1\n        else:\n            items_to_del += 1\nif items_to_del != 0:\n    ans += 1\nprint(ans)\n", "complexity": "linear"}
{"src": "#!/usr/bin/env python3\n\ndef win1():\n    if n==k or r[k+1]==n or l[n-k]==1:\n        return True\n    for i in range(2,n-k+1):\n        if l[i-1]==1 and r[i+k]==n and a[i-1]==a[i+k]:\n            return True\n    return False\n\ndef win2():\n    if 2*k<n:\n        return False\n    for i in range(2,n-k+1):\n        if l[i-1]!=1 or r[i+k]!=n:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    s=input().split()\n    n,k=int(s[0]),int(s[1])\n    s=input().split()\n    a=[0]\n    l=[0 for i in range(n+1)]\n    r=[0 for i in range(n+1)]\n    for c in s[0]:\n        a.append(int(c))\n    l[1],r[n]=1,n\n    for i in range(2,n+1):\n        if a[i-1]==a[i]:\n            l[i]=l[i-1]\n        else:\n            l[i]=i\n        if a[n-i+1]==a[n-i+2]:\n            r[n-i+1]=r[n-i+2]\n        else:\n            r[n-i+1]=n-i+1\n    # print(l,r)\n    if win1():\n        print(\"tokitsukaze\")\n    elif win2():\n        print(\"quailty\")\n    else:\n        print(\"once again\")\n \t\t  \t   \t\t \t  \t \t \t    \t \t   \t", "complexity": "linear"}
{"src": "m=[x for x in input().split()]\ntiles=[[0 for i in range(9)] for j in range(3)]\nfor i in range(len(m)):\n    g=int(m[i][0])-1\n    h=(m[i][1])    \n    if h==\"m\":\n        tiles[0][g]+=1\n    elif h==\"p\":\n        tiles[1][g]+=1\n    else:\n        tiles[2][g]+=1\nif m[0]==m[1] and m[1]==m[2]:\n    print(0)\nelif m[0]==m[1]:\n    print(1)\nelif m[0]==m[2]:\n    print(1)\nelif m[1]==m[2]:\n    print(1)\nelse:\n    n=False\n    for i in range(3):\n        for j in range(9):\n            if tiles[i][j]!=0:\n                if j!=8 and tiles[i][j+1]!=0:\n                    if j!=7 and tiles[i][j+2]!=0:\n                        print(0)\n                        n=True\n                        break\n                    else:\n                        print(1)\n                        n=True\n                        break\n                elif j!=7 and j!=8 and tiles[i][j+2]!=0:\n                    print(1)\n                    n=True\n                    break\n    if n==False:\n        print(2)", "complexity": "linear"}
{"src": "reduced = 1\nn, m ,k = map(int,input().split())\n\np = list(map(int, input().split()))\n\np.reverse()\ncnt = 0\nwhile(len(p)):\n    \n    cnt1 = 1\n    first = p.pop()\n    fack = ((first - reduced)//k) * k\n    while(len(p) and p[-1] - fack - reduced < k):\n        cnt1 += 1\n        p.pop()\n    \n    reduced += cnt1\n    cnt += 1\nprint(cnt)", "complexity": "linear"}
{"src": "n, k = [int(i) for i in input().split()]\nfor i in range(100*k+100*n):\n    if i*(i+1) == (n+k-i)*2:\n        print(n-i)\n        break", "complexity": "linear"}
{"src": "'''input\n3\n5 2\nBGGGG\n5 3\nRBRGR\n5 5\nBBBRR\n'''\nimport sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nfor _ in range(int(input())):\n\tn,k = ri()\n\ta = input()\n\trgb= [0 for i in range(n)]\n\tgbr= [0 for i in range(n)]\n\tbrg= [0 for i in range(n)]\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\trgb[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\trgb[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\trgb[i]+=1\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\tgbr[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\tgbr[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\tgbr[i]+=1\n\n\tfor i in range(n):\n\t\tif i%3==0:\n\t\t\tif a[i]!=\"B\":\n\t\t\t\tbrg[i]+=1\n\t\tif i%3==1:\n\t\t\tif a[i]!=\"R\":\n\t\t\t\tbrg[i]+=1\n\t\tif i%3==2:\n\t\t\tif a[i]!=\"G\":\n\t\t\t\tbrg[i]+=1\n\n\tfor i in range(1,n):\n\t\trgb[i]+=rgb[i-1]\n\t\tbrg[i]+=brg[i-1]\n\t\tgbr[i]+=gbr[i-1]\n\n\n\tans = 999999999\n\t#print(rgb,gbr,brg)\n\tfor i in range(k-1,n):\n\t\t#print(i,i-k)\n\t\tif i-k ==-1:\n\t\t\tans = min(ans,rgb[i],gbr[i],brg[i])\n\t\telse:\n\t\t\tans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] )\n\n\tprint(ans)\n\n\n\n\n\n\n", "complexity": "linear"}
{"src": "import sys\ninput = sys.stdin.readline\nq = int(input())\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    R, G, B = 0, 0, 0\n    ans = float('inf')\n    for j in range(n):\n        if j % 3 == 0:\n            if s[j] == 'R':\n                G += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                B += 1\n            else:\n                R += 1\n                G += 1\n        elif j % 3 == 1:\n            if s[j] == 'R':\n                G += 1\n                R += 1\n            elif s[j] == 'G':\n                G += 1\n                B += 1\n            else:\n                R += 1\n                B += 1\n        else:\n            if s[j] == 'R':\n                R += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                G += 1\n            else:\n                G += 1\n                B += 1\n        if j >= k - 1:\n            ans = min(ans, R, G, B)\n            if (j - k + 1) % 3 == 0:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    G -= 1\n            elif (j - k + 1) % 3 == 1:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    R -= 1\n                elif s[j - k + 1] == 'G':\n                    G -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    B -= 1\n            else:\n                if s[j - k + 1] == 'R':\n                    R -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    G -= 1\n                else:\n                    G -= 1\n                    B -= 1\n\n    print(ans)", "complexity": "linear"}
{"src": "n = int(input())\nl = list(map(int, input().split()))\nto = l.index(max(l))\nok = 1\nfor i in range(1, to):\n    if (l[i] <= l[i - 1]):\n        ok = 0\n        break\nfor i in range(to + 1, n):\n    if (l[i] >= l[i - 1]):\n        ok = 0\n        break\nif ok:\n    print('YES')\nelse:\n    print('NO')", "complexity": "linear"}
{"src": "n, t = map(int, input().split())\nl = []\nfor _ in range(n):\n  x, a = map(int, input().split())\n  l.append((x-a/2, x+a/2))\nl.sort()\nres = 2\n# print(l)\nfor i in range(n-1):\n  if l[i+1][0] - l[i][1] == t:\n    res += 1\n  elif l[i+1][0] - l[i][1] > t:\n    res += 2\n\nprint(res)\n", "complexity": "nlogn"}
{"src": "n,t=list(map(int,input().split()))\na=sorted([list(map(int,input().split())) for i in range(n)])\nb=[a[i][0]-a[i][1]/2-a[i-1][0]-a[i-1][1]/2 for i in range(1,n)]\nc=2\nfor i in range(n-1):\n    c+=int(b[i]>t)*2+int(b[i]==t)\nprint(c)", "complexity": "nlogn"}
{"src": "n = int(input())\nl1 = list(input().split())\nl2 = []\nfor i in l1:\n    l2.append(int(i))\nl1 = set(l2)\nl1 = list(l1)\nfor i in range(0, len(l1)):\n    for j in range(i + 1, len(l1)):\n        if l1[i] > l1[j]:\n            temp = l1[j]\n            l1[j] = l1[i]\n            l1[i] = temp\nif len(l1) > 1:\n    print(l1[1])\nelse:\n    print('NO')\n", "complexity": "nlogn"}
{"src": "n = int(input())\nl1 = list(input().split())\nl2 = []\nfor i in l1:\n    l2.append(int(i))\nl1 = set(l2)\nl1 = list(l1)\nfor i in range(0, len(l1)):\n    for j in range(i + 1, len(l1)):\n        if l1[i] > l1[j]:\n            temp = l1[j]\n            l1[j] = l1[i]\n            l1[i] = temp\nif len(l1) > 1:\n    print(l1[1])\nelse:\n    print('NO')\n  \t\t   \t\t\t    \t\t\t\t   \t\t     \t\t", "complexity": "nlogn"}
{"src": "import sys\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\ninput = sys.stdin.readline\n\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nif a[-1] == 1: ans = a[:-1] + [2]\nelse: ans = [1] + a[:-1]\nprint(*ans)\n", "complexity": "nlogn"}
{"src": "a=int(input())\nb=list(map(int,input().split()))\nz=max(b)\nif z==1:b[b.index(z)]=2\nelse:b[b.index(z)]=1\nprint(*sorted(b))", "complexity": "nlogn"}
{"src": "\ndef STR(): return list(input())\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef MAP2():return map(float,input().split())\ndef LIST(): return list(map(int, input().split()))\ndef STRING(): return input()\nimport string\nimport sys\nfrom heapq import heappop , heappush\nfrom bisect import *\nfrom collections import deque , Counter , defaultdict\nfrom math import *\nfrom itertools import permutations , accumulate\ndx = [-1 , 1 , 0 , 0  ]\ndy = [0 , 0  , 1  , - 1]\n#visited = [[False for i in range(m)] for j in range(n)]\n#  primes = [2,11,101,1009,10007,100003,1000003,10000019,102345689]\n#sys.stdin = open(r'input.txt' , 'r')\n#sys.stdout = open(r'output.txt' , 'w')\n#for tt in range(INT()):\n#arr.sort(key=lambda x: (-d[x], x)) Sort with Freq\n\n#Code\n\nn = INT()\narr = LIST()\nmx = max(arr)\nx = -1\nif mx == 1 :\n    x = 2\nelse:\n    x = 1\n\narr.remove(mx)\narr.append(x)\narr.sort()\nprint(*arr)\n\n\n", "complexity": "nlogn"}
{"src": "#Mamma don't raises quitter.................................................\nfrom collections import deque as de\nimport math\nfrom math import sqrt as sq\nfrom math import floor as fl\nfrom math import ceil as ce\nfrom sys import stdin, stdout\nimport re\nfrom collections import Counter as cnt\nfrom functools import  reduce\n\nfrom itertools import groupby as gb\n#from fractions import Fraction as fr\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n    \nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    \n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack() \n\n#decimal to binary   \ndef decimalToBinary(n): \n    return bin(n).replace(\"0b\", \"\")\n#binary to decimal\ndef binarytodecimal(n):\n    return int(n,2)\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n    return prime_factors\n\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\n \n# Function to get product of digits\ndef getProduct(n):\n \n    product = 1\n \n    while (n != 0):\n        product = product * (n % 10)\n        n = n // 10\n \n    return product\n\n\n#function to find LCM of two numbers\ndef lcm(x,y):\n   lcm = (x*y)//math.gcd(x,y)\n   return lcm\n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \n#to check whether the given sorted sequnce is forming an AP or not....\ndef checkisap(list):\n    d=list[1]-list[0]\n    for i in range(2,len(list)):\n        temp=list[i]-list[i-1]\n        if temp !=d:\n            return False\n    return True\n        \n#seive of erathanos\ndef primes_method5(n):\n    out ={}\n    sieve = [True] * (n+1)\n    for p in range(2, n+1):\n        if (sieve[p]):\n            out[p]=1\n            for i in range(p, n+1, p):\n                sieve[i] = False\n    return out\n#function to get the sum of digits\ndef getSum(n): \n      \n    strr = str(n)\n    list_of_number = list(map(int, strr.strip()))\n    return sum(list_of_number)\n\n\n#ceil  function gives wrong answer after 10^17 so i have to create my own :)\n# because i don't want to doubt on my solution of 900-1000 problem set.\ndef ceildiv(x,y): \n    return (x+y-1)//y \n  \ndef di():return map(int, input().split())\ndef ii():return int(input())\ndef li():return list(map(int, input().split()))\ndef si():return list(map(str, input()))\ndef indict():\n    dic = {}\n    for index, value in enumerate(input().split()):\n        dic[int(value)] = int(index)+1\n    return dic\ndef frqdict(): \n    # by default it is for integer input. :)\n    dic={}\n    for index, value in enumerate(input()):\n        if value not in dic:\n            dic[value] =1\n        else:\n            dic[value] +=1\n    return dic\n\n#inp = open(\"input.txt\",\"r\")\n#out = open(\"output.txt\",\"w\")\n#Here we go......................\n#practice like your never won\n#perform like you never lost\nn=ii()\na=sorted(li())\nif a[n-1]==1:\n    a[n-1]=2\nelse:\n    a[n-1]=1\na.sort()\nprint(*a)\n\n        \n\n        \n    \n\n\n\n            \n\n    \n    \n    \n\n\n\n            \n\n            \n\n\n    \n        \n\n\n        \n    \n\n            \n        \n    \n\n                \n                \n                \n        \n        \n        \n\n            \n\n        \n\n\n\n\n\n                    \n                \n            \n        \n\n            \n    \n        \n    \n    \n\n    \n        \n    \n \n\n    \n        \n\n\n    \n        \n\n", "complexity": "nlogn"}
{"src": "input();a=sorted(map(int,input().split()));s=c=0\nwhile s<=sum(a):s+=a.pop();c+=1\nprint(c)", "complexity": "nlogn"}
{"src": "#!/usr/bin/env python3\n\nif __name__ == \"__main__\":\n\tn, k = map(int, input().split())\n\tais = []\n\tfor i in range(n):\n\t\tais.append(list(map(int, input().split())))\n\tais.sort(key = lambda x: (-x[0], x[1]))\n\tprint(ais.count(ais[k-1]))\n", "complexity": "nlogn"}
{"src": "n,k=map(int,input().split())\nl,c=[],0\nfor _ in range(n):\n\tl.append(list(map(int,input().split())))\nl.sort(reverse=True)\na,x,y=l[k-1][0],k-1,k-1\nfor i in range(k-2,-1,-1):\n\tif l[i][0]==a:\n\t\tx=i\n\telse:\n\t\tbreak\nfor i in range(k,n):\n\tif l[i][0]==a:\n\t\ty=i\n\telse:\n\t\tbreak\nd=k-1-x\nd=y-d\nfor i in range(y,x-1,-1):\n\tif l[i]==l[d]:\n\t\tc+=1\nprint(c)", "complexity": "nlogn"}
{"src": "import bisect\n\ntmp = input().split()\nn = int(tmp[0])\nk = int(tmp[1])\n\nscores = list()\ntimes = list()\nfor i in range(n):\n    tmp = input().split()\n    scores.append(int(tmp[0]))\n    times.append(int(tmp[1]))\n\nsorted_scores = sorted(zip(scores, times), key=lambda y : (y[0], -y[1]), reverse=True)\n\nans = 1\ni = k-2\nwhile i>=0 and (sorted_scores[i] == sorted_scores[k-1]):\n    ans = ans + 1 \n    i = i - 1\n\ni = k\nwhile i < n and (sorted_scores[i] == sorted_scores[k-1]):\n    ans = ans + 1 \n    i = i + 1 \n\nprint(ans)", "complexity": "nlogn"}
{"src": "n,a,b=map(int,input().split())\nalist=list(map(int,input().split()))\nalist.sort(reverse=True)\np=alist[a-1]\nq=alist[a]\nprint(p-q)", "complexity": "nlogn"}
{"src": "nab=input().split()\nl=input().split()\nnab=[int(i) for i in nab]\nl=[int(i) for i in l]\nl.sort()\nif(l[nab[2]-1]==l[nab[2]]):\n    print(0)\nelse:\n    print(l[nab[2]]-l[nab[2]-1])\n", "complexity": "nlogn"}
{"src": "n = int(input())\nA = [int(a) for a in input().split()]\nB = A.copy()\nB.sort()\nc = 0\nfor i in range(n):\n    a = A[i]\n    b = B[i]\n    if a == b:\n        continue\n    else:\n        c += 1\nif c == 0 or c == 2:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "nlogn"}
{"src": "n, m, k = map(int,input().split())\nline = [int(x) for x in input().split()]\nline.sort(reverse = True)\ncount = 0\nif k >=m:\n    print(count)\n    exit(0)\nfor i in range(n):\n    k += line[i]-1\n    count += 1\n    if k >= m:\n        print(count)\n        exit(0)\nprint(-1)", "complexity": "nlogn"}
{"src": "def func(k, a):\n    if len(a) == 1:\n        return 1\n    if k == 1:\n        return len(a)\n    s = set(a)\n    for x in sorted(a):\n        if x in s and k * x in s:\n            s.remove(k * x)\n    return len(s)\n\n\ndef read_ints():\n    return [int(x) for x in input().split(' ')]\n\n\ndef main():\n    n, k = read_ints()\n    a = read_ints()\n    assert n == len(a)\n    print(func(k, a))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn"}
{"src": "w, h, n = map(int, input().split())\nl, r = [-1] * (w+1), [-1] * (w+1)\nt, b = [-1] * (h+1), [-1] * (h+1)\nl[0], b[0], t[h], r[w] = 0, 0, h, w\nV, H = [0] * n, [0] * n\n\nfor i in range(n):\n    line, idx = input().split()\n    idx = int(idx)\n    if line == 'V':\n        r[idx] = w\n        V[i] = idx\n    else:\n        t[idx] = h\n        H[i] = idx\n\nleft, max_w = 0, 0\nfor i in range(1, w+1):\n    if r[i] != -1:\n        l[i] = left\n        r[left] = i\n        max_w = max(max_w, i - left)\n        left = i\n\nbottom, max_h = 0, 0\nfor i in range(1 ,h+1):\n    if t[i] != -1:\n        b[i] = bottom\n        t[bottom] = i\n        max_h = max(max_h, i - bottom)\n        bottom = i\n\nres = [0] * n\nres[n-1] = max_h * max_w\nfor i in range(n-1, 0, -1):\n    if V[i] != 0:\n        max_w = max(max_w, r[V[i]] - l[V[i]])\n        r[l[V[i]]] = r[V[i]]\n        l[r[V[i]]] = l[V[i]]\n    else:\n        max_h = max(max_h, t[H[i]] - b[H[i]])\n        b[t[H[i]]] = b[H[i]]\n        t[b[H[i]]] = t[H[i]]\n    res[i-1] = max_h * max_w\n\nfor i in range(n):\n    print(res[i])", "complexity": "nlogn"}
{"src": "w,h,n=map(int,input().split())\nl=[-1]*(w+1)\nr=[-1]*(w+1)\nt=[-1]*(h+1)\nb=[-1]*(h+1)\n\nl[0]=0\nb[0]=0\nt[h]=h\nr[w]=w\n\n\nV=[0]*(n)\nH=[0]*(n)\nfor i in range(n):\n    line,index=input().split()\n    index=int(index)\n    if line==\"V\":\n        r[index]=w\n        V[i]=index\n    else:\n        t[index]=h\n        H[i]=index\n        \nleft=0\nmxw=0\nfor i in range(1,w+1):\n    if r[i]!=-1:\n        l[i]=left\n        r[left]=i\n        mxw=max(mxw,i-left)\n        left=i\n        \nbottom=0\nmxh=0\nfor i in range(1,h+1):\n    if t[i]!=-1:\n        b[i]=bottom\n        t[bottom]=i\n        mxh=max(mxh,i-bottom)\n        bottom=i\n        \nans=[0]*(n)\nans[n-1]=mxh*mxw\n\n\nfor i in range(n-1,0,-1):\n    if V[i]!=0:\n        mxw=max(mxw,r[V[i]]-l[V[i]])\n        r[l[V[i]]]=r[V[i]]\n        l[r[V[i]]]=l[V[i]]\n        \n    else:\n        mxh=max(mxh,t[H[i]]-b[H[i]])\n        b[t[H[i]]]=b[H[i]]\n        t[b[H[i]]]=t[H[i]]\n    \n    ans[i-1]=mxh*mxw\n\nfor i in range(n):\n    print(ans[i]) ", "complexity": "nlogn"}
{"src": "w, h, n = map(int, input().split())\nl, r = [-1] * (w+1), [-1] * (w+1)\nt, b = [-1] * (h+1), [-1] * (h+1)\nl[0], b[0], t[h], r[w] = 0, 0, h, w\nV, H = [0] * n, [0] * n\n\nfor i in range(n):\n    line, idx = input().split()\n    idx = int(idx)\n    if line == 'V':\n        r[idx] = w\n        V[i] = idx\n    else:\n        t[idx] = h\n        H[i] = idx\n\nleft, max_w = 0, 0\nfor i in range(1, w+1):\n    if r[i] != -1:\n        l[i] = left\n        r[left] = i\n        max_w = max(max_w, i - left)\n        left = i\n\nbottom, max_h = 0, 0\nfor i in range(1 ,h+1):\n    if t[i] != -1:\n        b[i] = bottom\n        t[bottom] = i\n        max_h = max(max_h, i - bottom)\n        bottom = i\n\nres = [0] * n\nres[n-1] = max_h * max_w\nfor i in range(n-1, 0, -1):\n    if V[i] != 0:\n        max_w = max(max_w, r[V[i]] - l[V[i]])\n        r[l[V[i]]] = r[V[i]]\n        l[r[V[i]]] = l[V[i]]\n    else:\n        max_h = max(max_h, t[H[i]] - b[H[i]])\n        b[t[H[i]]] = b[H[i]]\n        t[b[H[i]]] = t[H[i]]\n    res[i-1] = max_h * max_w\n\nfor i in range(n):\n    print(res[i])", "complexity": "nlogn"}
{"src": "from collections import Counter\nmp = Counter()\nn = int(input())\narr = list(map(int,input().split()))\n\ntot , cnt, ans = 0, 0, 0\nfor i in arr:\n\tncnt = cnt - mp[i] - mp[i+1] - mp[i-1]\n\tntot = tot - (i * mp[i]) - ((i-1)*mp[i-1]) - ((i+1)*mp[i+1])\n\tnsum = (ncnt * i) - ntot\n\tans += nsum\n\tmp[i] += 1\n\tcnt += 1\n\ttot += i\nprint(ans)\n", "complexity": "nlogn"}
{"src": "from sys import stdin, stdout\n\ndef pair_of_lines(n, xy_a):\n    if len(xy_a) <= 3:\n        return 'YES'\n\n    p1, p2, p3 = xy_a[0], xy_a[1], xy_a[2]\n    if judge(p1, kstr(p1, p2),xy_a):\n        return 'YES'\n    if judge(p1, kstr(p1, p3),xy_a):\n        return 'YES'\n    if judge(p2, kstr(p2, p3), xy_a):\n        return 'YES'\n    return 'NO'\n\n\ndef kstr(xy1, xy2):\n    cx, cy = xy1[0], xy1[1]\n    x, y = xy2[0], xy2[1]\n    dx = x - cx\n    dy = y - cy\n    k = ''\n    if dx == 0:\n        k = str(x) + '/y'\n    elif dy == 0:\n        k = 'x/' + str(y)\n    else:\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        k = str(dx) + '/' + str(dy)\n    return k\n\n\ndef judge(p, k, xy_a):\n\n    rl = []\n    for xy in xy_a:\n        if p[0] == xy[0] and p[1] == xy[1]:\n            continue\n        if kstr(p, xy) != k:\n            rl.append(xy)\n\n    if len(rl) > 2:\n        ck = kstr(rl[0], rl[1])\n        for i in range(2, len(rl)):\n            if ck != kstr(rl[0], rl[i]):\n                return False\n\n    return True\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ntry:\n    n = int(stdin.readline())\n    xy_a = []\n    for _ in range(n):\n        xy_a.append(list(map(int, stdin.readline().split())))\n    res = pair_of_lines(n, xy_a)\n    stdout.write(res)\nexcept Exception as e:\n  print(e)\n", "complexity": "nlogn"}
{"src": "def divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):#\u6392\u4ed6\u7684\u8ad6\u7406\u548c\u306e\u968e\u4e57\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass Matrix():\n    mod=10**9+7\n\n    def set_mod(m):\n        Matrix.mod=m\n\n    def __init__(self,L):\n        self.row=len(L)\n        self.column=len(L[0])\n        self._matrix=L\n        for i in range(self.row):\n            for j in range(self.column):\n                self._matrix[i][j]%=Matrix.mod\n\n    def __getitem__(self,item):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        return self._matrix[i][j]\n\n    def __setitem__(self,item,val):\n        if type(item)==int:\n            raise IndexError(\"you must specific row and column\")\n        elif len(item)!=2:\n            raise IndexError(\"you must specific row and column\")\n\n        i,j=item\n        self._matrix[i][j]=val\n\n    def __add__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]+other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __sub__(self,other):\n        if (self.row,self.column)!=(other.row,other.column):\n            raise SizeError(\"sizes of matrixes are different\")\n\n        res=[[0 for j in range(self.column)] for i in range(self.row)]\n        for i in range(self.row):\n            for j in range(self.column):\n                res[i][j]=self._matrix[i][j]-other._matrix[i][j]\n                res[i][j]%=Matrix.mod\n        return Matrix(res)\n\n    def __mul__(self,other):\n        if type(other)!=int:\n            if self.column!=other.row:\n                raise SizeError(\"sizes of matrixes are different\")\n\n            res=[[0 for j in range(other.column)] for i in range(self.row)]\n            for i in range(self.row):\n                for j in range(other.column):\n                    temp=0\n                    for k in range(self.column):\n                        temp+=self._matrix[i][k]*other._matrix[k][j]\n                    res[i][j]=temp%Matrix.mod\n            return Matrix(res)\n        else:\n            n=other\n            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]\n            return Matrix(res)\n\n    def __pow__(self,m):\n        if self.column!=self.row:\n            raise MatrixPowError(\"the size of row must be the same as that of column\")\n\n        n=self.row\n        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])\n        while m:\n            if m%2==1:\n                res=res*self\n            self=self*self\n            m//=2\n        return res\n\n    def __str__(self):\n        res=[]\n        for i in range(self.row):\n            for j in range(self.column):\n                res.append(str(self._matrix[i][j]))\n                res.append(\" \")\n            res.append(\"\\n\")\n        res=res[:len(res)-1]\n        return \"\".join(res)\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import log,gcd\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn = int(input())\nX = [0 for i in range(n)]\nY = [0 for i in range(n)]\nfor _ in range(n):\n    X[_],Y[_] = mi()\n\ndef solve(n,X,Y):\n    if n<=3:\n        return True\n\n    def check(i,j,k):\n        return (Y[k]-Y[j])*(X[j]-X[i])==(Y[j]-Y[i])*(X[k]-X[j])\n\n    #0,1\n    a,b = -1,-1\n    for i in range(n):\n        if not check(0,1,i):\n            if a==-1:\n                a = i\n            elif b==-1:\n                b = i\n            else:\n                if not check(a,i,b):\n                    break\n    else:\n        return True\n\n    a,b = -1,-1\n    for i in range(n):\n        if not check(2,1,i):\n            if a==-1:\n                a = i\n            elif b==-1:\n                b = i\n            else:\n                if not check(a,i,b):\n                    break\n    else:\n        return True\n\n    a,b = -1,-1\n    for i in range(n):\n        if not check(0,2,i):\n            if a==-1:\n                a = i\n            elif b==-1:\n                b = i\n            else:\n                if not check(a,i,b):\n                    break\n    else:\n        return True\n\n    return False\n\nprint(\"YES\" if solve(n,X,Y) else \"NO\")\n", "complexity": "nlogn"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit()\n\nA = [None]*n\n\nfor i in range(n):\n    A[i] = list(map(int,input().split()))\n\ndef is_colinear(a1,a2,a3):\n    if a1 == a2 or a2 == a3 or a1 == a3:\n        return True\n\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = a3\n\n    if x1 == x2 or x1 == x3 or x2 == x3:\n        return x1 == x2 == x3\n    if y1 == y2 or y1 == y3 or y2 == y3:\n        return y1 == y2 == y3\n    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\nX,Y,Z = A[0],A[1],A[2]\n\ndef good(X,Y):\n    # are X,Y on the same line?\n    bad = []\n    for i in range(n):\n        if not is_colinear(X,Y,A[i]):\n            bad.append(A[i])\n\n    if len(bad) <= 2:\n        return True\n\n    U,V = bad[0],bad[1]\n    for i in range(len(bad)):\n        if not is_colinear(U,V,bad[i]):\n            return False\n    return True\n\nif good(X,Y) or good(Y,Z) or good(X,Z):\n    print(\"YES\")\n    exit()\n\nprint(\"NO\")\nexit()\n", "complexity": "nlogn"}
{"src": "n = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\nf = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\ndef g(fi, se, p):\n    q = []\n    for x in p:\n        if f(fi, se, x):\n            if len(q) < 2:\n                q.append(x)\n            else:\n                if f(q[0], q[1], x):\n                    return 1\n    return 0\nprint('NO' if n > 4 and all([g(p[0], p[1], p), g(p[0], p[2], p), g(p[1], p[2], p)]) else 'YES')\n\n", "complexity": "nlogn"}
{"src": "def cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\n\ndef f(v, i1, i2):\n    d = [v[i2][i] - v[i1][i] for i in range(len(v[i1]))]\n\n    res = []\n    for x in v:\n        d2 = [x[i] - v[i1][i] for i in range(len(v[i1]))]\n        if cross(d, d2) != 0:\n            res.append(x)\n\n    return res\n\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    exit(0)\n\nv = []\nfor i in range(n):\n    v.append(list(map(int, input().split())))\n\nok = False\nfor first in range(3):\n    if ok:\n        break\n\n    for second in range(first+1, 3):\n        other = f(v, first, second)\n\n        if len(other) <= 2:\n            ok = True\n            break\n\n        remainder = f(other, 0, 1)\n\n        if not remainder:\n            ok = True\n\n\nif ok:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "complexity": "nlogn"}
{"src": "def Solution(N, Q, wariors_strength, arrows):\n    # Solution\n    prefix_sum = [0]\n    for strength in wariors_strength:\n        prefix_sum.append(prefix_sum[-1]+strength)\n    prefix_sum.pop(0)\n    arrow_so_far = 0\n    for arrow in arrows:\n        arrow_so_far += arrow\n        if arrow_so_far >= prefix_sum[-1]:\n            print(N)\n            arrow_so_far = 0\n        else:\n            idx = binarySearch_LowerBound(prefix_sum, arrow_so_far)\n            print(N-idx)\n\n\ndef binarySearch_LowerBound(arr, key):\n    l = 0\n    r = len(arr)-1\n\n    while l <= r:\n        mid = (l+r)//2\n        if arr[mid] == key:\n            return mid+1\n        elif arr[mid] > key:\n            r = mid-1\n        else:\n            l = mid+1\n    return r+1\n\n\nN, Q = map(int, input().split())\nwariors_strength = list(map(int, input().split()))\narrows = list(map(int, input().split()))\n# strArr = [input() for _ in range(N)]\n\nSolution(N, Q, wariors_strength, arrows)\n", "complexity": "nlogn"}
{"src": "import bisect\nn,q=map(int,input().split())\nstrength=list(map(int,input().split()))\narrows=list(map(int,input().split()))\nfor i in range(1,n):\n    strength[i]+=strength[i-1]\nNo_arrows=0\nn-=1\nfor i in range(q):\n    No_arrows+=arrows[i]\n    if(No_arrows>=strength[-1]):\n        No_arrows=0\n        print(n+1)\n    else:\n        it=bisect.bisect_left(strength,No_arrows)\n        if(strength[it]==No_arrows):\n            print(n-it)\n        else:\n            print(n-it+1)\n", "complexity": "nlogn"}
{"src": "d={}\nn=int(input())\nfor _ in range(n):\n    a,b=map(int,input().split())\n    d[a]=b\nm=int(input())\nfor _ in range(m):\n    a,b=map(int,input().split())\n    if(a in d and b>d[a]):\n        d[a]=b\n    elif(a not in d):\n        d[a]=b\ns=0\nfor i in d:\n    s+=d[i]\nprint(s)\n", "complexity": "nlogn"}
{"src": "#Winners never quit, Quitters never win............................................................................\nfrom collections import deque as de\nimport math\nfrom collections import Counter as cnt\nfrom functools import reduce\nfrom typing import MutableMapping\nfrom itertools import groupby as gb\nfrom fractions import Fraction as fr\n\ndef factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\nclass My_stack():\n    def __init__(self):\n        self.data = []\n    def my_push(self, x):\n        return (self.data.append(x))\n    def my_pop(self):\n        return (self.data.pop())\n    def my_peak(self):\n        return (self.data[-1])\n    def my_contains(self, x):\n        return (self.data.count(x))\n    def my_show_all(self):\n        return (self.data)\n    def isEmpty(self):\n      return len(self.data)==0\n\narrStack = My_stack()    \ndef decimalToBinary(n): \n    return bin(n).replace(\"0b\", \"\")\n\ndef isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\n\t\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\n\treturn True\n\ndef get_prime_factors(number):\n    prime_factors = []\n    while number % 2 == 0:\n        prime_factors.append(2)\n        number = number / 2\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        while number % i == 0:\n            prime_factors.append(int(i))\n            number = number / i\n\n    if number > 2:\n        prime_factors.append(int(number))\n\n    return prime_factors\ndef get_frequency(list):\n    dic={}\n    for ele in list:\n        if ele in dic:\n            dic[ele] += 1\n        else:\n            dic[ele] = 1\n    return dic\ndef Log2(x): \n    return (math.log10(x) / \n            math.log10(2)); \n\ndef isPowerOfTwo(n): \n    return (math.ceil(Log2(n)) == math.floor(Log2(n))); \ndef ceildiv(x,y): return (x+y-1)//y #ceil  function gives wrong answer after 10^17 so i have to create my own :)\n# because i don't want to doubt on my solution of 900-1000 problem set.  \ndef datainput():\n    return map(int, input().split())\ndef listinput():\n    return list(map(int, input().split()))\n#here we go......................\n#Winners never quit, Quitters never win\nn=int(input())\nans={}\nwhile n:\n    n-=1\n    a,x =datainput()\n    ans[a]=x\nm=int(input())\nwhile m:\n    m-=1\n    b,y =datainput()\n    if b in ans:\n        if ans[b] < y:\n            ans[b]=y\n    else:\n        ans[b]=y\nprint(sum(list(ans.values())))\n    \n    \n        \n        \n        \n                \n                \n\n        \n\n", "complexity": "nlogn"}
{"src": "import math\nn=int(input())\nlst = list(map(int, input().strip().split(' ')))\ns=input()\nfor j in range(n):\n    lst[j]=[lst[j],j+1]\nlst.sort()\nstk=[]\ni=0\nfor j in range(2*n):\n    if s[j]=='0':\n        stk.append(lst[i][1])\n        print(lst[i][1],end=\" \")\n        i+=1\n    \n    else:\n        print(stk[-1],end=\" \")\n        stk.pop()\n        ", "complexity": "nlogn"}
{"src": "n = int(input())\np = list(map(lambda x: int(x) - 1, input().split()))\n\nvis = [False] * n\nodd = 0\nfor x in range(n):\n    if vis[x]:\n        continue\n    odd ^= 1\n    while not vis[x]:\n        odd ^= 1\n        vis[x] = True\n        x = p[x]\n\nprint('Petr' if (n + odd) % 2 == 0 else 'Um_nik')\n", "complexity": "nlogn"}
{"src": "import sys\n\nn = int(sys.stdin.readline().rstrip())\nnums = list(map(int, sys.stdin.readline().split()))\n\nswaps = 0\nvisited = set()\nfor index in range(n):\n    if index in visited:\n        continue\n    else:\n        visited.add(index)\n        length = 0\n        value = nums[index]\n        while (value != index + 1):            \n           visited.add(value - 1)\n           value = nums[value - 1]\n           length += 1\n        swaps += length\n\nif ((3 * n - swaps) % 2):\n    print(\"Um_nik\")\nelse:\n    print(\"Petr\")\n\n\n\n\n \t\t \t\t \t    \t  \t  \t \t \t\t \t\t\t\t", "complexity": "nlogn"}
{"src": "n = int(input())\ns = ['']\nfor i in range(n):\n\tinp = input()\n\ts.append(inp)\n\tpos = len(s) - 1\n\twhile len(s[pos]) < len(s[pos-1]):\n\t\ts[pos], s[pos-1] = s[pos-1], s[pos]\n\t\tpos -= 1\nout = 'YES'\nfor i in range(n):\n\tif not s[i] in s[i+1]:\n\t\tout = 'NO'\n\t\ts = []\n\t\tbreak\nprint(out + '\\n'.join(s))\n\t \t\t\t   \t\t\t  \t \t\t\t\t\t  \t\t    \t\t", "complexity": "nlogn"}
{"src": "n = int(input())\nar = []\nfor i in range(n):\n    ar.append(input())\nsortedAr = sorted(ar,key=len)\nflag = False\nfor i in range(n-1):\n    if sortedAr[i+1].find(sortedAr[i]) == -1:\n        print('NO')\n        flag = True\n        break\nif not flag:\n    print('YES')\n    for i in sortedAr:\n        print(i)\n \t \t \t    \t\t\t \t   \t \t \t\t\t \t \t\t", "complexity": "nlogn"}
{"src": "o=int(input())\nuk=[]\ngh=0\nuo=0\nfor i in range(o):\n    yu=input()\n    if(len(yu)>gh):\n        gh=len(yu)\n        uo=i\n    uk.append(yu)\n        \nyk=0\nyj={}\n\ntd=0  \nuk.sort()\nfor i in range(len(uk)-1):\n    for j in range(i+1,len(uk)):\n        if(len(uk[j])<len(uk[i])):\n            t=uk[j]\n            uk[j]=uk[i]\n            uk[i]=t\nfor i in range(1,len(uk)):\n    j=i\n    while(j>=0):\n        if(uk[i].count(uk[j])==0):\n            td=1\n        j=j-1\nif(td==0):        \n    print('YES')   \n    for i in uk:\n        print(i)            \nelse:   \n    print('NO')\n\n \t\t \t \t\t\t \t\t\t\t\t \t\t\t\t\t\t     \t\t", "complexity": "nlogn"}
{"src": "from sys import stdin\ninput = stdin.buffer.readline\n    \nn=int(input())\narr=[int(x) for x in input().split()]\n\narr.sort()\ns=set(arr)\nflag=False\nfor ele in arr:\n    for i in range(31):\n        if ((ele-2**i) in s) and ((ele+2**i) in s):\n            ans=[ele,ele-2**i,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(3) \n    print(*ans)    \n    exit()\nfor ele in arr:\n    for i in range(31):\n        if (ele+2**i) in s:\n            ans=[ele,ele+2**i]\n            flag=True\n            break\n    if flag:\n        break\nif flag:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(arr[0])", "complexity": "nlogn"}
{"src": "n = int(input())\na = [int(i) for i in input().split()]\n\nd = {}\npower = [2**i for i in range(31)]\nans = []\nfor i in a:\n    d[i] = 0\n\nfor num in d.keys():\n    for p in power:\n        if num+p in d:\n            ans = [num, num+p]\n            if num+p+p in d:\n                print(3)\n                ans.append(num+p+p)\n                print(*ans)\n                exit()\nif ans:\n    print(2)\n    print(*ans)\nelse:\n    print(1)\n    print(a[0])\n", "complexity": "nlogn"}
{"src": "n = int(input())\narr = set(map(int,input().split()))\n\ndef solve():\n    for i in arr:\n        for k in range(31):\n            if i - (1 << k) in arr and i + (1 << k) in arr:\n                return [i - (1 << k), i, i + (1 << k)]\n    for i in arr:\n        for k in range(31):\n            if i + (1 << k) in arr:\n                return [i, i + (1 << k)]\n    \n    for i in arr:\n        return [i]\n\nlst = solve()\n# print(lst)\nprint(len(lst))\nprint(*lst)\n", "complexity": "nlogn"}
{"src": "import sys\nfrom array import array\nfrom bisect import bisect_right\n\nn, k = map(int, input().split())\na = sorted(map(int, input().split())) + [10**9]\nans = n\n\nfor x in a[:-1]:\n    if a[bisect_right(a, x)] <= x+k:\n        ans -= 1\n\nprint(ans)\n", "complexity": "nlogn"}
{"src": "# Author Name: Ajay Meena\n# Codeforce : https://codeforces.com/profile/majay1638\nimport sys\nimport math\nimport bisect\nimport heapq\nfrom bisect import bisect_right\nfrom sys import stdin, stdout\n\n# -------------- INPUT FUNCTIONS ------------------\n\n\ndef get_ints_in_variables(): return map(\n    int, sys.stdin.readline().strip().split())\n\n\ndef get_int(): return int(sys.stdin.readline())\n\n\ndef get_ints_in_list(): return list(\n    map(int, sys.stdin.readline().strip().split()))\ndef get_list_of_list(n): return [list(\n    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n\ndef get_string(): return sys.stdin.readline().strip()\n\n# -------- SOME CUSTOMIZED FUNCTIONS-----------\n\n\ndef myceil(x, y): return (x + y - 1) // y\n\n# -------------- SOLUTION FUNCTION ------------------\n\n\ndef Solution(td, n, k):\n    # Write Your Code Here\n    mxHeap = []\n    td = sorted(td, key=lambda x: x[0])\n    prefix = []\n    tmp = 0\n    for v in td:\n        b = v[1]\n        tmpAns = tmp+b\n        if len(mxHeap) == k:\n            if len(mxHeap) and b > mxHeap[0]:\n                t = heapq.heappop(mxHeap)\n                heapq.heappush(mxHeap, b)\n                tmp -= t\n                tmp += b\n        elif len(mxHeap) < k:\n            tmp += b\n            heapq.heappush(mxHeap, b)\n        prefix.append([tmpAns, v[2]])\n\n    ans = [0 for _ in range(n)]\n    for v in prefix:\n        ans[v[1]] = v[0]\n    print(*ans)\n\n\ndef main():\n    # Take input Here and Call solution function\n    n, k = get_ints_in_variables()\n    a = get_ints_in_list()\n    b = get_ints_in_list()\n    td = [[a[i], b[i], i] for i in range(n)]\n    Solution(td, n, k)\n\n\n# calling main Function\nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\nfrom collections import defaultdict as dd\nn=int(input())\nd=dd(int)\nfor i in range(n):\n    l,r=map(int,input().split())\n    d[l] +=1\n    d[r+1] -=1\narr=list(d.keys())\narr.sort()\nans=[0 for i in range(n+1)]\ncount =0\nl=len(arr)\narr.append(arr[-1])\nfor i in range(l):\n    count +=d[arr[i]]\n    ans[count] +=arr[i+1] -arr[i]\nprint(*ans[1:])", "complexity": "nlogn"}
{"src": "from collections import defaultdict\nn = int(input())\narr = defaultdict(int)\nfor a0 in range(n):\n\tl,r = input().strip().split()\n\tl,r=int(l),int(r)\n\tarr[l]+=1\n\tarr[r+1]-=1\n\nbrr=[0]*(n+1)\n\nl=sorted(arr.keys())\nsum=arr[l[0]]\nprevpoint=l[0]\nfor key in l[1:]:\n\tbrr[sum]+=key-prevpoint\n\tprevpoint=key\n\tsum+=arr[key]\nprint(*brr[1:])", "complexity": "nlogn"}
{"src": "from collections import defaultdict\nn, s= int(input()), []\nfor i in range(n):\n  a = [int(x) for x in input().split()]\n  s += [(a[0], 0), (a[1], 1)]\ns.sort()\nnow, rev = 0, defaultdict(int)\nfor a, b in zip(s, s[1:]):\n  now += 1 if a[1] == 0 else -1\n  if(a[1] == 0):\n    rev[now] += b[0] - a[0] + (1 if b[1] == 1 else 0)\n  elif b[0] != a[0]:\n    rev[now] += b[0] - a[0] - (1 if b[1] == 0 else 0)\n[print(rev[i], end=\" \") for i in range(1, n+1)]\n", "complexity": "nlogn"}
{"src": "MAXN = 200001\n\ndef less_sum(s, m):\n    n = len(s)\n    a = 0\n    b = 0\n    res = 0\n    last = 0\n\n    count = [0 for i in range(-MAXN, MAXN+1)]\n\n    count[0] = 1\n    x = 0\n    last = 1\n\n    for i in range(n):\n        if s[i] > m:\n            b += 1\n        else:\n            a += 1\n        x = a-b\n        #print(x)\n        #print(count[-2], count[-1], count[0], count[1], count[2])\n        if s[i] > m:\n            last -= count[x+1]\n        else:\n            last += count[x]\n        #print(x, last)\n        res += last\n        count[x] += 1\n        last += 1\n    \n    #print(res)\n\n    return res\n\nn, m = map(int, input().split(' '))\ns = list(map(int, input().split(' ')))[0:n]\n\n#print(m, s)\n\nprint(less_sum(s, m) - less_sum(s, m-1))", "complexity": "nlogn"}
{"src": "L1=list(map(int, input().split()))\nnumList=list(map(int, input().split()))\nlength=L1[0]\ntargetnumber=L1[1]\npos=numList.index(targetnumber)\npos_r=pos+1\nrem=0\nright={0:1}\nleft={0:1}\nwhile pos_r<=length-1:\n    if numList[pos_r]>targetnumber:\n        rem+=1\n    else:\n        rem-=1\n    if rem not in right:\n        right[rem]=1\n    else:\n        right[rem]+=1\n    pos_r+=1\npos_l=pos-1\nrem=0\nwhile pos_l>=0:\n    if numList[pos_l]>targetnumber:\n        rem+=1\n    else:\n        rem-=1\n    if rem not in left:\n        left[rem]=1\n    else:\n        left[rem]+=1\n    pos_l-=1\nsum=0\nfor number_l in left:\n    if number_l*(-1) in right:\n        sum += (left[number_l] * right[(-1) * number_l])\n    if 1-number_l in right:\n        sum += (left[number_l] * right[1-number_l])\nprint(sum)", "complexity": "nlogn"}
{"src": "n,m=map(int,input().split())\no=0\nc=0\ndiff=[]\nwhile n:\n    n-=1\n    a,b=map(int,input().split())\n    diff.append(a-b)\n    o+=a\n    c+=b\n#print(o,c,diff)\nif m >=o:\n    print(0)\nelif m <c:\n    print(-1)\nelse:\n    diff.sort(reverse=True)\n    nd=o-m\n    #print(diff,nd)\n    for i in range(len(diff)):\n        #print(diff[i])\n        nd-=diff[i]\n        if nd<=0:\n            print(i+1)\n            break\n    \n    ", "complexity": "nlogn"}
{"src": "import sys\ninput=sys.stdin.readline\ndef read():return list(map(int,input().split()))\nn,m=read()\na=[]\nfor i in range(n):\n    a.append(read())\nsm=0\ncur=0\nfor x, y in a:\n    sm+=y\n    cur+=x\nif sm>m:\n    print(-1)\n    quit()\ncnt=0\na.sort(key=lambda x: -x[0]+x[1])\ni = 0\nwhile cur>m and i < n:\n    cur -= a[i][0]-a[i][1]\n    cnt += 1\n    i += 1\nprint(cnt)", "complexity": "nlogn"}
{"src": "import sys,os,io\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef fun(a,b):\n    return (2*(a+b))**2/(a*b)\n\nfor i in range (int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    a.sort()\n    b = []\n    i=0\n    while(i<n-1):\n        if i<n-1 and a[i]==a[i+1]:\n            b.append(a[i])\n            i+=2\n        else:\n            i+=1\n    m = 10**14\n    mi = -1\n    for i in range (len(b)-1):\n        curr = fun(b[i],b[i+1])\n        if curr<m:\n            m = curr\n            mi = i\n    print(b[mi],b[mi],b[mi+1],b[mi+1])", "complexity": "nlogn"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\nfrom collections import defaultdict as dd\nfor t in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l1=dd(int)\n    a=0\n    for j in l:\n        l1[j]+=1\n        if l1[j]==4:\n            a=j\n    if a:\n        print(a,a,a,a)\n    else:\n        c=0\n        x=0\n        l2=[]\n        for j in l1:\n            if l1[j]>=2:\n                l2.append(j)\n        l2.sort()\n        for j in l2:\n                c+=1\n                if c==1:\n                    a=j\n                elif c==2:\n                    b=j\n                else:\n                    if x/j+j/x<a/b+b/a:\n                        a,b=x,j\n                x=j\n        print(a,a,b,b)", "complexity": "nlogn"}
{"src": "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            print(mx, mx, mx, mx)\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            print(res[minj],res[minj],res[minj+1],res[minj+1])", "complexity": "nlogn"}
{"src": "#by Nick \"LordVader\" Proshin\nimport sys\ninput = sys.stdin.readline\nout = sys.stdout\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == 1:\n        print(a[0],a[0],a[0],a[0])\n    else:\n        a.sort()\n        g1 = False\n        d = {}\n        mx = 10001\n        for i in a:\n            if i not in d.keys():\n                d[i] = 1\n            else:\n                d[i] += 1\n            if d[i] == 4:\n                g1 = True\n                if i < mx:\n                    mx = i\n        if g1:\n            out.write(str(mx)+\" \"+str(mx)+\" \"+str(mx)+\" \"+str(mx)+\"\\n\")\n        else:\n            res = []\n            for k in d.keys():\n                if d[k] >= 2:\n                    res.append(k)\n            m = len(res)\n            minj = 0\n            for j in range(m - 1):\n                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):\n                    minj = j\n            out.write(str(res[minj])+\" \"+str(res[minj])+\" \"+str(res[minj+1])+\" \"+str(res[minj+1])+\"\\n\")\n          ", "complexity": "nlogn"}
{"src": "n, k = map(int, input().split())\nv = list(map(int, input().split()))\n \nd = {}\nans = 0\n \nfor x in v:\n  num_d, mod_k = len(str(x)), x % k\n  d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)\n \nfor x in v:\n  num_d, mod_k = len(str(x)), x % k\n  for add, mods in d.items():\n    val_mod = (mod_k * 10 ** add) % k\n    need_mod = (k - val_mod) % k\n    ans += len(mods.get(need_mod, []))\n    if need_mod == mod_k and add == num_d:\n      ans -= 1\n \nprint(ans)\n", "complexity": "nlogn"}
{"src": "from math import log10\nfrom collections import Counter\n\nn,k=[int(x) for x in input().split()]\nlst=[int(x) for x in input().split()]\nlst2=[]\n\nfor i in range(n):\n    lst2.append(((lst[i]%k),len(str(lst[i]))))\n\ndp = [[] for i in range(12)]\nfor j in lst2:\n    dp[j[1]].append(j[0])\nfor i in range(12):\n    if len(dp[i]) > 0:\n        dp[i] = Counter(dp[i])\nans = 0\nfor i in lst:\n    for j in range(2, 12):\n        v1 = ((i%k) * pow(10, j-1))%k\n        if (k - v1)%k in  dp[j-1]:\n            ans=ans+dp[j-1][(k-v1)%k]\nfor i in lst:\n    if int(str(i)+str(i))%k==0 :\n        ans=ans-1\nprint(ans)\n\n", "complexity": "nlogn"}
{"src": "import sys\n\nnext(sys.stdin)\n\npositions = {}\npos2x = {}\nfor i, x in enumerate(next(sys.stdin).split()):\n    x = int(x)\n    positions[x] = i\n    pos2x[i] = x\n\nanswers = ['' for _ in range(len(positions))]\n\nfor x in range(len(positions), 0, -1):\n\n    position = positions[x]\n\n    def can_go_to_looser():\n\n        next_position = position + x\n        while next_position < len(positions):\n\n            if pos2x[next_position] > x and answers[next_position] == \"B\":\n                return True\n\n            next_position += x\n\n        next_position = position - x\n        while next_position >= 0:\n\n            if pos2x[next_position] > x and answers[next_position] == \"B\":\n                return True\n\n            next_position -= x\n\n        return False\n\n    if can_go_to_looser():\n        answers[position] = \"A\"\n    else:\n        answers[position] = \"B\"\n\nprint(''.join(answers))\n", "complexity": "nlogn"}
{"src": "n = int(input())\nfst, nxt, lst, des = [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)]\ncnt = 0\n\ndef add(u, v) :\n\tglobal cnt\n\tcnt += 1\n\tif fst[u] == 0 :\n\t\tfst[u] = cnt\n\telse :\n\t\tnxt[lst[u]] = cnt\n\tlst[u], des[cnt] = cnt, v\n\nfor i in range(1, n) : \n\tu, v = map(int, input().split())\n#\tprint(u, v)\n\tadd(u, v)\n\tadd(v, u)\n\na = list(map(int, input().split()))\ndeep = [0 for i in range(n + 1)]\ndeep[1] = 1\nnow, res = 1, 1\nAns = 0\n\nfor i in range(0, n) :\n\tif deep[a[i]] == 0 : \n\t\tAns = 1\n\t\tbreak\n\telif deep[a[i]] < now :\n\t\tAns = 1\n\t\tbreak\n\telse : \n\t\tb = fst[a[i]]\n\t\tres += 1\n\t\twhile b > 0 :\n\t\t\tif deep[des[b]] == 0 : \n\t\t\t\tdeep[des[b]] = res\n\t\t\tb = nxt[b]\n\t\tnow = deep[a[i]]\n\nif Ans == 0 :\n\tprint(\"Yes\")\nelse :\n\tprint(\"No\")\n", "complexity": "nlogn"}
{"src": "import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nt=True\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            t=False\n            break\n    else:\n        c+=aux\n        c1+=1\n        continue\n    break\nif t:\n    print(\"Yes\")\n", "complexity": "nlogn"}
{"src": "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = [abs(x) for x in a] \nif n == 1:\n    ans = a[0]\nelif all(x > 0 for x in a) or all(x < 0 for x in a):\n    b.sort()\n    ans = sum(b) - 2 * b[0]\nelse:\n    ans = sum(b)\nprint(ans)\n", "complexity": "nlogn"}
{"src": "n = int(input())\np = list(map(int, input().split()))\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    gr[p[i] - 1].append(i + 1)\n\nq = [0]\nafter = []\ni = 0\ns = [0 for i in range(n)]\nused = set()\nused.add(0)\nwhile q:\n    cur = q.pop()\n    after.append(cur)\n    for el in gr[cur]:\n        if el not in used:\n            used.add(el)\n            q.append(el)\n            i += 1\n\nq = after\nfor j in range(i, -1, -1):\n    if len(gr[q[j]]) == 0:\n        s[q[j]] = 1\n    else:\n        ans = 0\n        for c in gr[q[j]]:\n            ans += s[c]\n        s[q[j]] = ans\ns.sort()\nprint(' '.join(list(map(str, s))))\n", "complexity": "nlogn"}
{"src": "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(1000000)\nmod=int(1e9+7)\n\ndef bfs(x):\n    cnt=0\n    for i in tree[x]:\n        bfs(i)\n        cnt+=a[i]\n    if len(tree[x])==0:\n        cnt=1\n    a[x]=cnt\n\nn=int(data())\ntree=[{} for i in range(n)]\nif n>1:\n    P=list(mdata())\n    for i in range(n-1):\n        tree[P[i]-1][i+1]=0\n    a=[0]*n\n    for i in range(n-1,-1,-1):\n        if len(tree[i])==0:\n            a[i]=1\n        else:\n            for j in tree[i]:\n                a[i]+=a[j]\n    a.sort()\nelse:\n    a=[1]\nprint(*a)", "complexity": "nlogn"}
{"src": "\"\"\"n,L,a=map(int,input().split())\n#s=[int(x) for x in input().split()]\ned=0\nct=0\nfor j in range(0,n):\n    t,l=map(int,input().split())\n    ct=ct+((t-ed)//a)\n    ed=t+l\nt=L\nct=ct+((t-ed)//a)\nprint(ct)\"\"\"\n\n\"\"\"n,m=map(int,input().split())\ndp=[[-1 for i in range(m)] for j in range(n)]\ndp2=[[-1 for i in range(m)] for j in range(n)]\n#dp=[]\n#dp2=[]\nfor i in range(0,n):\n    s=input()\n    for j in range(0,m):\n        if(s[j]=='.'):\n            dp[i][j]=-1\n        else:\n            dp[i][j]=s[j]\nfor i in range(0,n-2):\n    for j in range(0,m-2):\n        #print(i,j)\n        p=0\n        c=0\n        for k in range(i,i+3):\n            for h in range(j,j+3):\n                p=p+1\n                if(p!=5):\n                    if(dp[k][h]=='#'):\n                        c=c+1\n\n                    \n        if(c==8):\n            p=0\n            for k in range(i,i+3):\n                for h in range(j,j+3):7\n                    p=p+1\n                    if(p!=5):\n                        dp2[k][h]='#'\n\n\n                        \n#print(dp)\n#print(dp2)\nif(dp==dp2):\n    print('YES')\nelse:\n    print('NO')\"\"\"\n\n\nimport math\nn=int(input())\nif(n==3):\n    print('1 1 3')\n\nelse:\n    t=1\n    while(t<=n):\n        ct=math.ceil((n//t)/2)\n        for i in range(0,ct):\n            print(t,end=\" \")\n        #t=t*2\n        if(ct==2 and (n//t)%2!=0):\n            t=t*3\n        else:\n            t=t*2\n    print(\" \")\n\n                            \n", "complexity": "nlogn"}
{"src": "from math import ceil\n\nn=int(input())\nd={1:[1],2:[1,2],3:[1,1,3]}\nif n in d:\n    for i in d[n]:\n        print(i,end=' ')\n    exit()\ndef f(n):\n    if n in d:\n        return d[n]\n    odds=ceil(n/2)\n    lis=[1]*odds\n    even=n//2\n    lis1=f(even)\n    for i in range(len(lis1)):\n        lis1[i]*=2\n    return lis+lis1\nans=f(n)\nfor i in ans:\n    print(i,end=' ')", "complexity": "nlogn"}
{"src": "import sys\ninput_file = sys.stdin\n\n[n,m] = list(int(x) for x in input_file.readline().split())\nstacks = list(int(x) for x in input_file.readline().split())\nstacks.sort()\n\nans = 0\ncur_stack = 0\ncur_h = 0\n\nwhile cur_stack < n:\n    ans += 1\n    if stacks[cur_stack] >= cur_h + 1:\n        cur_h += 1\n    cur_stack += 1\nans += stacks[-1] - cur_h \n    \nprint(sum(stacks) - ans)\n", "complexity": "nlogn"}
{"src": "n, m = map(int, input().split())\ny = []\nfor i in range(n):\n    y.append(int(input()))\ny.append(10 ** 9)\nx = []\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    if a == 1:\n        x.append(b)\ny.sort(); x.sort()\nm = len(x)\nans = m\nk = 0\nfor i in range(n + 1):\n    ok = True\n    for j in range(k, m):\n        if y[i] <= x[j]:\n            k = j\n            ok = False\n            break\n    if ok:\n        k = m\n        ans = min(ans, m - k + i)\n        break\n    ans = min(ans, m - k + i)\nprint(ans)\n#    \n", "complexity": "nlogn"}
{"src": "from bisect import bisect_left\n\ndef readint():\n    return int(input())\n\n\ndef readline():\n    return [int(c) for c in input().split()]\n\n# similar to 45311982\ndef main():\n    MAX = 10**9\n    n, m = readline()\n    v = sorted([readint() for _ in range(n)])\n\n    h = []\n    for _ in range(m):\n        x1, x2, _ = readline()\n        if x1 == 1:\n            h.append(x2)\n    h.sort()\n\n    lh = len(h)\n    if lh == 0:\n        print(0)\n    elif n == 0:\n        print(lh - bisect_left(h, MAX))\n    else:\n        mn = n + lh - bisect_left(h, MAX)\n        for i in range(n):\n            mn = min(mn, lh - bisect_left(h, v[i]) + i)\n        print(mn)\n\n                  \nif __name__ == '__main__':\n    main()\n", "complexity": "nlogn"}
{"src": "from bisect import bisect\nn, m = map(int, input().split())\nvv = sorted([int(input()) for _ in range(n)])\nhh = [0] * n\nrr = 0\nfor _ in range(m):\n  one, x, _ = map(int, input().split())\n  if one == 1:\n    if x == 1000000000:\n      rr += 1\n    else:  \n      ind = bisect(vv, x)\n      if ind:\n        hh[ind-1] += 1\nr = n\ns = 0\n#print(*vv)\n#print(*hh) \nfor i, h in reversed(list(enumerate(hh))):\n  s += h\n  #print(\"~\", r, s)\n  r = min(r, s+i)\nprint(r+rr)  \n    ", "complexity": "nlogn"}
{"src": "import sys\ninput = sys.stdin.readline\nfrom collections import *\n\ndef judge(x):\n    ins = [0]*n\n    outs = defaultdict(list)\n    \n    for u, v, c in edges:\n        if c>x:\n            ins[v] += 1\n            outs[u].append(v)\n    \n    q = deque([v for v in range(n) if ins[v]==0])\n    cnt = 0\n    \n    while q:\n        v = q.popleft()\n        cnt += 1\n        \n        for nv in outs[v]:\n            ins[nv] -= 1\n            \n            if ins[nv]==0:\n                q.append(nv)\n        \n    return cnt==n\n\ndef binary_search():\n    l, r = 0, 10**9+10\n    \n    while l<=r:\n        m = (l+r)//2\n        \n        if judge(m):\n            r = m-1\n        else:\n            l = m+1\n    \n    return l\n\nn, m = map(int, input().split())\nedges = []\nidx = defaultdict(lambda : deque([]))\n\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges.append((u, v, c))\n    idx[10**6*u+v].append(i+1)\n\nk = binary_search()\nins = [0]*n\nouts = defaultdict(list)\nremoved = []\n\nfor u, v, c in edges:\n    if c>k:\n        ins[v] += 1\n        outs[u].append(v)\n    else:\n        removed.append((u, v))\n    \nq = deque([v for v in range(n) if ins[v]==0])\norder = [-1]*n\ncnt = 0\n\nwhile q:\n    v = q.popleft()\n    order[v] = cnt\n    cnt += 1\n    \n    for nv in outs[v]:\n        ins[nv] -= 1\n        \n        if ins[nv]==0:\n            q.append(nv)\n\nchange = []\n\nfor u, v in removed:\n    if order[v]<order[u]:\n        change.append(idx[10**6*u+v].popleft())\n\nprint(k, len(change))\nprint(*change)", "complexity": "nlogn"}
{"src": "n, m = map(int, input().split())\nb = list(map(int, input().split()))\ng = list(map(int, input().split()))\nmab = max(b)\nmig = min(g)\nif mab > mig:\n    print(-1)\n    exit()\n\nb = sorted(b, reverse=True)\ng = sorted(g)\nnum = 0\nj = 0\nfor i in range(n):\n    k = 0\n    l = 1\n    while j < m and k < m - l and b[i] <= g[j]:\n        if b[i] == g[j]:\n            l = 0\n        num += g[j]\n        j += 1\n        k += 1\n    num += b[i] * (m - k)\n\nprint(num)", "complexity": "nlogn"}
{"src": "n=int(input())\nl=sorted(list(map(int,raw_input().split())))\ndef f():\n    global n\n    dou=False\n    for k in range(1,n):\n        if l[k]==l[k-1]:\n            if dou or l[k]==0 or (l[k]==l[k-2] and n!=2) or l[k]==l[k-2]+1:\n                return False\n            else:\n                dou=True\n    return (sum(l)-(n*(n-1))//2)%2\nif f():\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")\n", "complexity": "nlogn"}
{"src": "l = input().split()\nif l[0]==l[1] and l[1]==l[2]:\n    print(0)\n    exit(0)\ndef shuntsu(li):\n    li.sort()\n    return li[0][1]==li[1][1] and li[1][1]==li[2][1] and int(li[1][0])==int(li[0][0])+1 and int(li[2][0])==int(li[1][0])+1\nif shuntsu(l):\n    print(0)\n    exit(0)\nfor k in l:\n    if len([x for x in l if x==k]) > 1:\n        print(1)\n        exit(0)\n    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+1]) !=0:\n        print(1)\n        exit(0)\n    if len([x for x in l if x[1]==k[1] and int(x[0]) == int(k[0])+2]) != 0:\n        print(1)\n        exit(0)\nprint(2)\n", "complexity": "nlogn"}
{"src": "from sys import stdin, stdout, exit\n\nt1, t2, t3 = stdin.readline().split()\n\nif t1 == t2 and t2 == t3:\n    print(0)\n    exit()\n\nts = [(int(t[0]), t[1]) for t in [t1, t2, t3]]\nts.sort()\nns = [t[0] for t in ts]\nss = [t[1] for t in ts]\n\nif ns[0] + 1== ns[1] and ns[0] + 2 == ns[2] and ss[0] == ss[1] and ss[1] == ss[2]:\n    print(0)\n    exit()\nif ns[0] + 2 >= ns[1] and ss[1] == ss[0]:\n    print(1)\n    exit()\nif ns[1] + 2 >= ns[2] and ss[1] == ss[2]:\n    print(1)\n    exit()\nif ns[0] + 2 >= ns[2] and ss[0] == ss[2]:\n    print(1)\n    exit()\nif ts[0] == ts[1] or ts[1] == ts[2] or ts[2] == ts[0]:\n    print(1)\n    exit()\n\nprint(2)\n", "complexity": "nlogn"}
{"src": "from sys import exit\nt = input().split()[:3:]\ns = set(t)\nres = 3\nif len(s)==1:\n\tres = min(res,0)\nelif len(s)==2:\n\tres = min(res,1)\nelif len(s)==3:\n\tres = min(res,2)\nif res==0:\n\tprint(res)\n\texit(0)\nt.sort()\nm = [int(a[0]) for a in t if a[1]=='m']\np = [int(a[0]) for a in t if a[1]=='p']\ns = [int(a[0]) for a in t if a[1]=='s']\ndef f(a):\n\tres = 2\n\tfor i in a:\n\t\tif (i-1 in a and i+1 in a)or(i-2 in a and i-1 in a)or(i+1 in a and i+2 in a):\n\t\t\treturn 0\n\t\telif i-1 in a or i+1 in a or i-2 in a or i+2 in a:\n\t\t\tres = min(res,1)\n\treturn res\nres = min([res,f(m),f(p),f(s)])\nprint(res)", "complexity": "nlogn"}
{"src": "import math\n\nn, m, k = list(map(lambda i: int(i), input().split(sep=' ')))\np = list(map(lambda i: int(i), input().split(sep=' ')))\np.sort()\npage_max = k\naction_count = 0\nindex = 0\nwhile index < m:\n    while index < m and p[index] <= page_max:\n        count = 0\n        while index < m and p[index] <= page_max:\n            index += 1\n            count += 1\n        if count > 0:\n            action_count += 1\n        page_max += count\n\n    pc = 1 if index >= m else math.ceil((p[index] - page_max) / k)\n    page_max += k * pc\n\nprint(action_count)\n", "complexity": "nlogn"}
{"src": "n = int(input())\nai = list(map(int,input().split()))\nai.sort()\nnum = 0\nnum2 = 0\nfor i in range(1,n):\n    if ai[i-1] == ai[i]:\n        num += 1\n        num2 = i\nif num == 0:\n    num3 = sum(ai)\n    num4 = n * (n-1) // 2\n    ans = (num3 - num4) % 2\n    if ans == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\nelif num == 1:\n    if (num2 > 1 and ai[num2-2] == ai[num2] - 1) or ai[num2] == 0:\n        print(\"cslnb\")\n    else:\n        num3 = sum(ai)\n        num4 = n * (n-1) // 2\n        ans = (num3 - num4) % 2\n        if ans == 1:\n            print(\"sjfnb\")\n        else:\n            print(\"cslnb\")\nelse:\n    print(\"cslnb\")\n", "complexity": "nlogn"}
{"src": "n = int(input())\nli = list(map(int, input().split()))\nx = li.index(max(li))\nif li[:x] == sorted(li[:x]) and li[x:] == sorted(li[x:])[::-1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "complexity": "nlogn"}
{"src": "n, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nnew_arr = []\nfor i in range(n - 1):\n\tnew_arr.append(arr[i + 1] - arr[i])\n\nnew_arr.sort()\nprint(sum(new_arr[:n - k]))\n", "complexity": "nlogn"}
{"src": "n, k = [int(i) for i in input().split()]\ndata = [int(i) for i in input().split()]\nspan = data[-1] - data[0]\ndelta = [data[i+1] - data[i] for i in range(n-1)]\ndelta.sort(reverse=True)\nprint(span - sum(delta[:k-1]))\n\n", "complexity": "nlogn"}
{"src": "n, k = map(int, input().split())\nl = list(map(int, input().split()))\ncost = l[n - 1] - l[0]\nif k == 1:\n\tprint(cost)\nelse:\n\tdiff = [0 for _ in range(n - 1)]\n\tfor i in range(n - 1):\n\t\tdiff[i] = l[i + 1] - l[i]\n\t#print(diff)\n\tdiff = sorted(diff)\n\tdiff.reverse()\n\tprint(cost - sum(diff[:k - 1]))", "complexity": "nlogn"}
{"src": "n, k = map(int, input().split())\nA = list(map(int, input().split()))\nB = []\nfor i in range(n - 1):\n    B.append([A[i + 1] - A[i], i])\nB.sort(reverse=True)\nC = []\nfor i in range(k - 1):\n    C.append(B[i][1])\nC.sort()\nans = 0\nmi = 10 ** 9\nma = -10 ** 9\nu = 0\nfor i in range(n):\n    mi = min(mi, A[i])\n    ma = max(ma, A[i])\n    if u < len(C) and i == C[u]:\n        ans += ma - mi\n        mi = 10 ** 9\n        ma = -10 ** 9\n        u += 1\nprint(ans + ma - mi)", "complexity": "nlogn"}
{"src": "n,r=list(map(int,input().split()))\nx=list(map(int,input().split()))\ny=[r]*n\nfor i in range(1,n):\n    for j in range(i):\n        d=abs(x[i]-x[j])\n        if d<=2*r:\n            y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5))\nprint(*y)", "complexity": "quadratic"}
{"src": "import math\nn, r = [int(x) for x in input().split()]\nx = [int(x) for x in input().split()]\nans = []\nfor i in range(n):\n    t = r\n    for j in range(i):\n        a = abs(x[i] - x[j])\n        if a <= 2 * r:\n            t2 = (2 * r)**2\n            t2 -= a**2\n            t2 = math.sqrt(t2) + ans[j]\n            t = max(t, t2)\n    ans.append(t)\nfor k in ans:\n    print(k)\n\t \t\t\t\t \t\t\t \t\t  \t\t\t \t\t\t\t   \t\t\t\t\t", "complexity": "quadratic"}
{"src": "# this is directly from: https://codeforces.com/contest/908/submission/46821547\n# you can disregard this answer if desired\n\nn, r = map(int, input().split())\ny = []\nx = list(map(int, input().split()))\nfor xi in x:\n    yi = r\n    for tx, ty in zip(x, y):\n        if xi - 2 * r <= tx <= xi + 2 * r:\n            dy = (4.0 * r ** 2 - (tx - xi) ** 2) ** 0.5\n            yi = max(yi, ty + dy)\n    y.append(yi)\nprint(*y)\n\n\t\t\t\t  \t\t\t \t\t \t\t\t\t\t   \t\t   \t\t \t", "complexity": "quadratic"}
{"src": "import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\ny = [r]\n\nfor i in range(1, n):\n    _y = r\n    for j in range(i):\n        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):\n            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))\n    y.append(_y)\n\nprint(' '.join(map(str, y)))\n", "complexity": "quadratic"}
{"src": "import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap,0,len(heap)-1)\nfrom math import gcd as Gcd\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n\ndef Extended_Euclid(n,m):\n    stack=[]\n    while m:\n        stack.append((n,m))\n        n,m=m,n%m\n    if n>=0:\n        x,y=1,0\n    else:\n        x,y=-1,0\n    for i in range(len(stack)-1,-1,-1):\n        n,m=stack[i]\n        x,y=y,x-(n//m)*y\n    return x,y\n\nclass MOD:\n    def __init__(self,p,e=1):\n        self.p=p\n        self.e=e\n        self.mod=self.p**self.e\n\n    def Pow(self,a,n):\n        a%=self.mod\n        if n>=0:\n            return pow(a,n,self.mod)\n        else:\n            assert math.gcd(a,self.mod)==1\n            x=Extended_Euclid(a,self.mod)[0]\n            return pow(x,-n,self.mod)\n\n    def Build_Fact(self,N):\n        assert N>=0\n        self.factorial=[1]\n        self.cnt=[0]*(N+1)\n        for i in range(1,N+1):\n            ii=i\n            self.cnt[i]=self.cnt[i-1]\n            while ii%self.p==0:\n                ii//=self.p\n                self.cnt[i]+=1\n            self.factorial.append((self.factorial[-1]*ii)%self.mod)\n        self.factorial_inv=[None]*(N+1)\n        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)\n        for i in range(N-1,-1,-1):\n            ii=i+1\n            while ii%self.p==0:\n                ii//=self.p\n            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod\n\n    def Fact(self,N):\n        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod\n\n    def Fact_Inv(self,N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inv[N]\n\n    def Comb(self,N,K,divisible_count=False):\n        if K<0 or K>N:\n            return 0\n        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod\n        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]\n        if divisible_count:\n            return retu,cnt\n        else:\n            retu*=pow(self.p,cnt,self.mod)\n            retu%=self.mod\n            return retu\n\ndef Bell_Numbers(N,mod,prime=False):\n    bell_numbers=[0]*(N+1)\n    bell_numbers[0]=1\n    MD=MOD(mod)\n    if prime:\n        MD.Build_Fact(min(mod-2,N-1))\n        for i in range(1,min(mod,N+1)):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n        for i in range(mod,N+1):\n            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod\n    else:\n        MD.Build_Fact(N-1)\n        for i in range(1,N+1):\n            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod\n    return bell_numbers\n\nM,N=map(int,readline().split())\nS=[readline().rstrip() for i in range(N)]\ndct=defaultdict(int)\nfor i in range(M):\n    tpl=()\n    for j in range(N):\n        tpl+=(S[j][i],)\n    dct[tpl]+=1\nans=1\nmod=10**9+7\nbell=Bell_Numbers(M,mod)\nfor c in dct.values():\n    ans*=bell[c]\n    ans%=mod\nprint(ans)", "complexity": "quadratic"}
{"src": "def main():\n    # import sys\n    # input = sys.stdin.readline\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                cnt += 1\n    even = cnt % 2 == 0\n    q = int(input())\n    ans = []\n    for _ in range(q):\n        l, r = map(int, input().split())\n        len = r - l + 1\n        pairs = len * (len-1) // 2\n        if pairs % 2 == 1:\n            even = not even\n        if even:\n            ans.append('even')\n        else:\n            ans.append('odd')\n    print('\\n'.join(ans))\n\n\nmain()", "complexity": "quadratic"}
{"src": "import zlib, base64\nexec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))\n \t\t\t   \t \t   \t   \t  \t\t \t  \t\t\t \t", "complexity": "quadratic"}
{"src": "def rotate_90(a):\n    b=[]\n    for x in range(len(a)):\n        l=[]\n        for y in range(len(a)-1,-1,-1):\n            l.append(a[y][x])\n        b.append(l)\n    return b\ndef flip(a):\n    b=[]\n    for x in range(len(a)):\n        l=[]\n        for y in range(len(a)-1,-1,-1):\n            l.append(a[x][y])\n        b.append(l)\n    return b\nn=int(input())\nl=[]\nfor i in range(n):\n    a=input()\n    l2=[]\n    for i2 in a:\n        l2.append(i2)\n    l.append(l2)\nl2=[]\nfor i in range(n):\n    a=input()\n    l3=[]\n    for i2 in a:\n        l3.append(i2)\n    l2.append(l3)\nd='no'\nfor i in range(4):\n    l = rotate_90(l)\n    if l==l2:\n        d='yes'\nl=flip(l)\nfor i in range(4):\n    l = rotate_90(l)\n    if l==l2:\n        d='yes'\nprint(d)\n", "complexity": "quadratic"}
{"src": "n,m=map(int,input().split())\nc=input().split()\ncol=[0]*n\nfor i in range(len(c)):\n    col[int(c[i])-1]+=1\nprint(min(col))", "complexity": "quadratic"}
{"src": "if __name__==\"__main__\":\n    dic={}\n    n,m=map(int,input().split())\n    li=list(map(int,input().split()))\n    c=0\n    for i in range(n):\n        dic.setdefault(i+1,0)\n    for i in li:\n        if 0 not in dic.values():\n            c=c+1\n            for j in range(1,n+1):\n                dic[j]=dic[j]-1\n\n        dic[i]=dic[i]+1\n    if 0 not in dic.values():\n        c=c+1\n    print(c)\n", "complexity": "quadratic"}
{"src": "import sys,math,itertools\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nfrom heapq import heappop,heappush,heapify, nlargest\nfrom copy import deepcopy\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))\ndef inps(): return sys.stdin.readline()\ndef inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])\ndef err(x): print(x); exit()\n\nn = inp()\ns = []\nfor _ in range(4):\n    tmp = [input() for i in range(n)]\n    if _<3: input()\n    s.append(tmp)\nres = INF\nfor pt in itertools.combinations(range(4),2):\n    cnt = 0\n    for k in range(4):\n        f = 1 if k in pt else 0\n        for i in range(n):\n            for j in range(n):\n                if (i+j+f)%2 != int(s[k][i][j]): cnt += 1\n    res = min(res, cnt)\nprint(res)", "complexity": "quadratic"}
{"src": "# link: https://codeforces.com/problemset/problem/961/C\n\nimport os, sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom math import ceil\nmod = 10 ** 9 + 7 \n\ndef get_original_pieces(x):\n    common = (pow(x, 2) - 1) // 2\n    first_piece = \"10\"*common + '1'\n    second_piece = '0' + \"10\"*common\n    return [first_piece, second_piece]\n\n# number of test cases\nfor _ in range(1):\n    n = int(input())\n    pieces = [\"\" for _ in range(4)]\n    original_pieces = get_original_pieces(n)\n    i = 0\n    for _ in range(3 + (n*4)):\n        s = input()\n        if s:\n            pieces[i] += s\n        else:\n            i += 1   \n    #print(pieces) \n    till = pow(n, 2)\n    fp = [[0,i] for i in range(4)]\n    sp = [[0,i] for i in range(4)]\n    for i in range(4):\n        fpc, spc = 0, 0\n        for j in range(till):\n            if pieces[i][j] != original_pieces[0][j]:\n                fpc += 1\n            if pieces[i][j] != original_pieces[1][j]:\n                spc += 1\n        fp[i][0] = fpc\n        sp[i][0] = spc\n    fp.sort()\n    sp.sort()\n    ans1 = fp[0][0] + fp[1][0]\n    ans2 = sp[0][0] + sp[1][0]\n    for i in range(4):\n        if sp[i][1] not in [fp[0][1], fp[1][1]]: ans1 += sp[i][0]\n        if fp[i][1] not in [sp[0][1], sp[1][1]]: ans2 += fp[i][0]\n    ans = min(ans1, ans2)\n    print(ans)                            ", "complexity": "quadratic"}
{"src": "from itertools import permutations\n\nn = int(input())\na = []\nfor i in range(4):\n    a.append([list(map(int, list(input()))) for j in range(n)])\n    if i < 3:\n        input()\n\nans = 10 ** 10\nfor i in permutations(a, 4):\n    cnt = 0\n    total = 0\n    for j in i:\n        if cnt < 2:\n            cnt2 = 0\n            for p in j:\n                for q in p:\n                    if q != cnt2 % 2:\n                        total += 1\n                    cnt2 += 1\n        else:\n            cnt2 = 1\n            for p in j:\n                for q in p:\n                    if q != cnt2 % 2:\n                        total += 1\n                    cnt2 += 1\n        cnt += 1\n\n    ans = min(ans, total)\n\nprint(ans)", "complexity": "quadratic"}
{"src": "N, K = input().split()\nN, K = int(N), int(K)\nP = [int(x) for x in input().split()]\nA = [None]*256\nA[0] = 0\nfor i in range(N):\n    pn = P[i]\n    if A[pn] is None:\n        for j in range(K-1, -1, -1):\n            if pn < j: continue\n            if A[pn-j] is None:\n                A[pn-j] = pn-j\n                break\n            else:\n                if A[pn-j] + K - 1 >= pn:\n                    break\n        for jj in range(j, -1, -1):\n            A[pn-jj] = A[pn-j]\nprint(*[A[P[i]] for i in range(N)])\n", "complexity": "quadratic"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\n\nn=int(input())\na=list(map(int,input().split()))\ndp=[[0]*(n) for i in range(n)]\nfor i in range(n):\n    dp[i][i]=a[i]\ncount=1\nfor i in range(n-1):\n    for j in range(n-i-1):\n        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]\n    count+=1\ncount=1\nfor i in range(n-1):\n    for j in range(n-i-1):\n        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])\n    count+=1\nfor i in range(int(input())):\n    l,r=map(int,input().split())\n    l-=1\n    r-=1\n    print(dp[l][r])", "complexity": "quadratic"}
{"src": "import sys\ninput=sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nf=[[0]*n for i in range(n)]\nfor i in range(n):\n    f[0][i]=a[i]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=f[i-1][j]^f[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1])\nq=int(input())\nfor _ in range(q):\n    l,r=map(int,input().split())\n    print(f[r-l][l-1])", "complexity": "quadratic"}
{"src": "from sys import stdin\nfrom operator import xor\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, m = int(input()), [rints()], int(input())\nqur, out = [rints() for _ in range(m)], []\n\nfor i in range(1, n):\n    a.append(map(xor, a[-1][:-1], a[-1][1:]))\n\nfor i in range(n - 1):\n    a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1])\n\nfor l, r in qur:\n    out.append(a[r - l][l - 1])\n\nprint('\\n'.join(map(str, out)))\n", "complexity": "quadratic"}
{"src": "import sys\ninput=sys.stdin.readline\nn=int(input())\nar=list(map(int,input().split()))\ndic={}\nli=[]\nfor i in range(n):\n    xx=[]\n    for j in range(n-i):\n        xx.append(0)\n    li.append(xx.copy())\nfor i in range(n):\n    for j in range(n-i):\n        if(i==0):\n            li[i][j]=ar[j]\n        else:\n            li[i][j]=li[i-1][j]^li[i-1][j+1]\nfor i in range(1,n):\n    for j in range(n-i):\n        li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1])\nfor _ in range(int(input())):\n    l,r=map(int,input().split())\n    print(li[r-l][l-1])", "complexity": "quadratic"}
{"src": "# qumeric\nn, m = map(int, input().split())\na = [int(input(), 2) for _ in range(n)]\n\ns = t = 0\nfor x in a:\n    t |= s & x\n    s |= x\nprint((\"YES\", \"NO\")[all(x & s & ~t for x in a)])\n", "complexity": "quadratic"}
{"src": "from sys import stdin,stdout\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int,stdin.readline().split()))\nfor _ in range(1):#nmbr()):\n    n=nmbr()\n    a=lst()\n    b=lst()\n    dp=[0]*n\n    for i in range(n):\n        v=float('inf')\n        for j in range(i+1,n):\n            if a[j]>a[i]:v=min(v,b[i]+b[j])\n        dp[i]=v\n    # print(dp)\n    for i in range(n):\n        v = float('inf')\n        for j in range(i + 1, n):\n            if a[j] > a[i]: v = min(v, b[i] + dp[j])\n        dp[i] = v\n    ans=min(dp)\n    print(ans if ans!=float('inf') else -1)", "complexity": "quadratic"}
{"src": "import sys\n\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\ninput = sys.stdin.readline\n\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n\nans = float('inf')\nfor i in range(1, n-1):\n    bef = aft = float('inf')\n    for j in range(i):\n        if a[j] < a[i]:\n            bef = min(bef, b[j])\n    for j in range(i, n):\n        if a[i] < a[j]:\n            aft = min(aft, b[j])\n    ans = min(ans, b[i]+bef+aft)\nprint(-1 if ans > 10**9 else ans)\n\n\n\n\n", "complexity": "quadratic"}
{"src": "I=lambda:list(map(int,input().split()))\nn,s,a=int(input()),I(),I()\nt=3*10**9\nq=[0]*n\nfor i in range(n-1,-1,-1):\n    u=10**8\n    for j in range(i-1,-1,-1):\n        if s[i]>s[j]:u=min(u,a[j])\n    q[i]=u\nfor i in range(n):\n    for j in range(i+1,n):\n        if s[i]<s[j]:t=min(t,a[i]+a[j]+q[i])\nprint(t if t<=sum(a)else -1)", "complexity": "quadratic"}
{"src": "from math import inf\n\n\nn = int(input())\ns_list = list(map(int, input().split()))\nc_list = list(map(int, input().split()))\n\ntotal_min = inf\nfor j in range(n):\n    min_i = inf\n    for i in range(0, j):\n        if s_list[i] < s_list[j]:\n            min_i = min(min_i, c_list[i])\n\n    min_k = inf\n    for k in range(j + 1, n):\n        if s_list[k] > s_list[j]:\n            min_k = min(min_k, c_list[k])\n\n    total_min = min(total_min, min_i + c_list[j] + min_k)\nif total_min != inf:\n    print(total_min)\nelse:\n    print(-1)", "complexity": "quadratic"}
{"src": "from os import path\nimport sys,time, collections as c , math , pprint as p , itertools as it , operator as op\nmaxx , localsys , mod = float('inf'), 0 , int(1e9 + 7) \nif (path.exists('input.txt')):  sys.stdin=open('input.txt','r') ;   sys.stdout=open('output.txt','w')\ninput = sys.stdin.readline\nn = int(input()) ; s = list(map(int , input().split())) ; c = list(map(int , input().split()))\nans = maxx\nfor mid in range(1 , n - 1):\n    l = [maxx] + [c[i] for i in range(mid) if s[i] < s[mid]]\n    r = [maxx] + [c[i] for i in range(mid+1 , n) if s[i] > s[mid]]\n    ans = min(ans , min(l) + c[mid] + min(r))\nprint(ans if ans != float('inf') else -1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# for _ in  range(int(input())):\n#     n = int(input())\n#     a , i , j ,ok = [[int(i) for i in input().rstrip('\\n')] for _ in range(2)] , 0 , 0 , True\n#     while j < n :\n#         if a[i][j] > 2:\n#             if a[i^1][j] < 3:\n#                 break\n#             else:\n#                 i^=1\n#         j+=1\n#     print('YES' if i==1 and j == n else 'NO')\n#for example suppose if you are at row 1 and standing on the curled tile which will obviously lead to another row\n#and if this row has ( | or - ) then obviously you have no other way to move forward\n#all other combinations are viable\n\n\n\n\n# n = int(input()) ; g = c.defaultdict(list)\n# for _ in range(n-1):\n#     u , v = map(int , input().split())\n#     g[u].append(v)\n#     g[v].append(u)\n# v , q  , ans  = [0]*(n+1) , [(1 ,1 ,0)] , 0 #p , cnt , height\n# while q :\n#     p , cnt , h = q.pop()\n#     v[p] , c = 1 , 0\n#     for i in g[p]:\n#         if not v[i]:\n#             c+=1\n#     if c == 0 :\n#         ans+= cnt*h\n#     else:\n#         for i in g[p]:\n#             if not v[i]:\n#                 q.append((i , cnt/c , h+1))\n#                 v[i] = 1\n#     print(q,ans , p, cnt , h)\n# print('%.14f'%(ans))\n# #probability of the horse taking the route to each of the child of the parent * length of the journey = expected value for that vertex\n\n\n\n\n# def ok(p , s):\n#     cnt , need =0 , 0\n#     for i in s:\n#         if p[need] == i:\n#             cnt+=1 ; need ^= 1\n#     if cnt % 2 and p[0] != p[1]:\n#         cnt-=1\n#     return cnt\n\n# for _ in range(int(input())):\n#     s = input().rstrip('\\n') ; n , ans = len(s) , maxx\n#     for i in range(10):\n#         for j in range(10):\n#             ans = min(ans , n - ok((str(i) , str(j)), s))\n#     print(ans)\n#This problem was so easy oh gawd , so you can only make left cyclic shift = right cyclic shift , when there are at most\n#2 characters\n#(incase of 1 ch) at the same time if total string has only character it is valid no matter how you see it \n#(incase of 2 ch) all the characters at odd positions must be equal , and all the characters at even position must be equal\n\n\n\n\n\n# n , k = map(int , input().split()) ; s = input().rstrip('\\n')\n# ans = a = b = j = 0\n# for i in range(n):\n#     a , b = (a+1 , b) if s[i] == 'a' else (a , b+1 )\n#     if min(a, b) > k :\n#         a , b = (a -1 , b) if s[j] == 'a' else (a , b -1) ; j+=1\n#     else:\n#         ans+=1\n# print(ans)\n# #two - pointer method , if at any point min(a , b )> k then keep on decreasing from the beginning untill and unless you get min(a , b) \n# #less than k", "complexity": "quadratic"}
{"src": "def read():\n    return int(input())\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\ndef readmap():\n    return map(int, input().split())\n\n\nN, A, B = readmap()\n\nif N == 1:\n    print(\"YES\")\n    print(0)\n\nelif N == 2:\n    if A == 1 and B == 2:\n        print(\"YES\")\n        print(\"01\")\n        print(\"10\")\n    elif A == 2 and B == 1:\n        print(\"YES\")\n        print(\"00\")\n        print(\"00\")\n    else:\n        print(\"NO\")\n\nelif N == 3:\n    if A == 1 and B == 2:\n        print(\"YES\")\n        print(\"011\")\n        print(\"100\")\n        print(\"100\")\n    elif A == 2 and B == 1:\n        print(\"YES\")\n        print(\"001\")\n        print(\"000\")\n        print(\"100\")\n    elif A == 1 and B == 3:\n        print(\"YES\")\n        print(\"011\")\n        print(\"101\")\n        print(\"110\")\n    elif A == 3 and B == 1:\n        print(\"YES\")\n        print(\"000\")\n        print(\"000\")\n        print(\"000\")\n    else:\n        print(\"NO\")\n\nelse:\n    if A != 1 and B != 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if B == 1 and A != 1:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= A:\n                            vec.append(1)\n                        else:\n                            vec.append(0)\n                    mat.append(vec)\n                else:\n                    vec = [0] * N\n                    if i >= A:\n                        vec[0] = 1\n                    mat.append(vec)\n\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n        elif A == 1 and B != 1:\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= B:\n                            vec.append(0)\n                        else:\n                            vec.append(1)\n                    vec[i] = 0\n                    mat.append(vec)\n                else:\n                    vec = [1] * N\n                    if i >= B:\n                        vec[0] = 0\n                    vec[i] = 0\n                    mat.append(vec)\n\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n        else:  # A == 1 and B == 1\n            mat = []\n            for i in range(N):\n                vec = []\n                if i == 0:\n                    for j in range(N):\n                        if j >= 2:\n                            vec.append(1)\n                        else:\n                            vec.append(0)\n                    mat.append(vec)\n                else:\n                    vec = [0] * N\n                    if i >= 2:\n                        vec[0] = 1\n                    mat.append(vec)\n\n            mat[1][2] = 1\n            mat[2][1] = 1\n            for n in range(N):\n                print(\"\".join(list(map(str, mat[n]))))\n", "complexity": "quadratic"}
{"src": "n, a, b = map(int, input().split())\nif min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))): \n    print(\"NO\")\n    exit()\nres = [[0] * n for _ in range(n)]\nfor i in range(0, n - max(a, b)):\n    res[i][i + 1] = res[i + 1][i] = 1\nif a == 1:\n    res = [[e ^ 1 for e in l] for l in res]\n\nprint(\"YES\")\nfor i in range(n):\n    res[i][i] = 0\n    print(*res[i], sep='')", "complexity": "quadratic"}
{"src": "n, a, b = map(int, input().strip().split())\n\nif min(a, b) > 1:\n    print('NO')\n    exit(0)\n\nM = [[0] * n for _ in range(n)]\n\nif a == 1 and b == 1:\n    if n == 1:\n        print('YES')\n        print('0')\n        exit(0)\n    if n == 2 or n == 3:\n        print('NO')\n        exit(0)    \n    for i in range(1, n):\n        M[i - 1][i] = 1\n        M[i][i - 1] = 1    \nelse:\n    # assume b == 1\n    s = n - max(a, b) + 1\n    for i in range(s):\n        for j in range(s):\n            if i != j:\n                M[i][j] = 1\n    if a == 1:\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    M[i][j] = 1 - M[i][j]\n\nprint('YES')\nfor i in range(n):\n    print(''.join(map(str, M[i])))", "complexity": "quadratic"}
{"src": "n,k=[int(x) for x in input().split()]\nlst1=[int(x) for x in input().split()]\nlst2=[int(x) for x in input().split()]\nlst3={}\nans=[]\nfor i in lst2:\n    if(i in lst1):\n        \n        lst3[i]=lst1.index(i)\nfor i in sorted(lst3,key=lst3.get):\n    ans.append(i)\n#print(lst3)\nprint(*ans,sep=\" \")\n", "complexity": "quadratic"}
{"src": "import sys\ninput = sys.stdin.readline\n\n'''\n\n'''\n\nn = int(input())\na = list(map(int, input().split()))\nswaps = 0\nfor i in range(0, 2*n, 2):\n    if a[i] == a[i+1]:\n        continue\n    \n    c = a[i]\n    j = i + 2\n    while c != a[j]:\n        j += 1\n    \n    MIN = i+1\n    while j > MIN:\n        a[j], a[j-1] = a[j-1], a[j]\n        j -= 1\n        swaps += 1\n\nprint(swaps)\n", "complexity": "quadratic"}
{"src": "def mp():return map(int,input().split())\ndef it():return int(input())\n\nn,k=mp()\nl=list(mp())\nans=0\nfor i in range(n):\n\tavg,count=0,0\n\tfor j in range(i,n):\n\t\tcount+=l[j]\n\t\tif j-i+1>=k:\n\t\t\tavg=count/(j-i+1)\n\t\tans=max(avg,ans)\nprint(ans)\n", "complexity": "quadratic"}
{"src": "def main():\n    n,k=map(int,input().split( ))\n    a=list(map(int,input().split( )))\n    ans=-1*10**9+7\n    for i in range(n):\n        s=0\n        for j in range(i,n):\n            s+=a[j]\n            if j-i+1>=k:\n\n                ans=max(ans,s/(j-i+1))\n    print(ans)\n\n    \nmain()", "complexity": "quadratic"}
{"src": "from collections import Counter\nimport string\nimport math\nimport sys\n# sys.setrecursionlimit(10**6) \nfrom fractions import Fraction\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\ndef vary(arrber_of_variables):\n    if arrber_of_variables==1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables>=2:\n        return map(int,sys.stdin.readline().split()) \ndef makedict(var):\n    return dict(Counter(var))\ntestcases=1\nfor _ in range(testcases):\n    n,k=vary(2)\n    num=array_int()\n    maxi=0.0\n    for i in range(n):\n        count=1\n        sumt=num[i]\n        # print(sumt)\n        for j in range(i+1,n):\n            sumt+=num[j]\n            count+=1\n            if count>=k:\n                # print(sumt,sumt/count)\n                maxi=max(maxi,sumt/count)\n        # print(maxi)\n    if k==1:\n        print(max(maxi,max(num)))\n    else:\n        print(maxi)\n    \n\n\n\n", "complexity": "quadratic"}
{"src": "n,m=map(int,input().split())\nlst=list(map(int,input().split()))\nmaxx=0\narr=[0]*(n+1)\nfor i in range(n):\n    summ=0\n    for j in range(i,n):\n        summ+=lst[j]\n        arr[j-i]=max(arr[j-i], summ/(j-i+1))\nprint(max(arr[m-1:]))", "complexity": "quadratic"}
{"src": "from sys import stdin,stdout,setrecursionlimit\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush,nlargest\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm , accumulate\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nsetrecursionlimit(10**9)\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n# from sys import stdin\n# input = stdin.readline\n#def data(): return sys.stdin.readline().strip()\ndef data(): return input()\ndef num():return int(input())\ndef L(): return list(sp())\ndef LF(): return list(spf())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef spf(): return map(int, input.readline().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef pmat(A):\n    for ele in A:\n        print(*ele,end=\"\\n\")\ndef pmat2(A):\n    for ele in A:\n        for j in ele:\n            print(j,end='')\n        print()\ndef iseven(n):\n    return n%2==0\n\ndef seive(r):\n    prime=[1 for i in range(r+1)]\n    prime[0]=0\n    prime[1]=0\n    for i in range(r+1):\n        if(prime[i]):\n            for j in range(2*i,r+1,i):\n                prime[j]=0\n    return prime\n#solution\n#ACPC \n#remeber cut ribbon problem\n# set data structures faster than binary search sometimes\n#bipartite match dfs\n#think in problems with recursive manner.\nn = int(input())\ns = list(input())\nt = list(input())\nans = []\nfor i in range(n):\n    for j in range(i,n):\n        if s[j] == t[i]:\n            for k in range(j, i, -1):\n                s[k], s[k-1] = s[k-1], s[k]\n                ans.append(k)\n            break\nif s==t:\n    print(len(ans))\n    print(' '.join(map(str, ans)))\nelse:\n    print(-1)\n\n\n\n\nendtime = time.time()\n#print(f\"Runtime of the program is {endtime - starttime}\")", "complexity": "quadratic"}
{"src": "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef main():\n\tn, m = mints()\n\tres = []\n\ta = [None]*n\n\tl = [None]*n\n\tr = [None]*n\n\ts = [0]*n\n\tfor i in range(n):\n\t\ta[i] = list(minp())\n\t\tl[i] = [i for i in range(m)]\n\t\tr[i] = [i for i in range(m)]\n\t\ts[i] = [0]*m\n\tfor i in range(n):\n\t\tj = 0\n\t\tb = a[i]\n\t\tll = l[i]\n\t\trr = r[i]\n\t\twhile j < m:\n\t\t\tif b[j] == '*':\n\t\t\t\tjj = j+1\n\t\t\t\twhile jj < m and b[jj] == '*':\n\t\t\t\t\tjj += 1\n\t\t\t\tjj -= 1\n\t\t\t\tfor k in range(j,jj+1):\n\t\t\t\t\tll[k] = j\n\t\t\t\t\trr[k] = jj\n\t\t\t\tj = jj + 1\n\t\t\telse:\n\t\t\t\tj += 1\n\tfor i in range(m):\n\t\tj = 0\n\t\twhile j < n:\n\t\t\tif a[j][i] == '*':\n\t\t\t\tjj = j+1\n\t\t\t\twhile jj < n and a[jj][i] == '*':\n\t\t\t\t\tjj += 1\n\t\t\t\tjj -= 1\n\t\t\t\tfor k in range(j,jj+1):\n\t\t\t\t\tx = min(i-l[k][i],r[k][i]-i,k-j,jj-k)\n\t\t\t\t\ts[k][i] = x\n\t\t\t\t\tif x > 0:\n\t\t\t\t\t\tres.append((k+1,i+1,x))\n\t\t\t\tj = jj + 1\n\t\t\telse:\n\t\t\t\tj += 1\n\tfor i in range(n):\n\t\tj = 0\n\t\tss = s[i]\n\t\trr = r[i]\n\t\tc = -1\n\t\twhile j < m:\n\t\t\tif ss[j] > 0 and c < ss[j]:\n\t\t\t\tc = ss[j]\n\t\t\tif c >= 0:\n\t\t\t\trr[j] = '*'\n\t\t\telse:\n\t\t\t\trr[j] = '.'\n\t\t\tj += 1\n\t\t\tc -= 1\n\t\tj = m-1\n\t\tc = -1\n\t\twhile j >=0:\n\t\t\tif ss[j] > 0 and c < ss[j]:\n\t\t\t\tc = ss[j]\n\t\t\tif c >= 0:\n\t\t\t\trr[j] = '*'\n\t\t\tc -= 1\n\t\t\tj -= 1\n\tfor i in range(m):\n\t\tj = 0\n\t\tc = -1\n\t\twhile j < n:\n\t\t\tx = s[j][i]\n\t\t\tif x > 0 and c < x:\n\t\t\t\tc = x\n\t\t\tif c >= 0:\n\t\t\t\tr[j][i] = '*'\n\t\t\tj += 1\n\t\t\tc -= 1\n\t\tj = n-1\n\t\tc = -1\n\t\twhile j >=0:\n\t\t\tx = s[j][i]\n\t\t\tif x > 0 and c < x:\n\t\t\t\tc = x\n\t\t\tif c >= 0:\n\t\t\t\tr[j][i] = '*'\n\t\t\tif r[j][i] != a[j][i]:\n\t\t\t\tprint(-1)\n\t\t\t\texit(0)\n\t\t\tc -= 1\n\t\t\tj -= 1\n\tprint(len(res))\n\tfor i in res:\n\t\tprint(*i)\nmain()", "complexity": "quadratic"}
{"src": "import sys\nfrom array import array  # noqa: F401\n\n\ndef readline(): return sys.stdin.buffer.readline().decode('utf-8')\n\n\nn, k = map(int, readline().split())\nmod = 998244353\n\nif k == 1:\n    print(0)\n    exit()\n\n\ndp1 = [array('i', [0])*n for _ in range(n)]\ndp2 = [array('i', [0])*n for _ in range(n)]\ndp1[0][0] = 1\n\nfor i in range(n-1):\n    for j in range(i+1):\n        for l in range(j+1):\n            dp2[j][0] += dp1[j][l]\n            if dp2[j][0] >= mod:\n                dp2[j][0] -= mod\n\n            dp2[j+1 if j == l else j][l+1] += dp1[j][l]\n            if dp2[j+1 if j == l else j][l+1] >= mod:\n                dp2[j+1 if j == l else j][l+1] -= mod\n\n            dp1[j][l] = 0\n\n    dp1, dp2 = dp2, dp1\n\nans = 0\nfor i in range(1, n+1):\n    t = (k-1) // i\n    if t == 0:\n        break\n\n    dps1 = array('i', [0])*(t+1)\n    dps2 = array('i', [0])*(t+1)\n    dps1[0] = 1\n\n    for j in range(n-1):\n        for l in range(min(j+1, t)):\n            dps2[0] += dps1[l]\n            if dps2[0] >= mod:\n                dps2[0] -= mod\n\n            dps2[l+1] += dps1[l]\n            if dps2[l+1] >= mod:\n                dps2[l+1] -= mod\n\n            dps1[l] = 0\n\n        dps1, dps2 = dps2, dps1\n\n    x = sum(dp1[i-1]) % mod\n    ans = (ans + x * sum(dps1[:-1])) % mod\n\nprint(ans * 2 % mod)\n", "complexity": "quadratic"}
{"src": "n,k=map(int,input().split())\ns=input();flag=True;lenn=10**10;ans=0\nfor i in range(n):\n  s1=s+s[n-i-1:]*(k-1);cnt=0\n  for i in range(len(s1)-len(s)+1):\n     if s1[i:i+len(s)]==s:cnt+=1\n  if cnt==k and len(s1)<lenn:ans=s1;lenn=len(s1)\nprint(ans)\n", "complexity": "quadratic"}
{"src": "\ndef solve():\n    n, k = [int(x) for x in input().split(' ')]\n    t = input()\n    j = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            j = i\n    s = t + (k - 1) * t[-(n - j):]\n    return s\n \nprint(solve())", "complexity": "quadratic"}
{"src": "n, k = map(int, input().split())\ns = input()\n# fail = [-1] * len(s)\n# for i in range(1, len(s)):\n#     j = fail[i - 1]\n#     while j != -1 and s[i - 1] != s[j]:\n#         j = fail[j]\n#     fail[i] = j + 1\n# # print(fail)\n# l = fail[-1]\n# print(s + s[l:] * (k - 1))\nfor i in range(1, n):\n    if s[:n - i] == s[i:]:\n        print(s + s[n - i:] * (k - 1))\n        exit()\nprint(s * k)\n", "complexity": "quadratic"}
{"src": "n = int(input())\na = list(input())\nsmm = 0\nfor i in range(n):\n    a[i] = int(a[i])\n    smm += a[i]\nans = \"NO\"\nsm = smm\nfor div in range(2, n + 1):\n    sm = smm\n    if not sm % div:\n        sm //= div\n        f = 0\n        s = 0\n        for i in range(n):\n            s += a[i]\n            if s == sm:\n                s = 0\n                f += 1\n        if f == div:\n            ans = \"YES\"\n            break\nprint(ans)\n", "complexity": "quadratic"}
{"src": "# https://codeforces.com/problemset/problem/1030/C\n\nimport sys\n\nlines = sys.stdin.readlines()\n\n\ndef read_a_num(line):\n    n = int(line.strip())\n    return n\n\n\ndef read_a_str(line):\n    line = line.strip()\n    return line\n\n\ndef check_ticket(digits):\n    for target in range(900):\n        seg_i = 0\n        seg_sum = 0\n        next_flag = False\n        for d in digits:\n            int_d = int(d)\n            if int_d > target:\n                next_flag = True\n                break\n            elif seg_sum + int_d > target:\n                if next_flag:\n                    break\n                next_flag = True\n                continue\n            elif int_d == target or seg_sum + int_d == target:\n                seg_i += 1\n                seg_sum = 0\n            else:\n                seg_sum += int_d\n\n        if next_flag:\n            continue\n\n        if seg_i >= 2 and seg_sum == 0:\n            return True\n\n    return False\n\n\ndigits = read_a_str(lines[1])\nif check_ticket(digits):\n    print(\"yes\")\nelse:\n    print(\"no\")\n", "complexity": "quadratic"}
{"src": "import sys,math,bisect\nfrom random import randint\ninf = float('inf')\nmod = 998244353\n\"========================================\"\ndef lcm(a,b):\n    return int((a/math.gcd(a,b))*b)\ndef gcd(a,b):\n    return int(math.gcd(a,b))\ndef tobinary(n):\n    return bin(n)[2:]\ndef binarySearch(a,x):\n    i = bisect.bisect_left(a,x)\n    if i!=len(a) and a[i]==x:\n        return i\n    else:\n        return -1\ndef lowerBound(a, x):\n    i = bisect.bisect_left(a, x)\n    if i:\n        return (i-1)\n    else:\n        return -1\ndef upperBound(a,x):\n    i = bisect.bisect_right(a,x)\n    if i!= len(a)+1 and a[i-1]==x:\n        return (i-1)\n    else:\n        return -1\ndef primesInRange(n):\n    ans = []\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n+1):\n        if prime[p]:\n            ans.append(p)\n    return ans\ndef primeFactors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors\ndef isPrime(n,k=5):\n    if (n <2):\n        return True\n    for i in range(0,k):\n        a = randint(1,n-1)\n        if(pow(a,n-1,n)!=1):\n            return False\n    return True\n\"=========================================\"\n\"\"\"\nn = int(input())\nn,k = map(int,input().split())\narr = list(map(int,input().split()))\n\"\"\"\nfrom collections import deque,defaultdict,Counter\nimport heapq,string\n\n\nn=int(input())\ns=input()\ns=[int(i) for i in s]\nflag=False\nfor i in range(0,(9*n)+1):\n    count=0\n    sum = 0\n    for j in s:\n        sum+=j\n        if sum==i:\n            count+=1\n            sum=0\n    if count>1 and sum==0:\n        print('YES')\n        exit(0)\nprint('NO')\n", "complexity": "quadratic"}
{"src": "n=int(input())\nL=list(map(int,input().split()))\nans=['']*n\nrevL=[0]*n\nans[-1]='B'\nfor i in range(n):\n    revL[L[i]-1]=i+1\nfor i in range(n-2,-1,-1):\n    t=revL[i]-1\n    counter='B'\n    for j in range(t,-1,-i-1):\n        if j==t:continue\n        if ans[L[j]-1]=='B':\n            counter='A'\n            break\n    if counter!='A':\n        for k in range(t,n,i+1):\n            if k==t:continue\n            if ans[L[k]-1]=='B':\n                counter='A'\n                break\n    ans[i]=counter\nfor i in range(n):\n    print(ans[L[i]-1],sep='',end='')", "complexity": "quadratic"}
{"src": "n=int(input())\na=[*map(int,input().split())]\nb=[0]*n\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))", "complexity": "quadratic"}
{"src": "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nzl = getIntList()\nzr = getIntList()\n\nzt = [ (zl[i] + zr[i], i) for i in range(N) ]\nzt.sort()\nza = [0 for i in range(N) ]\nnow = N\nfor i in range(N):\n    if i>0 and zt[i-1][0] <zt[i][0]:\n        now-=1\n    za[ zt[i][1] ] = now\n\nfor i in range(N):\n    l = 0\n    r = 0\n    for j in range(i):\n        if za[j] > za[i]:\n            l+=1\n    for j in range(i+1, N):\n        if za[j] > za[i]:\n            r+=1\n    if zl[i] != l or zr[i] != r:\n        print('NO')\n        sys.exit()\nprint('YES')\nfor i in range(N):\n    print(za[i],end = ' ')\n\n\n\n\n", "complexity": "quadratic"}
{"src": "n = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nans = [1 for i in range(n)]\n\ns = [l[i] + r[i] for i in range(n)]\norder = [i for i in range(n)]\n\nfor i in range(n-1):\n    m = i\n    for j in range(i+1,n):\n        if s[m] < s[j]:\n            m = j\n    t = s[i]\n    s[i] = s[m]\n    s[m] = t\n    t = order[i]\n    order[i] = order[m]\n    order[m] = t\ncur = 1\nfor i in range(1,n):\n    if s[i-1] > s[i]:\n        cur += 1\n    ans[order[i]] = cur\nfor i in range(n):\n    k = 0\n    for j in range(i):\n        if ans[j] > ans[i]:\n            k += 1\n    if l[i] != k:\n        print('NO')\n        exit()\n    k = 0\n    for j in range(i+1,n):\n        if ans[j] > ans[i]:\n            k += 1\n    if r[i] != k:\n        print('NO')\n        exit()\n\nprint('YES')\nfor i in ans:\n    print(i, end=' ')", "complexity": "quadratic"}
{"src": "import sys\nn = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\nres = [0] * n\nfor i in range(n):\n    res[i] = n - l[i] - r[i]\nfor i in range(n):\n    ok = 0\n    for j in range(i):\n        if res[j] > res[i]:\n            ok += 1\n    if ok != l[i]:\n        print(\"NO\")\n        sys.exit(0)\n    ok = 0\n    for j in range(i + 1, n):\n        if res[j] > res[i]:\n            ok += 1\n    if ok != r[i]:\n        print(\"NO\")\n        sys.exit(0)\nprint(\"YES\")\nprint(' '.join(map(str, res)))\n", "complexity": "quadratic"}
{"src": "import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n\treturn list(map(int , input().split()))\n\ndef num():\n\treturn map(int , input().split())\n\ndef nu():\n\treturn int(input())\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\n\nn=nu()\na=li()\nb=li()\nz=[]\nfor i in range(n):\n\tz.append((a[i]+b[i],i))\nz.sort()\nfl=True\nx=[]\ncc=0\nxp=0\nmp={}\nnp=[]\nfor i in range(n):\n\tif(a[i]>i):\n\t\tfl=False\n\tif(b[i]>(n-i-1)):\n\t\tfl=False\n\tif((n-a[i]-b[i])<=0):\n\t\tfl=False\n\nif(fl==False):\n\tprint(\"NO\")\nelse:\n\tzz=[0]*n\n\tfor i in range(n):\n\t\tzz[i]=(n-a[i]-b[i])\n\tfor i in range(n):\n\t\txl = 0\n\t\txr = 0\n\t\tfor j in range(i + 1 , n):\n\t\t\tif (zz[j] > zz[i]):\n\t\t\t\txr += 1\n\t\tfor j in range(i - 1 , -1 , -1):\n\t\t\tif (zz[j] > zz[i]):\n\t\t\t\txl += 1\n\t\tif (xl != a[i] or xr != b[i]):\n\t\t\tfl = False\n\t\t\tbreak\n\tif (fl == True):\n\t\tprint(\"YES\")\n\t\tprint(*zz)\n\telse:\n\t\tprint(\"NO\")\n", "complexity": "quadratic"}
{"src": "n=int(input())\nif n==1:\n    print(1)\nelse:\n    p=list(map(int,input().split()))\n    children=[]\n    for i in range(n):\n        children.append([])\n    for i in range(n-1):\n        children[p[i]-1].append(i+1)\n    layers=[1]+[0]*(n-1)\n    layer=[0]\n    num=2\n    bylayer=[]\n    while len(layer)>0:\n        bylayer.append(layer)\n        newlayer=[]\n        for vert in layer:\n            for child in children[vert]:\n                layers[child]=num\n                newlayer.append(child)\n        layer=newlayer\n        num+=1\n    bylayer=bylayer[::-1]\n    count=[0]*n\n    for layer in bylayer:\n        for vert in layer:\n            if children[vert]==[]:\n                count[vert]=1\n            else:\n                count[vert]=sum(count[v] for v in children[vert])\n    count.sort()\n    out=\"\"\n    for guy in count:\n        out+=str(guy)+\" \"\n    print(out)", "complexity": "quadratic"}
{"src": "import sys\nimport threading\ninp = sys.stdin.buffer.readline      \ninput = lambda: sys.stdin.readline().rstrip()\ndef I(): return list(map(int,inp().split()))\ndef main():\n    n,=I() ; vis=[0]*n ; st=[0]*n\n    if n==1:\n        print(1)\n        exit(0)\n    def dfs(g,e):\n        if vis[e]==1: return\n        else: \n            vis[e]=1\n            for i in g[e]:\n                dfs(g,i)\n            if len(g[e])==1 and e!=0: st[e]+=1\n            for i in g[e]:\n                st[e]+=st[i]\n    a=[int(i)-1 for i in input().split()]\n    g=[[] for i in range(n)]\n    for i in range(n-1):\n        g[i+1].append(a[i])\n        g[a[i]].append(i+1)\n    dfs(g,0)\n    st.sort()\n    print(*st)\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "complexity": "quadratic"}
{"src": "#!/usr/bin/python3\n\nimport math\nimport sys\n\n\nDEBUG = False\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(H, W, A):\n    visited = [bytearray(W) for _ in range(H)]\n\n    for y in range(H):\n        for x in range(W):\n            if A[y][x] == '.' or visited[y][x]:\n                continue\n\n            dprint(x, y)\n            for dx, dy in [(0, 0), (-1, 0), (-2, 0),\n                           (0, -1), (-2, -1),\n                           (0, -2), (-1, -2), (-2, -2)]:\n                tx = x + dx\n                ty = y + dy\n                dprint('  ', tx, ty)\n                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:\n                    continue\n                bad = False\n                for ex, ey in [(0, 0), (1, 0), (2, 0),\n                               (0, 1), (2, 1),\n                               (0, 2), (1, 2), (2, 2)]:\n                    nx = tx + ex\n                    ny = ty + ey\n                    if A[ny][nx] == '.':\n                        bad = True\n                        break\n                if bad:\n                    continue\n\n                for ex, ey in [(0, 0), (1, 0), (2, 0),\n                               (0, 1), (2, 1),\n                               (0, 2), (1, 2), (2, 2)]:\n                    nx = tx + ex\n                    ny = ty + ey\n                    visited[ny][nx] = 1\n\n                assert visited[ny][nx] == 1\n                break\n\n            if visited[y][x] == 0:\n                return False\n\n    return True\n\n\ndef main():\n    H, W = [int(e) for e in inp().split()]\n    A = [inp() for _ in range(H)]\n\n    print('YES' if solve(H, W, A) else 'NO')\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "quadratic"}
{"src": "\nN, M = map(int, input().split())\n\n\ngrid = []\nfor _ in range(N):\n    grid.append(list(input()))\n\ndef check(grid, i, j, sx, sy):\n    if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M:\n        i -= sx\n        j -= sy\n        v = grid[i][j] == '#' and grid[i+1][j] == '#' and grid[i+2][j] == '#' and grid[i][j+1] == '#' and grid[i+2][j+1] == '#' and grid[i][j+2] == '#' and grid[i+1][j+2] == '#' and grid[i+2][j+2] == '#'\n        return v\n\n    return False\n\n\n\nprev = False\nfor m in range(M):\n    for n in range(N):\n        if grid[n][m] == '#':\n            if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)):\n                print(\"NO\")\n                exit(0)\n\nprint(\"YES\")\n", "complexity": "quadratic"}
{"src": "n,m=map(int,raw_input().split())\n\nl=[]\nfor i in range(n):\n\ts=raw_input()\n\tl.append([])\n\tfor j in range(m):\n\t\tl[-1].append(s[j])\n\nans=[]\nfor i in range(n):\n\n\tans.append([])\n\tfor j in range(m):\n\t\tans[-1].append(\".\")\n\nfor i in range(n-2):\n\tfor j in range(m-2):\n\t\tif l[i][j]==\"#\":\n\t\t\tif l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]:\n\t\t\t\tans[i][j]=\"#\"\n\t\t\t\tans[i][j+1]=\"#\"\n\t\t\t\tans[i][j+2]=\"#\"\n\t\t\t\tans[i+1][j]=\"#\"\n\t\t\t\tans[i+1][j+2]=\"#\"\n\t\t\t\tans[i+2][j]=\"#\"\n\t\t\t\tans[i+2][j+1]=\"#\"\n\t\t\t\tans[i+2][j+2]=\"#\"\n\nflag = True\nfor i in range(n):\n\tfor j in range(m):\n\t\tif l[i][j]!=ans[i][j]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag==False:\n\t\tbreak\n\nif flag==True:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n\n", "complexity": "quadratic"}
{"src": "n,m = map(int, input().split())\na = []\nfor i in range(n):\n    s = input()\n    a.append(s)\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == '.':\n            continue\n        if i >= 2 and j >= 2:\n            if a[i-2][j-2] == '#' and a[i-2][j-1] == '#' and a[i-2][j] == '#' \\\n                    and a[i-1][j] == '#' and a[i-1][j-2] == '#' and a[i][j-1] == '#' and a[i][j-2] == '#':\n                continue\n        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '#' and a[i-1][j-1] == '#' and a[i-1][j] == '#' \\\n                and a[i][j-2] == '#' and a[i+1][j-2] == '#' and a[i+1][j-1] == '#' and a[i+1][j] == '#':\n            continue\n        if i <= n-3 and j >= 2 and a[i][j-1] == '#' and a[i][j-2] == '#' and a[i+1][j] == '#' \\\n                and a[i+1][j-2] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j-2] == '#':\n            continue\n        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '#' and a[i][j+1] == '#' and a[i+1][j-1] == '#' \\\n                and a[i+1][j+1] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j+1] == '#':\n            continue\n        if i <= n-3 and j <= m-3 and a[i][j+1] == '#' and a[i][j+2] == '#' and a[i+1][j] == '#' \\\n                and a[i+1][j+2] == '#' and a[i+2][j] == '#' and a[i+2][j+1] == '#' and a[i+2][j+2] == '#':\n            continue\n        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j+2] == '#' \\\n                and a[i][j+2] == '#' and a[i+1][j] == '#' and a[i+1][j+1] == '#' and a[i+1][j+2] == '#':\n            continue\n        if i >= 2 and j <= m-3 and a[i-2][j] == '#' and a[i-2][j+1] == '#' and a[i-2][j+2] == '#' \\\n                and a[i-1][j] == '#' and a[i-1][j+2] == '#' and a[i][j+1] == '#' and a[i][j+2] == '#':\n            continue\n        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '#' and a[i-2][j] == '#' and a[i-2][j+1] == '#' \\\n                and a[i-1][j-1] == '#' and a[i-1][j+1] == '#' and a[i][j-1] == '#' and a[i][j+1] == '#':\n            continue\n        print('NO')\n        exit()\nprint('YES')", "complexity": "quadratic"}
{"src": "i = input()\ni = int(i)\nv = 0\ng = 2\ns = 4\nwhile g <= i:\n\twhile s <= i:\n\t\tv = v + int(s / g * 4)\n\t\ts = s + g\n\tg = g + 1\n\ts = g * 2\nprint(str(v))", "complexity": "quadratic"}
{"src": "def stones_after(n, s):\n\tfor i in s:\n\t\tif i == '-':\n\t\t\tn -= 1\n\t\telse:\n\t\t\tn += 1\n\t\tif n < 0:\n\t\t\treturn -1\n\treturn n\n\nn = int(input().strip())\ns = input().strip()\nans = 99999999\nfor i in range(n+1):\n\tstones = stones_after(i, s)\n\tif stones != -1:\n\t\tans = min(ans, stones)\nprint(ans)", "complexity": "quadratic"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom collections import defaultdict, deque\nimport random\n\n# to output - sys.stdout.write('{} {}\\n'.format(*a))\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# n, k = map(int, input().split(\" \"))\n# l = list(map(int, input().split(\" \")))\n\nn, k = map(int, input().split(\" \"))\nans = []\nfor i in range(1, n*k + 1):\n    if i%2:\n        x,y = divmod(i//2, k)\n        ans.append([x+1, y+1])\n    else:\n        x,y = divmod(n*k-i//2, k)\n        ans.append([x + 1, y + 1])\nfor i in ans:\n    sys.stdout.write('{} {}\\n'.format(*i))", "complexity": "quadratic"}
{"src": "import sys\ninput=sys.stdin.buffer.readline\nn,m=map(int,input().split())\nfor i in range(n//2+n%2):\n    x1=i+1\n    x2=n-i\n    if(x1==x2):\n        for j in range(m//2+m%2):\n            if(j+1==m-j):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n            else:\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n    else:\n        if(i%2==0):\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(j+1)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(m-j)+\"\\n\"))\n        else:\n            for j in range(m):\n                sys.stdout.write((str(x1)+\" \"+str(m-j)+\"\\n\"))\n                sys.stdout.write((str(x2)+\" \"+str(j+1)+\"\\n\"))", "complexity": "quadratic"}
{"src": "def main():\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        min_ans = 10 ** 9\n        for i in range(n - k + 1):\n            count1 = 0\n            count2 = 0\n            count3 = 0\n            for j in range(k):\n                if (i + j) % 3 == 0:\n                    if s[i + j] != \"R\":\n                        count1 += 1\n                    if s[i + j] != \"G\":\n                        count2 += 1\n                    if s[i + j] != \"B\":\n                        count3 += 1\n                if (i + j) % 3 == 1:\n                    if s[i + j] != \"G\":\n                        count1 += 1\n                    if s[i + j] != \"B\":\n                        count2 += 1\n                    if s[i + j] != \"R\":\n                        count3 += 1 \n                if (i + j) % 3 == 2:\n                    if s[i + j] != \"B\":\n                        count1 += 1\n                    if s[i + j] != \"R\":\n                        count2 += 1\n                    if s[i + j] != \"G\":\n                        count3 += 1 \n            min_ans = min(min_ans, count1, count2, count3)\n        print(min_ans)\nmain()", "complexity": "quadratic"}
{"src": "import sys\n\nn, m, k = list(map(int, sys.stdin.readline().strip().split()))\na = list(map(int, sys.stdin.readline().strip().split()))\nb = [0] * (n+1)\nfor i in range (1, n+1):\n    b[i] = b[i-1] + m * a[i-1] - k\nM = [10 ** 20] * m\nans = 0\nfor i in range (0, n+1):\n    M[i % m] = min([M[i % m], b[i]])\n    for j in range (0, m):\n        if i > j:\n            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])\n    # print(j, M, ans)\nprint(ans // m)\n", "complexity": "quadratic"}
{"src": "\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    aa = list(map(int,input().split()))\n    ans = 0\n    for start in range(m):\n        ac = aa[:]\n        for i in range(start, n, m):\n            ac[i] -= k\n        cur = 0\n        for i in range(start, n):\n            if i%m == start:\n                cur = max(ac[i] + cur, ac[i])\n            else:\n                cur += ac[i]\n            ans = max(cur, ans)\n    print(ans)\n", "complexity": "quadratic"}
{"src": "n=int(input())\na=[int(i) for i in input().split()]\na.sort()\ntot = 0\nd={}\nfor i in range(len(a)):\n    if a[i] not in d:\n        tot+=1\n        for j in range(i+1,len(a),1):\n            if a[j]%a[i] == 0:\n                d[a[j]]=1\nprint(tot)", "complexity": "quadratic"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nA.sort()\n\nANS=[0]*n\n\nNOW=1\nfor i in range(n):\n    if ANS[i]==0:\n        ANS[i]=NOW\n\n        for j in range(i,n):\n            if A[j]%A[i]==0 and ANS[j]==0:\n                ANS[j]=NOW\n\n        NOW+=1\n\nprint(max(ANS))\n", "complexity": "quadratic"}
{"src": "n=int(input())\na=sorted([int(x) for x in input().split()])\ncounter=0\ntest=[False]*n\nfor j in range(n):\n    if not test[j]:\n        for i in range(n):\n            if not test[i] and a[i]%a[j]==0:\n                test[i]=True\n        counter+=1\nprint(counter)\n            \n", "complexity": "quadratic"}
{"src": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nwhile len(a) > 0:\n    k = a.pop(0)\n    a = [i for i in a if i % k != 0]\n    ans += 1\n\nprint(ans)\n", "complexity": "quadratic"}
{"src": "import sys\nimport string\n\nfrom collections import Counter, defaultdict\nfrom math import fsum, sqrt, gcd, ceil, factorial\nfrom operator import *\nfrom itertools import accumulate, count\n\ninf = float(\"inf\")\n# input = sys.stdin.readline\nflush = lambda: sys.stdout.flush\ncomb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y)\n\n\n# inputs\n# ip = lambda : input().rstrip()\nip = lambda: input()\nii = lambda: int(input())\nr = lambda: map(int, input().split())\nrr = lambda: list(r())\n\n\narr = ip()\nn = len(arr)\nms = \"\"\nmn = 0\n\n\ndef counter(s, x):\n    p = len(x)\n    px = 0\n    for i in range(len(s)):\n        if s[i : i + p] == x:\n            px += 1\n\n    return px\n\n\nfor i in range(n):\n    s = \"\"\n    for j in range(i, n):\n        s += arr[j]\n        c = counter(arr, s)\n        if c > 1 and len(s) > mn:\n            ms = s\n            mn = len(s)\n\nprint(mn)", "complexity": "cubic"}
{"src": "line = input()\nn = len(line)\ntemp = [0]\nfor i in range(1, n):\n    for j in range(n-i):\n        for k in range(1, n-i-j+1):\n            # print(line[j:j+i+1])\n            # print(line[j+k:j+k+i+1])\n            if line[j:j+i] == line[j+k:j+k+i]:\n                temp.append(i)\nprint(max(temp))", "complexity": "cubic"}
{"src": "t = input()\n\nn = len(t)\n\nmaxi = 0\n\nfor i in range(n):\n    s = t[i]\n    if t.count(s) > 1:\n        maxi = max(maxi, 1)\n    nr = 1\n    for j in range(i + 1, n):\n        s += t[j]\n        nr += 1\n        g = 0\n        for h in range(n - nr + 1):\n            if s == t[h:h + nr]:\n                g += 1\n        if g > 1:\n            maxi = max(nr,maxi)\n\nprint(maxi)", "complexity": "cubic"}
{"src": "from sys import stdin\ns=stdin.readline()\nfor ln in range(len(s),0,-1):\n    for L in range(len(s)-ln+1):\n        if s[L:L+ln] in s[L+1:]:\n            print(ln)\n            exit()\nprint(0)", "complexity": "cubic"}
{"src": "a=input()\nn=len(a)\nfor l in range(n,0,-1):\n  for i in range(n-l+1):\n    if a[i:i+l] in a[i+1:]:\n      print(l)\n      exit(0)\nprint(0)", "complexity": "cubic"}
{"src": "from queue import Queue\nimport datetime\n\nwith open(\"input.txt\", 'r') as in_file:\n    n, m = (int(i) for i in in_file.readline().split(\" \"))\n    k = int(in_file.readline())\n    ints = [int(i) for i in in_file.readline().split(\" \")]\n\npairs = []\nfor i in range(0, len(ints), 2):\n    x = ints[i]\n    y = ints[i+1]\n    pairs.append((x, y))\n\n# calc = datetime.datetime.now()\nlast_tree = (1, 1)\nmaxd = 0\nmult = m * n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        md = mult\n        # print(\"par\", i, j)\n        for pair in pairs:\n            x, y = pair\n            d = abs(i-x)+abs(j-y)\n            # print(\"punto\", x, y)\n            # print(\"distancia\", d)\n            md = min(md, d)\n            # print(\"min\", md)\n        if md > maxd:\n            # print(\"max\", md)\n            last_tree = (i, j)\n            maxd = md\n        # print(\"\")\n\n# dif_calc = datetime.datetime.now() - calc\n# print(\"calcular\", dif_calc)\n# print(\"res\", last_tree)\nwith open(\"output.txt\", 'w') as out_file:\n    out_file.write(f\"{last_tree[0]} {last_tree[1]}\")\n", "complexity": "cubic"}
{"src": "# https://codeforces.com/problemset/problem/35/C\n\nfrom sys import stdin, exit\nfrom typing import List, Tuple, Dict\nfrom itertools import product\n\n\ndef distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):\n    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])\n\n\ndef shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):\n    shorthest_path = float('inf')\n    for outbreak in outbreaks:\n        if shorthest_path < min_dst:\n            break\n        shorthest_path = min(shorthest_path, distance(tree, outbreak))\n    return shorthest_path\n\n\ninput_f = open('input.txt', 'r')\noutput_f = open('output.txt', 'w')\n\nN, M = [int(v) for v in input_f.readline().rstrip().split()]\ninput_f.readline()  # ignore\noutbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]\noutbreaks = []\ninput_f.close()\n\n\nfor i in range(0, len(outbreaks_line) - 1, 2):\n    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))\n\nlast_tree = (1, 1)\nbest_dst = 0\nfor x, y in product(range(1, N + 1), range(1, M + 1)):\n    path_len = shorthest_path((x, y), outbreaks, best_dst)\n    if path_len > best_dst:\n        last_tree = (x, y)\n        best_dst = path_len\n\noutput_f.write(' '.join(map(str, last_tree)))\n# print(' '.join(map(str, last_tree)))\n\noutput_f.close()\n", "complexity": "cubic"}
{"src": "import math\nfrom collections import defaultdict\n\n\ndef main():\n    n, k = map(int, input().split())\n    cards = list(map(int, input().split()))\n    fav = list(map(int, input().split()))\n\n    h = [0] + list(map(int, input().split()))\n\n    cards_cnt = defaultdict(int)\n    for val in cards:\n        cards_cnt[val] += 1\n\n    players_fav_cnt = defaultdict(int)\n    for val in fav:\n        players_fav_cnt[val] += 1\n\n    # dp[a][b] - a players, b favourite cards (in total)\n    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]\n    for p in range(n):\n        for c in range(k*n+1):\n            for hand in range(k+1):\n                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])\n\n    res = 0\n    for f in players_fav_cnt:\n        res += dp[players_fav_cnt[f]][cards_cnt[f]]\n\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "cubic"}
{"src": "def solve():\n    n, k = map(int, input().split())\n    c = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    cnt = {}\n    for i in c:\n        cnt[i] = cnt.get(i, 0) + 1\n    likecolor = {}\n    for i in range(n):\n        likecolor.setdefault(f[i], []).append(i)\n        cnt[f[i]] = cnt.get(f[i], 0)\n    ans = 0\n    for key, v in likecolor.items():\n        n1 = len(v)\n        if cnt[key] >= n1 * k:\n            ans += n1 * h[k - 1]\n            continue\n        dp = [[-float(\"INF\")] * (cnt[key]+1) for _ in range(n1 + 1)]\n        dp[0][0] = 0\n        for i in range(n1):\n            j = i + 1\n            for e in range(cnt[key] + 1):\n                dp[j][e] = max(dp[j][e], dp[i][e])\n                for w in range(e + 1, min(cnt[key] + 1, e + k + 1)):\n                    dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w])\n        ans += dp[n1][cnt[key]]\n    print(ans)\n\n\nsolve()\n", "complexity": "cubic"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\n# ------------------------------\n# f = open('./input.txt')\n# sys.stdin = f\n\ndef main():\n    n, k = RL()\n    cds = RLL()\n    fn = RLL()\n    sc = [0]+RLL()\n\n    rec = set(fn)\n    uses = 0\n    dic = defaultdict(int)\n    for i in cds:\n        if i in rec:\n            dic[i]+=1\n            uses+=1\n\n    dp = [[0]*(n*k+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n*k+1):\n            for l in range(k+1):\n                if l>j: break\n                val = sc[l]\n                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)\n    res = 0\n\n    for i, v in Counter(fn).items():\n        res+=dp[v][dic[i]]\n    # for i in dp: print(i)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n\n", "complexity": "cubic"}
{"src": "T = int(input())\nfor ti in range(T):\n    s, t = input().strip(), input().strip()\n    N = len(t)\n    for i in range(1, N+1):\n        dp = [0]+[-1]*i\n        for l, c in enumerate(s):\n            for j in range(i, -1, -1):\n                tmp = dp[j]\n                if dp[j] != -1 and i + dp[j] < N and \\\n                   t[i + dp[j]] == c:\n                    tmp = dp[j] + 1\n                if j != 0 and t[j-1] == c:\n                    tmp = max(tmp, dp[j-1])\n                dp[j] = tmp\n        if dp[i] == N-i:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n\n", "complexity": "cubic"}
{"src": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO,IOBase\n\ndef main():\n    n = int(input())\n    a = [0]+list(map(int,input().split()))\n    dp = [[[-1,-1,-1] for _ in range(n+1)]for _ in range(n+1)]\n    ## left right length\n    for i in range(1,n+1):\n        dp[i][i] = (a[i],a[i],1)\n    for i in range(n-1,0,-1):\n        for j in range(i+1,n+1):\n            mini = 10**10\n            for k in range(j-i):\n                x = dp[i][i+k][2]+dp[i+k+1][j][2]\n                if dp[i][i+k][1] == dp[i+k+1][j][0]:\n                    if mini > x-1:\n                        mini = x-1\n                        dp[i][j][0] = dp[i][i+k][0]+(dp[i][i+k][2]==1)\n                        dp[i][j][1] = dp[i+k+1][j][1]+(dp[i+k+1][j][2]==1)\n                        dp[i][j][2] = x-1\n                else:\n                    if mini > x:\n                        mini = x\n                        dp[i][j][0] = dp[i][i+k][0]\n                        dp[i][j][1] = dp[i+k+1][j][1]\n                        dp[i][j][2] = x\n    print(dp[1][n][2])\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()", "complexity": "cubic"}
{"src": "m = int(input())\na = list(map(int, input().split()))\n \ndp = [[505]*m for _ in range(m)]\nMax = [[0]*m for _ in range(m)]\n \nfor i in range(m):  \n    dp[i][i] = 1\n    Max[i][i] = a[i]\n \nfor len in range(1, m+1):\n    for i in range(m-len+1):\n        j = i + len - 1\n        for k in range(i, j):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:\n                dp[i][j] = 1\n                Max[i][j] = Max[i][k] + 1\nprint(dp[0][m-1])", "complexity": "cubic"}
{"src": "n = int(input())\nb = [int(_) for _ in input().split()]\ne = [[-1] * (n+1) for _ in range(2024)]\n \nd = [[] for _ in range(n)]\nfor i, v in enumerate(b):\n\te[v][i] = i\n\td[i].append(i)\n \nfor v in range(1, 2024):\n\tfor i in range(n):\n\t\tj = e[v][i]\n\t\th = e[v][j+1] if j != -1 else -1\n\t\tif j != -1 and h != -1:\n\t\t\te[v+1][i] = h\n\t\t\td[i].append(h)\n \na = [_ for _ in range(1, n+1)]\nfor s in range(n):\n\tfor e in d[s]:\n\t\ta[e] = min(a[e], a[s-1]+1 if s > 0 else 1)\nprint(a[n-1])", "complexity": "cubic"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nmod = 10 ** 9 + 7\n\nR,G,B=map(int,input().split())\nr=list(map(int,input().split()))\ng=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr.sort(reverse=True)\ng.sort(reverse=True)\nb.sort(reverse=True)\ndp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]\nans=0\nfor i in range(R+1):\n    for j in range(G+1):\n        for k in range(B+1):\n            if i>0 and j>0 and k>0:\n                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],\n                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],\n                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])\n            elif i>0 and j>0:\n                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]\n            elif i>0 and k>0:\n                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]\n                ans = max(ans, dp[i][j][k])\n            elif j>0 and k>0:\n                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]\n            ans=max(ans,dp[i][j][k])\n# for i in dp:\n#     print(i)\nprint(ans)\n\n\n\n\n", "complexity": "cubic"}
{"src": "# import sys\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nn = list(map(int, input().split()))\nu = []\nu.append(list(map(int, input().split())))\nu.append(list(map(int, input().split())))\nu.append(list(map(int, input().split())))\nu[0].sort(reverse=True)\nu[1].sort(reverse=True)\nu[2].sort(reverse=True)\nres = 0\ndp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]\nfor i in range(n[0]+1):\n    for j in range(n[1]+1):\n        for k in range(n[2]+1):\n            if i<n[0] and j<n[1]:\n                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])\n            if j<n[1] and k<n[2]:\n                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])\n            if i<n[0] and k<n[2]:\n                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])\nres = max(x for u1 in dp for u2 in u1 for x in u2)\nprint(res)", "complexity": "cubic"}
{"src": "# import sys\n# sys.stdin = open('CF_E93_D2/input.txt', 'r') \n# sys.stdout = open('CF_E93_D2/output.txt', 'w')\n#----------------------------------------------------------------\n\nr,g,b = list(map(int,input().split()))\ndp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]\nra = sorted(list(map(int,input().split())),reverse=True)\nga = sorted(list(map(int,input().split())),reverse=True)\nba = sorted(list(map(int,input().split())),reverse=True)\n\ndef solve(i,j,k) :\n    \n    if dp[i][j][k] != -1 :\n        return dp[i][j][k]\n\n    if i==r :\n        if j==g or k==b :\n            return 0\n        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)\n\n    elif j==g :\n        if i==r or k==b:\n            return 0\n        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)\n        \n    elif k==b :\n        if j==g or i==r:\n            return 0\n        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)\n    \n    else :\n        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))\n\n    return dp[i][j][k]\n\n\nprint(solve(0,0,0))", "complexity": "cubic"}
{"src": "from collections import defaultdict\nfrom sys import setrecursionlimit,stdin\ninput=stdin.readline\nsetrecursionlimit(100000)\n\ndef dfs(r,g,b,rr,gg,bb):\n    if r<0 or g<0 or b<0:\n        return 0\n    x=0\n    y=0\n    z=0\n    \n    if dp[r][g][b]!=-1:\n        return dp[r][g][b]\n    if r!=0 and g!=0:\n        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)\n    if r!=0 and b!=0:\n        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)\n    if b!=0 and g!=0:\n        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)\n    dp[r][g][b]=max(x,y,z)\n    return max(x,y,z)\n\nr,g,b=map(int,input().split())\nrr=list(map(int,input().split()))\ngg=list(map(int,input().split()))\nbb=list(map(int,input().split()))\nrr.sort()\ngg.sort()\nbb.sort()\ndp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]\n\nprint(dfs(r,g,b,rr,gg,bb))\n\n\n\n\n\n", "complexity": "cubic"}
{"src": "#import sys\n#input = sys.stdin.readline\ndef main():\n    R, G, B = map( int, input().split())\n    Rs = list( map( int, input().split()))\n    Gs = list( map( int, input().split()))\n    Bs = list( map( int, input().split()))\n\n    Rs.sort(reverse=True)\n    Gs.sort(reverse=True)\n    Bs.sort(reverse=True)\n\n    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]\n    ans = 0\n    for i in range(R+1):\n        for j in range(G+1):\n            for k in range(B+1):\n                t = 0\n                if i > 0 and j > 0:\n                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:\n                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]\n                if j > 0 and k > 0:\n                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:\n                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]\n                if k > 0 and i > 0:\n                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:\n                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]\n                dp[i][j][k] = t\n                if ans < t:\n                    ans = t\n    print(ans)\n                        \n\nif __name__ == '__main__':\n    main()\n", "complexity": "cubic"}
{"src": "def solve(i, j, k):\n    if dp[i][j][k]!=-1:\n        return dp[i][j][k]\n    call = 0\n    if i>0 and j>0:\n        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))\n    if j>0 and k>0:\n        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))\n    if k>0 and i>0:\n        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))\n    dp[i][j][k] = call\n    return call\n\n\nnr, ng, nb = map(int,input().split())\nR = [0]+list(map(int,input().split()))\nG = [0]+list(map(int,input().split()))\nB = [0]+list(map(int,input().split()))\nR.sort()\nG.sort()\nB.sort()\ndp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]\nans = solve(nr, ng, nb)\nprint(ans)", "complexity": "cubic"}
{"src": "r, g, b = map(int, input().split(' '))\nR = list(map(int, input().split(' ')))\nG = list(map(int, input().split(' ')))\nB = list(map(int, input().split(' ')))\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i == 0 and j == 0 and k == 0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans,dp[i][j][k])\nprint(ans)", "complexity": "cubic"}
{"src": "a,b,c=list(map(int,input().split()))\nR=list(map(int,input().split()))\nG=list(map(int,input().split()))\nB=list(map(int,input().split()))\ndp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]\n# print(dp)\nR.sort()\nG.sort()\nB.sort()\nfor i in range(len(R)+1):\n    for j in range(len(G)+1):\n        for k in range(len(B)+1):\n            if(i and j):\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])\n            if(j and k):\n                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])\n            if(i and k):\n                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])\nprint(dp[len(R)][len(G)][len(B)])      ", "complexity": "cubic"}
{"src": "import math\nimport time\nfrom collections import defaultdict,deque,Counter\nfrom sys import stdin,stdout\nfrom bisect import bisect_left,bisect_right\nfrom queue import PriorityQueue \nimport sys\nt=1\n# t=int(input())\nfor _ in range(t):\n    r,g,b=map(int,stdin.readline().split())\n    ra=list(map(int,stdin.readline().split()))\n    ga=list(map(int,stdin.readline().split()))\n    ba=list(map(int,stdin.readline().split()))\n    ra.sort()\n    ga.sort()\n    ba.sort()\n    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]\n    for i in range(r+1):\n        for j in range(g+1):\n            for k in range(b+1):\n                if(i and j>0):\n                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])\n                if(i and k>0):\n                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])\n                if(k and j>0):\n                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])\n    print(dp[r][g][b])\n", "complexity": "cubic"}
{"src": "\nR,G,B=[int(c) for c in input().split()]\nra=[int(c) for c in input().split()]\nga=[int(c) for c in input().split()]\nba=[int(c) for c in input().split()]\n\nra.sort(reverse=True)\nga.sort(reverse=True)\nba.sort(reverse=True)\n\ndp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)]\ndef solve(dp,r,g,b):\n    if dp[r][g][b] !=-1:\n        return dp[r][g][b]\n    count= 0\n    for i,j in zip((r,g,b),(R,G,B)):\n        if i == j:\n            count+=1\n    if count >= 2:\n        return 0\n\n    ##Three cases choose btw r,b r,g  and gb\n    res = -999\n    if r != R and b!=B:\n\n        res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1))\n        # print(res)\n    \n    if r!=R and g != G:\n        res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b))\n        # print(res)\n    \n    if b!=B and g != G:\n        res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1))\n        # print(res)\n    \n    dp[r][g][b] = res\n\n    return res\n     \n\nprint(solve(dp,0,0,0))", "complexity": "cubic"}
{"src": "import sys\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\nr, g, b = nm()\nR = nl()\nG = nl()\nB = nl()\ndp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]\nR.sort(reverse=True)\nG.sort(reverse=True)\nB.sort(reverse=True)\nR.insert(0, 0)\nG.insert(0, 0)\nB.insert(0, 0)\ndp[0][0][0], ans = 0, 0\nfor i in range(0, r+1):\n    for j in range(0, g+1):\n        for k in range(0, b+1):\n            if i==0 and j==0 and k==0:continue\n            if i and j and dp[i - 1][j - 1][k] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])\n            if k and j and dp[i][j - 1][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])\n            if i and k and dp[i - 1][j][k - 1] != -1:\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])\n            ans = max(ans, dp[i][j][k])\nprint(ans)", "complexity": "cubic"}
{"src": "R, G, B = map(int, input().split())\nr = list(map(int, input().split()))\ng = list(map(int, input().split()))\nb = list(map(int, input().split()))\nr.sort()\ng.sort()\nb.sort()\n# State- dp[i][j][k] represents max value after choosing i elements from r, j elements from g, k elements from b\ndp = [[[0]*202 for i in range(202)] for j in range(202)]\nfor i in range(R+1):\n       for j in range(G+1):\n              for k in range(B+1):\n                     if i and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])\n                     if i and k:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])\n                     if k and j:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])\nprint(dp[R][G][B])\n", "complexity": "cubic"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\nimport heapq\n# c=sorted((i,int(val))for i,val in enumerate(input().split()))\n# n = int(input())\n# ls = list(map(int, input().split()))\n# n, k = map(int, input().split())\n# n =int(input())\n#arr=[(i,x) for i,x in enum]\n#arr.sort(key=lambda x:x[0])\n#print(arr)\n# e=list(map(int, input().split()))\nfrom collections import Counter\n#print(\"\\n\".join(ls))\n#print(os.path.commonprefix(ls[0:2]))\n#n=int(input())\nfrom bisect import  bisect_right\n#for _ in range(int(input())):\n#n=int(input())\n#arr = list(map(int, input().split()))\n#for _ in range(int(input())):\n#n, k = map(int, input().split())\nimport bisect\n#n=int(input())\n#n, p,q,r = map(int, input().split())\n#arr = list(map(int, input().split()))\n#n=int(input())\n#nm,k = map(int, input().split())\n#for _ in range(int(input())):\ndef find(x,y,z):\n    if dp[x][y][z]!=-1:\n        return dp[x][y][z]\n    ans=0\n    if x<r and y<g:\n        ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z))\n    if x<r and z<b:\n        ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1))\n    if y<g and z<b:\n        ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1))\n\n    dp[x][y][z]=ans\n    return ans\nr,g,b = map(int, input().split())\nrl=sorted(list(map(int, input().split())),reverse=True)\ngl=sorted(list(map(int, input().split())),reverse=True)\nbl=sorted(list(map(int, input().split())),reverse=True)\ndp=[[[-1]*(b+1) for i in range(g+1)]for i in range(r+1)]\nprint(find(0,0,0))\n\n", "complexity": "cubic"}
{"src": "R, G, B = map(int, input().split())\nL = [sorted(map(int, input().split())) for _ in range(3)]\n \nDP = [0] * ((R+1) * (G+1) * (B+1))\ndef idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b\n \nfor r in range(R+1):\n\tfor g in range(G+1):\n\t\tfor b in range(B+1):\n\t\t\tbest = 0\n \n\t\t\tif r:\n\t\t\t\tif g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]\n\t\t\t\tif b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])\n \n\t\t\tif g and b:\n\t\t\t\tbest = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])\n \n\t\t\tDP[idx(r, g, b)] = best\n \nprint(max(DP))", "complexity": "cubic"}
{"src": "import sys\ninput = sys.stdin.readline\n\nclass sieve:\n  def __init__(self, n):\n    self.n = n\n    self.sv = [1] * (n + 1)\n    self.sv[0] = 0\n    self.sv[1] = 0\n    for i in range(2, n + 1):\n      if self.sv[i]:\n        for j in range(i * 2, n + 1, i):\n          self.sv[j] = 0\n  def isprime(self, x):\n    if x > self.n:\n      return False\n    return self.sv[x] == 1\n  def factorize(self, x):\n    res = []\n    for i in range(2, int(x ** 0.5) + 1):\n      if self.sv[i]:\n        while x % i == 0:\n          x //= i\n          res.append(i)\n    if x != 1:\n      res.append(x)\n    return res\n  def modlcm(self, a, mod):\n    res = [0] * (self.n + 1)\n    ex = set()\n    for i in range(len(a)):\n      f = self.factorize(a[i])\n      for j in f:\n        if j > self.n:\n          ex.add(j)\n          continue\n        res[j] = max(f.count(j), res[j])\n    rres = 1\n    for i in range(self.n + 1):\n      if res[i] != 0:\n        rres *= pow(i, res[i], mod)\n        rres %= mod\n    for i in ex:\n      rres *= i\n      rres %= mod\n    return rres\n\nsv = sieve(10 ** 4)\nfor _ in range(int(input())):\n  n, k = map(int, input().split())\n  a = list(map(int, input().split()))\n  for i in range(n):\n    x = a[i]\n    q = sv.factorize(x)\n    s = [1]\n    while len(q):\n      y = q.pop()\n      if y == s[-1]:\n        s.pop()\n        a[i] //= y ** 2\n      else: s.append(y)\n  s = [set() for _ in range(k + 1)]\n  #print(a)\n  dp = [n] * (k + 1)\n  dp[0] = 0\n\n  for i in range(n):\n    for j in range(k, -1, -1):\n      if dp[j] == n: continue\n      if a[i] in s[j]:\n        if j + 1 <= k and dp[j + 1] > dp[j]:\n          dp[j + 1] = dp[j]\n          s[j + 1] = s[j]\n        dp[j] += 1\n        s[j] = set()\n        s[j].add(a[i])\n      else:\n        s[j].add(a[i])\n      \n\n    #print(dp, s)\n\n  for j in range(k + 1): dp[j] += len(s[j]) > 0\n  print(min(dp))\n", "complexity": "cubic"}
{"src": "def nr(): return nrs()[0]\ndef nrs(): return [int(i) for i in input().split()]\n\ndef get_prime(n):\n\tres = []\n\tfor i in range(2,n):\n\t\tis_prime = True\n\t\tfor x in res:\n\t\t\tif i % x == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime: res.append(i)\n\treturn res\n\nprime = get_prime(3162)\n\ncache = {}\ndef get_mask (num):\n\tkey = num\n\tif key in cache: return cache[key]\n\tdv = []\n\tfor p in prime:\n\t\tc = 0\n\t\twhile num % p == 0:\n\t\t\tc += 1\n\t\t\tnum = num // p\n\t\tif c % 2 == 1:\n\t\t\tdv.append(p)\n\t\tif num < p * p:\n\t\t\tbreak\n\n\tfor x in dv:\n\t\tnum *= x\n\n\tcache[key] = num\n\treturn num\n\nfor _ in range(nr()):\n\tN, K = nrs()\n\tA = nrs()\n\tdp = [N] * (K + 1)\n\tdp[0] = 1\n\tused = [{}] * (K + 1)\n\tfor a in A:\n\t\ta = get_mask(a)\n\t\tfor j in range(K, -1, -1):\n\t\t\tif dp[j] == N: continue\n\t\t\tif a in used[j]:\n\t\t\t\tif j < K and dp[j + 1] > dp[j]:\n\t\t\t\t\tdp[j + 1] = dp[j]\n\t\t\t\t\tused[j + 1] = used[j]\n\t\t\t\tdp[j] += 1\n\t\t\t\tused[j] = {}\n\t\t\tused[j][a] = 1\n\tprint(min(dp))\n", "complexity": "cubic"}
{"src": "#   Author: yumtam\n#   Created at: 2021-05-03 00:42\n\nfrom __pypy__.intop import int_mulmod\n\nn_, MOD = [int(t) for t in input().split()]\n\ndef mul(a, b):\n    return int_mulmod(a, b, MOD)\n\nN = 410\ndp = [[0] * (N+1) for _ in range(N+1)]\n\nfact = [1]\nfor x in range(1, N):\n    fact.append(fact[-1] * x % MOD)\n\ninv_fact = [0] * N\ninv_fact[-1] = pow(fact[-1], MOD - 2, MOD)\nfor x in reversed(range(1, N)):\n    inv_fact[x - 1] = inv_fact[x] * x % MOD\n\ndef nCr(n, r):\n    return mul(fact[n], mul(inv_fact[n-r], inv_fact[r]))\n\nfor n in range(1, N+1):\n    dp[n][n] = pow(2, n-1, MOD)\n    for i in range(1, n-1):\n        j = n-i-1\n        for k in range(1, i+1):\n            dp[n][k+j] = (dp[n][k+j]\n                          + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD\n\nprint(sum(dp[n_]) % MOD)\n", "complexity": "cubic"}
{"src": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    n, MOD = map(int, input().split())\n    factorial = [1]\n    for i in range(2, n + 1):\n        factorial.append(factorial[-1] * i % MOD)\n    for i in range(len(factorial)):\n        factorial[i] = pow(factorial[i], MOD - 2, MOD)\n    DP = []\n    for i in range(n):\n        DP.append([0] * n)\n    for i in range(n):\n        DP[i][0] = pow(2, i, MOD) * factorial[i]\n        for j in range(1, i // 2 + 1):\n            for k in range(0, i - 1):\n                DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2]\n            DP[i][j] %= MOD\n    ans = 0\n    for i in range(len(factorial)):\n        factorial[i] = pow(factorial[i], MOD - 2, MOD)\n    for i in range(n):\n        ans += DP[n - 1][i] * factorial[n - i - 1]\n    print(ans % MOD)\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic"}
{"src": "\np1, g1, ig1 = 104857601, 3, 34952534\np2, g2, ig2 = 111149057, 3, 37049686\np3, g3, ig3 = 113246209, 7, 16178030\nz1 = 439957480532171226961446\nz2 = 879898597692195524486915\nz3 = 8496366309945115353\nppp = p1 * p2 * p3\nW1 = [pow(g1, (p1 - 1) >> i, p1) for i in range(22)]\nW2 = [pow(g2, (p2 - 1) >> i, p2) for i in range(22)]\nW3 = [pow(g3, (p3 - 1) >> i, p3) for i in range(22)]\niW1 = [pow(ig1, (p1 - 1) >> i, p1) for i in range(22)]\niW2 = [pow(ig2, (p2 - 1) >> i, p2) for i in range(22)]\niW3 = [pow(ig3, (p3 - 1) >> i, p3) for i in range(22)]\n\ndef fft1(k, f):\n    for l in range(k, 0, -1):\n        d = 1 << l - 1\n        U = [1]\n        for i in range(d):\n            U.append(U[-1] * W1[l] % p1)\n        \n        for i in range(1 << k - l):\n            for j in range(d):\n                s = i * 2 * d + j\n                f[s], f[s+d] = (f[s] + f[s+d]) % p1, U[j] * (f[s] - f[s+d]) % p1\ndef fft2(k, f):\n    for l in range(k, 0, -1):\n        d = 1 << l - 1\n        U = [1]\n        for i in range(d):\n            U.append(U[-1] * W2[l] % p2)\n        \n        for i in range(1 << k - l):\n            for j in range(d):\n                s = i * 2 * d + j\n                f[s], f[s+d] = (f[s] + f[s+d]) % p2, U[j] * (f[s] - f[s+d]) % p2\ndef fft3(k, f):\n    for l in range(k, 0, -1):\n        d = 1 << l - 1\n        U = [1]\n        for i in range(d):\n            U.append(U[-1] * W3[l] % p3)\n        \n        for i in range(1 << k - l):\n            for j in range(d):\n                s = i * 2 * d + j\n                f[s], f[s+d] = (f[s] + f[s+d]) % p3, U[j] * (f[s] - f[s+d]) % p3\n\ndef ifft1(k, f):\n    for l in range(1, k + 1):\n        d = 1 << l - 1\n        for i in range(1 << k - l):\n            u = 1\n            for j in range(i * 2 * d, (i * 2 + 1) * d):\n                f[j+d] *= u\n                f[j], f[j+d] = (f[j] + f[j+d]) % p1, (f[j] - f[j+d]) % p1\n                u = u * iW1[l] % p1\ndef ifft2(k, f):\n    for l in range(1, k + 1):\n        d = 1 << l - 1\n        for i in range(1 << k - l):\n            u = 1\n            for j in range(i * 2 * d, (i * 2 + 1) * d):\n                f[j+d] *= u\n                f[j], f[j+d] = (f[j] + f[j+d]) % p2, (f[j] - f[j+d]) % p2\n                u = u * iW2[l] % p2\ndef ifft3(k, f):\n    for l in range(1, k + 1):\n        d = 1 << l - 1\n        for i in range(1 << k - l):\n            u = 1\n            for j in range(i * 2 * d, (i * 2 + 1) * d):\n                f[j+d] *= u\n                f[j], f[j+d] = (f[j] + f[j+d]) % p3, (f[j] - f[j+d]) % p3\n                u = u * iW3[l] % p3\n\ndef convolve(a, b):\n    n0 = len(a) + len(b) - 1\n    if len(a) < 50 or len(b) < 50:\n        ret = [0] * n0\n        if len(a) > len(b): a, b = b, a\n        for i, aa in enumerate(a):\n            for j, bb in enumerate(b):\n                ret[i+j] = (ret[i+j] + aa * bb) % P\n        return ret\n    \n    k = (n0).bit_length()\n    n = 1 << k\n    a = a + [0] * (n - len(a))\n    b = b + [0] * (n - len(b))\n    \n    a1 = [x % p1 for x in a]\n    a2 = [x % p2 for x in a]\n    a3 = [x % p3 for x in a]\n    b1 = [x % p1 for x in b]\n    b2 = [x % p2 for x in b]\n    b3 = [x % p3 for x in b]\n    fft1(k, a1), fft1(k, b1)\n    fft2(k, a2), fft2(k, b2)\n    fft3(k, a3), fft3(k, b3)\n    for i in range(n): a1[i] = a1[i] * b1[i] % p1\n    for i in range(n): a2[i] = a2[i] * b2[i] % p2\n    for i in range(n): a3[i] = a3[i] * b3[i] % p3\n    ifft1(k, a1)\n    ifft2(k, a2)\n    ifft3(k, a3)\n    invn1 = pow(n, p1 - 2, p1)\n    invn2 = pow(n, p2 - 2, p2)\n    invn3 = pow(n, p3 - 2, p3)\n    for i in range(n0): a1[i] = a1[i] * invn1 % p1\n    for i in range(n0): a2[i] = a2[i] * invn2 % p2\n    for i in range(n0): a3[i] = a3[i] * invn3 % p3\n    return [(x1 * z1 + x2 * z2 + x3 * z3) % ppp % P for x1, x2, x3 in zip(a1[:n0], a2[:n0], a3[:n0])]\ndef chk(L):\n    return [fa[i] * x % P for i, x in enumerate(L)]\ndef chkinv(L):\n    return [fainv[i] * x % P for i, x in enumerate(L)]\nN, P = map(int, input().split())\n\nnn = 1001 # !!!!!!!!!!!\n\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nX = [[] for _ in range(444)]\nY = [[] for _ in range(444)]\nX[0] = [1]\nX[1] = [0, 1]\nX[2] = [0, 1, 1]\nX[3] = [0, 0, 4, 1]\n\nY[0] = [1]\nY[1] = [1, 0]\nY[2] = [0, 2, 0]\nY[3] = [0, 1, 4, 0]\n\nfor i in range(4, 404):\n    X[i] = [0] * i + [1]\n    Y[i] = [0] * (i + 1)\n    for j in range(1, i):\n        k = i - j\n        X[i][j] = (X[i-1][j-1] * (2 * k + 1) + X[i-2][j-1] * k) % P\n        Y[i][j] = (Y[i-1][j-1] * (2 * k) + Y[i-2][j-1] * (k-1)) % P\n\nX = [chkinv(a) for a in X]\nY = [chkinv(a) for a in Y]\n\nANS = [0] * (N + 1)\nfor i in range(N):\n    t = convolve(X[i], X[N-1-i])\n    for j, a in enumerate(t):\n        ANS[j] = (ANS[j] + a) % P\n# print(ANS)\nans = 0\nfor i, a in enumerate(ANS):\n    ans = (ans + a * fa[i]) % P\nprint(ans)\n\n\n\n", "complexity": "cubic"}
{"src": "\ninp = input().split()\ntotNums, mod = int(inp[0]), int(inp[1])\n\ndef Exp(b,exp):\n\tif exp==0: return 1\n\ttemp = Exp(b,exp>>1)**2\n\tif exp%2==1: temp*=b\n\treturn temp%mod\n\n\n#main\nn = 410\n\n\n#Precompute\nfact, inv = [0 for i in range(n)],[0 for i in range(n)]\nfact[0] = inv[0] = 1;\nfor i in range(1,totNums+1):\n\tfact[i] = fact[i-1]*i%mod\n\tinv[i] = Exp(fact[i],mod-2)\n\ndp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)]\nfor i in range(0,totNums+1):\n\tfor j in range(0,i+1):\n\t\tchoose[i][j] = fact[i]*inv[j]*inv[i-j]%mod\npow2 = [Exp(2,i) for i in range(n)]\n\n#dp\ndp[0][0] = 1\nfor i in range(totNums):\n\tfor j in range(i+1):\n\t\tfor k in range(1,totNums-i+1):\n\t\t\tdp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k]\n\t\t\tdp[i+k+1][j+k] %= mod\n\nans = 0\nfor i in range(0,totNums+1):\n\tans = (ans+dp[totNums+1][i])%mod\nprint(ans)", "complexity": "cubic"}
{"src": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M, K = map(int, input().split())\nif K % 2:\n    for _ in range(N):\n        print(*[-1] * M)\n    exit()\nA = [[int(a) for a in input().split()] for _ in range(N)]\nB = [[int(a) for a in input().split()] for _ in range(N-1)]\nX = [[0] * M for _ in range(N)]\ninf = 1 << 30\nfor k in range(1, K // 2 + 1):\n    nX = [[inf] * M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j])\n            if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j])\n            if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1])\n            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j])\n    X = nX\nfor x in X:\n    print(*[a * 2 for a in x])\n\n\n", "complexity": "cubic"}
{"src": "import sys, os\n\nif os.environ['USERNAME']=='kissz':\n    inp=open('in.txt','r').readline\n    def debug(*args):\n        print(*args,file=sys.stderr)\nelse:\n    inp=sys.stdin.readline    \n    def debug(*args):\n        pass\n\n# SCRIPT STARTS HERE\n\nn,m,k=map(int,inp().split())\nA=[[*map(int,inp().split())] for _ in range(n)]\nB=[[*map(int,inp().split())] for _ in range(n-1)]\nif k%2==0:\n    O=[[[1e12]*m for _ in range(n)] for _ in range(k//2)]\n    for i in range(n):\n        for j in range(m):\n            if i>0:\n                O[0][i][j]=min(O[0][i][j],B[i-1][j])\n            if i<n-1:\n                O[0][i][j]=min(O[0][i][j],B[i][j])\n            if j>0:\n                O[0][i][j]=min(O[0][i][j],A[i][j-1])\n            if j<m-1:\n                O[0][i][j]=min(O[0][i][j],A[i][j])\n    #for i in range(n):\n    #    debug(*O[0][i])\n    for l in range(1,k//2):\n        for i in range(n):\n            for j in range(m):\n                if i>0:\n                    O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j])\n                if i<n-1:\n                    O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j])\n                if j>0:\n                    O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1])\n                if j<m-1:\n                    O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1])         \n                \n        #for i in range(n):\n        #    debug(*O[l][i])\n    for i in range(n):\n        print(*[O[-1][i][j]*2 for j in range(m)])\nelse:\n    for i in range(n):\n        print(*[-1]*m)\n    \n\n", "complexity": "cubic"}
{"src": "from sys import stdin\ninput=stdin.readline\nn,m,k=map(int,input().split())\nlr=[list(map(int,input().split())) for i in range(n)] # (i,j),(i,j+1)\nud=[list(map(int,input().split())) for i in range(n-1)] # (i,j),(i+1,j)\nif k%2:\n  arr=[-1]*m\n  for i in range(n):\n    print(*arr)\n  exit()\nkk=k//2\ndp=[[[10**10]*(kk+1) for i in range(m)] for j in range(n)]\nfor i in range(n):\n  for j in range(m):\n    dp[i][j][0]=0\nfor z in range(1,kk+1):\n  for i in range(n):\n    for j in range(m):\n      if i>0:\n        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-1]+ud[i-1][j])\n      if i<n-1:\n        dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-1]+ud[i][j])\n      if j>0:\n        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-1]+lr[i][j-1])\n      if j<m-1:\n        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-1]+lr[i][j])\nans=[[dp[i][j][kk]*2 for j in range(m)] for i in range(n)]\nfor i in range(n):\n  print(*ans[i])", "complexity": "cubic"}
{"src": "# URDL\nDR = [1,0,-1,0]\nDC = [0,1,0,-1]\n\nn, m, k = map(int, input().split())\nw = [[[0] * m for _ in range(n)] for _ in range(4)]\nfor r in range(n):\n    for c, e in enumerate(map(int, input().split())):\n        w[1][r][c] = w[3][r][c + 1] = e\nfor r in range(n - 1):\n    for c, e in enumerate(map(int, input().split())):\n        w[0][r][c] = w[2][r + 1][c] = e\n\n\nINF = 10 ** 9\n\n\ndef solve():\n    global k\n    global w\n    if k % 2 == 1:\n        return [[-1] * m] * n\n    k //= 2\n    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]\n    for steps in range(1, k + 1):\n        for r in range(n):\n            for c in range(m):\n                best[steps][r][c] = INF\n                for d in range(4):\n                    r2, c2 = r + DR[d], c + DC[d]\n                    if 0 <= r2 < n and 0 <= c2 < m:\n                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])\n    return best[k]\n\n\nres = solve()\nfor e in res:\n    print(*e)", "complexity": "cubic"}
{"src": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#https://github.com/cheran-senthil/PyRival/blob/master/templates/template_py3.py\n\n\nn,m,k=map(int,input().split())\ny_axis=[list(map(int,input().split())) for i in range(n)]\nx_axis=[list(map(int,input().split())) for i in range(n-1)]\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=\" \")\n        print()\nelse:\n    inf=10**9\n    dp=[[[inf for z in range(k+1)]for y in range(m)]for x in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if(i>0):\n                if(i<n-1):\n                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j],2*x_axis[i-1][j])\n                else:\n                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i-1][j])\n            else:\n                dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j])\n            if(j>0):\n                if(j<m-1):\n                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j],2*y_axis[i][j-1])\n                else:\n                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j-1])\n            else:\n                dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j])\n    for z in range(4,k+1,2):\n        for i in range(n):\n            for j in range(m):\n                if(i>0):\n                    if(i<n-1):\n                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j],dp[i+1][j][z-2]+2*x_axis[i][j])\n                    else:\n                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j])\n                else:\n                    dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-2]+2*x_axis[i][j])\n                if(j>0):\n                    if(j<m-1):\n                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1],dp[i][j+1][z-2]+2*y_axis[i][j])\n                    else:\n                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1])\n                else:\n                    dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*y_axis[i][j])\n    for i in range(n):\n        for j in range(m):\n            if(dp[i][j][k]==inf):\n                print(-1,end=\" \")\n            else:\n                print(dp[i][j][k],end=\" \")\n        print()\n                \n                    \n            \n        \n", "complexity": "cubic"}
{"src": "from sys import stdin, stdout \ninput = stdin.readline\n \nn,m,K = map(int,input().split())\nedges = []\nfor i in range(n):\n    edges.append([[]])\n    lis = list(map(int,input().split()))\n    for j in range(m-1):\n        edges[i][j].append((1,0,lis[j]))\n        edges[i].append([])\n        edges[i][j+1].append((-1,0,lis[j]))\nfor i in range(n-1):\n    lis = list(map(int,input().split()))\n    for j in range(m):\n        edges[i][j].append((0,1,lis[j]))\n        edges[i+1][j].append((0,-1,lis[j]))\n\nif K%2==1:\n    lis = []\n    for i in range(n):\n        lis.append([-1]*m)\nelse:\n    lis = []\n    for i in range(n):\n        lis.append([0]*m)\n        \n    for k in range(1,(K//2)+1):\n        new_lis = []\n        for i in range(n):\n            new_lis.append([0]*m)\n        for i in range(n):\n            for j in range(m):\n                dist = []\n                for e in edges[i][j]:\n                    # print(e,i,j,lis)\n                    dist.append(e[2] + lis[i+e[1]][j+e[0]])\n                new_lis[i][j] = min(dist)\n        lis = new_lis\n    for i in range(n):\n        for j in range(m):\n            lis[i][j] *= 2\n            \nfor i in lis:\n    print(*i)", "complexity": "cubic"}
{"src": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom array import array\n\ndef main():\n    n,m,k=map(int,input().split())\n    left=[array(\"i\",map(int,input().split())) for _ in range(n)]\n    down=[array(\"i\",map(int,input().split())) for _ in range(n-1)]\n    dp=[array(\"i\",[(-1 if k&1 else 0) for _ in range(m)]) for _ in range(n)]\n    if k&1==0:\n        for l in range(k//2):\n            dp1=[array(\"i\",[10**8 for _ in range(m)]) for _ in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    if j>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])\n                    if j<m-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])\n                    if i>0:\n                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])\n                    if i<n-1:\n                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])\n            dp=dp1\n    for i in dp:\n        print(*i)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()", "complexity": "cubic"}
{"src": "n,m,k = map(int,input().split())\nright = [[9999999 for i in range(m-1)] for j in range(n)]\ndown =  [[9999999 for i in range(m)] for j in range(n-1)]\nfor i in range(n):\n    right[i] = list(map(int,input().split()))\nfor i in range(n-1):\n    down[i] = list(map(int,input().split()))\n\nif(k%2==1):\n    for i in range(n):\n        for j in range(m):\n            print(\"-1\",end=\" \")\n        print()\nelse:\n    k = k//2\n    row = n\n    col = m\n    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]\n    for steps in range(k+1):\n        for i in range(row):\n            for j in range(col):\n                if(steps==0):\n                    dp[steps][i][j] = 0\n                    continue\n                ans = 99999999999\n                if(i>0):\n                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])\n                if(i<n-1):\n                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])\n                if(j<m-1):\n                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])\n                if(j>0):\n                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])\n                dp[steps][i][j] = ans\n                \n    for i in range(n):\n        for j in range(m):\n            print(2*dp[k][i][j],end=\" \")\n        print()\n    ", "complexity": "cubic"}
{"src": "'''\nAuthor: your name\nDate: 2021-04-25 17:01:28\nLastEditTime: 2021-04-25 17:13:31\nLastEditors: Please set LastEditors\nDescription: In User Settings Edit\nFilePath: \\code_py\\cf_718D.py\n'''\n\n\ndef main():\n    n, m, k = map(int, input().split())\n    inf = 1 << 30\n    left = [list(map(int, input().split())) for i in range(n)]\n    down = [list(map(int, input().split())) for i in range(n-1)]\n    if k & 1:\n        for i in range(n):\n            print(*[-1]*m)\n        exit()\n    ans = [[0]*m for i in range(n)]\n    for k in range(1, k//2+1):\n        _ = [[inf]*m for ii in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i:\n                    _[i][j] = min(_[i][j], ans[i-1][j]+down[i-1][j])\n                if i < n-1:\n                    _[i][j] = min(_[i][j], ans[i+1][j]+down[i][j])\n                if j:\n                    _[i][j] = min(_[i][j], ans[i][j-1]+left[i][j-1])\n                if j < m-1:\n                    _[i][j] = min(_[i][j], ans[i][j+1]+left[i][j])\n        ans = _\n    for i in range(n):\n        for j in range(m):\n            print(ans[i][j]*2, end=' ')\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "cubic"}
{"src": "n, m, k =map(int, input().split())\nhorizontal = [list(map(int, input().split())) for i in range(n)]\nvertical = [list(map(int, input().split())) for i in range(n-1)]\nif k%2 or max(n, m)==1:print(*[\" \".join(['-1']*m) for i in range(n)], sep='\\n');exit()\ndp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]\nfor length in range(1, k//2+1):\n    for i in range(n):\n        for j in range(m):\n            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]\n            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]\n            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]\n            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]\n            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])\nfor i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])\n", "complexity": "cubic"}
{"src": "def main():\n    n, m, k = [int(v) for v in input().split()]\n    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    # dx = [-1, 1, 0, 0]\n    # dy = [0, 0, -1, 1]\n    w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)]\n    for i in range(n):\n        row = [int(v) for v in input().split()]\n        for j in range(m-1):\n            w[i][j+1][2] = row[j]\n            w[i][j][3] = row[j]\n    for i in range(n-1):\n        row = [int(v) for v in input().split()]\n        for j in range(m):\n            w[i][j][1] = row[j]\n            w[i+1][j][0] = row[j]\n    if k % 2 == 1:\n        for i in range(n):\n            for j in range(m):\n                print(-1, end=\" \")\n            print()\n        return\n    else:\n        k //= 2\n    dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0] = 0\n    for d in range(1, k+1):\n        for i in range(n):\n            for j in range(m):\n                for di, (dx, dy) in enumerate(dxy):\n                    ii = i + dx\n                    jj = j + dy\n                    if 0 <= ii < n and 0 <= jj < m:\n                        dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di])\n    for i in range(n):\n        for j in range(m):\n            print(dp[i][j][k] * 2, end=\" \")\n        print()\n\nmain()\n\n", "complexity": "cubic"}
{"src": "import math\n\nn,m,kk=[int(x) for x in input().split()]\nright,down=[],[]\nfor i in range(n) :\n\ta=[int(x) for x in input().split()]\n\tright.append(a)\n\nfor i in range(n-1) :\n\ta=[int(x) for x in input().split()]\n\tdown.append(a)\n\ndp,dpCopy=[],[]\nfor i in range(n) :\n\tli,li1=[],[]\n\tfor j in range(m) :\n\t\tli.append(math.inf)\n\t\tli1.append(math.inf)\n\tdp.append(li)\n\tdpCopy.append(li1)\n\n'''for i in range(n) :\n\tli=[]\n\tfor j in range(m) :\n\t\tli.append(math.inf)\n\tdpCopy.append(li)'''\n\nfor i in range(1,(kk//2)+1) :\n\t#print(i)\n\tfor j in range(n) :\n\t\tfor k in range(m) :\n\t\t\tif i==1 :\n\t\t\t\tif j==0 :\n\t\t\t\t\tif k==0 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],down[j][k],right[j][k])\n\t\t\t\t\telif k==m-1 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])\n\t\t\t\t\telse :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])\n\t\t\t\telif j==n-1 :\n\t\t\t\t\tif k==0 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])\n\t\t\t\t\telif k==m-1 :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])\n\t\t\t\t\telse :\n\t\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])\n\t\t\t\telif k==0 :\n\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])\n\t\t\t\telif k==m-1 :\n\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])\n\t\t\t\telse :\n\t\t\t\t\tdp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])\n\t\t\t\t#print(dpCopy)\n\t\t\t\tcontinue\n\n\t\t\tif j==0 :\n\t\t\t\tif k==0 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])\n\t\t\t\telif k==m-1 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])\n\t\t\t\telse :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])\n\t\t\telif j==n-1 :\n\t\t\t\tif k==0 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])\n\t\t\t\telif k==m-1 :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])\n\t\t\t\telse :\n\t\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])\n\t\t\telif k==0 :\n\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])\n\t\t\telif k==m-1 :\n\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])\n\t\t\telse :\n\t\t\t\tdp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])\n\t\t\t#print(dp)\n\n\tfor ii in range(n) :\n\t\tfor jj in range(m) :\n\t\t\tdpCopy[ii][jj]=dp[ii][jj]\n\nif kk%2==1 :\n\tfor i in range(n) :\n\t\tfor j in range(m) :\n\t\t\tprint(-1,end=' ')\n\t\tprint()\n\texit(0)\n\nfor i in range(n) :\n\tfor j in range(m) :\n\t\tprint(2*dp[i][j],end=' ')\n\tprint()", "complexity": "cubic"}
{"src": "def roll(i,j):\n    ways = []\n    if j:\n        ways.append(2*hor[i][j-1] + grid[i][j-1])\n    if m-1-j:\n        ways.append(2*hor[i][j] + grid[i][j+1])\n    if i:\n        ways.append(2*ver[i-1][j] + grid[i-1][j])\n    if n-1-i:\n        ways.append(2*ver[i][j] + grid[i+1][j])\n    return min(ways)\n \nn , m , k = map(int, input().split())\nhor = [list(map(int, input().split())) for _ in range(n)]\nver = [list(map(int, input().split())) for _ in range(n-1)]\n \n \ngrid = [[0]*m for _ in range(n)]\nif k%2:\n    for _ in range(n):\n        print(\" \".join([\"-1\"]*m))\nelse:\n    for _ in range(k//2):\n        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]\n        grid = new_grid[:]\n    for i in range(n):\n        print(\" \".join(map(str,grid[i])))", "complexity": "cubic"}
{"src": "from sys import stdin\ninput=stdin.readline\ndef answer():\n    dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dp[i][j][0]=0\n    \n    for x in range(1,k//2 + 1):\n\n        for i in range(n):\n            for j in range(m):\n\n                if(i > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])\n                if(j > 0):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])\n                if(i + 1 < n):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])\n                if(j + 1 < m):\n                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])\n\n    for i in range(n):\n        for j in range(m):\n            print(2*dp[i][j][-1],end=' ')\n\n        print()\n\n\n\nn,m,k=map(int,input().split())\n\nr=[list(map(int,input().split())) for i in range(n)]\nc=[list(map(int,input().split())) for i in range(n-1)]\n\nif(k & 1):\n    for i in range(n):\n        for j in range(m):\n            print(-1,end=' ')\n    \nelse:answer()\n", "complexity": "cubic"}
{"src": "inf=10000000000\nn,m,k=(int(i) for i in input().split())\nh=[[int(i) for i in input().split()]for i in range(n)]\nz=[[int(i) for i in input().split()]for i in range(n-1)]\ndh=lambda x,y:h[x][y] if 0<=x<len(h) and 0<=y<len(h[0]) else inf\ndz=lambda x,y:z[x][y] if 0<=x<len(z) and 0<=y<len(z[0]) else inf\ndp=[[[0 for iii in range(m)] for ii in range(n)] for i in range(2)]\nddp=lambda x,y,z:dp[x][y][z] if 0<=y<n and 0<=z<m else inf\nif k%2!=0:\n    for i in dp[0]:\n        for j in i:\n            print(-1,end=' ')\n        print()\nelse:\n    for kk in range(int(k/2)):\n        for i in range(n):\n            for j in range(m):\n                dp[1][i][j]=min(ddp(0,i-1,j)+dz(i-1,j),ddp(0,i+1,j)+dz(i,j),ddp(0,i,j-1)+dh(i,j-1),ddp(0,i,j+1)+dh(i,j))\n        dp.reverse()\n    for i in dp[0]:\n        for j in i:\n            print(2*j,end=' ')\n        print()\n", "complexity": "cubic"}
{"src": "import sys,math\nclass Node:\n    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):\n        self.up=u\n        self.dn=d\n        self.lt=l\n        self.rt=r\n    def __str__(self):\n        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)\n\nn,m,k=list(map(int,sys.stdin.readline().strip().split()))\ngraph=[[Node() for j in range(m)]for i in range(n)]\nfor i in range(n):\n    wts=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(m-1):\n        graph[i][j].rt=wts[j]\n        graph[i][j+1].lt=wts[j]\n\nfor i in range(n-1):\n    wts=list(map(int,sys.stdin.readline().strip().split()))\n    for j in range(m):\n        graph[i][j].dn=wts[j]\n        graph[i+1][j].up=wts[j]\n\nans=[[math.inf for j in range(m)]for i in range(n)]\n\nif k%2:\n    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]\n    \nelse:\n    def bfs(prsnt,stps):\n        # print(prsnt,stps)\n        if stps==0:\n            return 0\n        else:\n            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:\n                min_cost=math.inf\n                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:\n                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:\n                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)\n                dp[prsnt[0]][prsnt[1]][stps]=min_cost\n                return min_cost\n            else:\n                return dp[prsnt[0]][prsnt[1]][stps]\n\n    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            ans[i][j]=bfs((i,j),k//2)*2\n    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]", "complexity": "cubic"}
{"src": "def main():\n    a = sorted(input(), reverse=True)\n    b = int(input())\n    k = \"\"\n    while len(a) > 0:\n        for i in range(len(a)):\n            num = k + a[i] + \"\".join(sorted(a[:i] + a[i + 1:]))\n            if int(num) <= b:\n                k += a[i]\n                a = a[:i] + a[i + 1:]\n                break\n    print(k)\n\n\nif __name__ == \"__main__\":\n    main()\n", "complexity": "cubic"}
{"src": "a=input()\nb=input()\nv=sorted(a)\nv=v[::-1]\nx=\"\"\nfor i in range(len(v)):\n    x=x+v[i]\nv=x\nif(len(a)<len(b)):\n    print(v)\nelse:\n    if(b==a):\n        print(a)\n    else:\n        fin=\"\"\n        flag=False\n        for j in range(len(a)):            \n            for k in range(len(a)):\n                num=fin+v[k]+''.join(sorted(v[:k:]+v[k+1::]))\n                #print(num,k,fin)\n                if(num<=b):\n                    fin+=v[k]\n                    #print(fin,v[k],b[j])\n                    if(int(v[k])<int(b[j])):\n                        flag=True\n                        v=v[:k:]+v[k+1::]\n                        fin+=v \n                    v=v[:k:]+v[k+1::]\n                    break\n            if(flag):\n                break\n        print(fin)", "complexity": "cubic"}
{"src": "a = input()\nb = input()\nla = [int(x) for x in a]\nres = []\nla.sort()\nla = la[::-1]\nlb = [int(x) for x in b]\ncnt = [0] * 20\n\ndef check():\n    tres = 0\n    for x in range(len(res)):\n        tres *= 10\n        tres += int(res[x])\n    return tres <= int(b)\nif len(a) < len(b):\n    for i in range(len(la)):\n        print(la[i], end = '')\n    print()\nelse:\n    for i in range(len(la)):\n        cnt[la[i]] += 1\n    flag = 0\n    for i in range(len(lb)):\n        if flag == 0 and cnt[lb[i]]:\n            res.append(lb[i])\n            cnt[lb[i]] -= 1\n        else:\n            flag = i - 1\n            for j in range(lb[i] - 1, -1, -1):\n                if cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n                    break\n            for j in range(9, -1, -1):\n                while cnt[j]:\n                    res.append(j)\n                    cnt[j] -= 1\n            break\n    while not check():\n        temp = []\n        cnt = [0] * 20\n        for x in range(flag):\n            temp.append(res[x])\n            cnt[res[x]] -= 1\n        for i in la:\n            cnt[i] += 1\n        ##print(\"cnt = \", cnt)\n        res = temp\n        ##print(flag, res)\n        for v in range(lb[flag] - 1, -1, -1):\n            if cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n                break\n        for v in range(9, -1, -1):\n            while cnt[v]:\n                res.append(v)\n                cnt[v] -= 1\n        ##print(flag, res)\n        flag -= 1\n    for i in range(len(res)):\n        print(res[i], end = '')\n    print()", "complexity": "cubic"}
{"src": "def possible(a,index,a1,b):\n    rem = []\n    for i in range(len(a)):\n        if i != index:\n            rem.append(a[i])\n\n    a3 = a1[:]\n    rem.sort()\n    a3.append(a[index])\n    a3.extend(rem)\n    a2 = ''\n    for i in a3:\n        a2 += str(i)\n\n    if int(a2) <= b:\n        return True\n\n    return False\n\ndef main():\n    a = list(map(int,input()))\n    b = int(input())\n\n    a.sort(reverse = True)\n    a1 = []\n    for pos in range(len(a)):\n        for i in range(len(a)):\n            if possible(a,i,a1,b):\n                a1.append(a[i])\n                a.pop(i)\n                break\n            \n    for i in a1:\n        print(i,end = '')\n\nmain()\n", "complexity": "cubic"}
{"src": "from string import digits\nfrom collections import Counter\na = input()\nb = input()\nca = Counter(a)\nl = list()\nif len(b) > len(a):\n    for i in digits[::-1]:\n        if i in ca:\n            l.extend(i * ca[i])\nelse:\n    def asd(i, s):\n        if i == len(b):\n            return True\n        if s:\n            for j in digits[::-1]:\n                if j in ca and ca[j] > 0:\n                    l.extend(j * ca[j])\n            return True\n        else:\n            for j in digits[:int(b[i])+1][::-1]:\n                if j in ca and ca[j] > 0:\n                    ca[j] -= 1\n                    l.append(j)\n                    if asd(i + 1, j != b[i]):\n                        return True\n                    ca[j] += 1\n                    l.pop()\n            return False\n    asd(0, False)\nprint(\"\".join(l))\n\n       \t\t  \t \t  \t \t \t \t \t   \t\t\t", "complexity": "cubic"}
{"src": "def get(g):\n    s = [str(i) for i in g]\n    num = int(\"\".join(s))\n    return num\n\na = input()\nb = input()\nbb = int(b)\nmark = [0 for i in range(len(a))]\nc = a\nf = []\ng = []\n\nfor i in range(0 , len(a)):\n    g.append(a[i])\n\ng.sort()\ng.reverse()\nnum = get(g)\n\nindex = []\n\nif num <= bb:\n    print(num)\n    exit(0)\n\n\nfor i in range(0 , min(len(a) , len(b))):\n    mx = '-1'\n    idx = 0\n    for j in range(0 , len(a)):\n        if mark[j] == 0 and a[j] <= b[i]:\n            if a[j] > mx:\n                mx = a[j]\n                idx = j\n\n    if mx == '-1':\n        rem = []\n\n        while True and len(f) > 0:\n            ma = '-1'\n            id = 0\n            for j in range(0 , len(a)):\n                if mark[j] == 0 and a[j] < f[-1]:\n                    if a[j] > ma:\n                        ma = a[j]\n                        id = j\n\n            if ma == '-1':\n                mark[index.pop()] = 0\n                f.pop()\n                continue\n            else:\n                mark[index.pop()] = 0\n                f.pop()\n                f.append(ma)\n                mark[id] = 1\n                break\n\n        for j in range(0, len(a)):\n            if mark[j] == 0:\n                rem.append(a[j])\n\n        rem.sort()\n        rem.reverse()\n\n        for j in rem:\n            f.append(j)\n\n        print(get(f))\n        exit(0)\n\n    f.append(mx)\n    mark[idx] = 1\n    index.append(idx)\n\n    if mx < b[i] and mx != '-1':\n        break\n\nrem = []\n\nfor i in range(0 , len(a)):\n    if mark[i] == 0:\n        rem.append(a[i])\n\nrem.sort()\nrem.reverse()\nfor i in rem:\n    f.append(i)\n\nprint(get(f))", "complexity": "cubic"}
{"src": "def c(a, b, l, ans, pro):\n    if l != 0:\n        n = a[:]\n        mx = None\n        pro1 = pro\n        prosh = set()\n        for i in range(l):\n            pro = pro1\n            if a[i] == prosh:\n                continue\n            elif (a[i] <= b[0] and pro):\n                n.pop(i)\n                prosh = a[i]\n                if pro == True:\n                    if a[i] < b[0]:\n                        pro = False\n                m = c(n, b[1:], l-1, ans+str(a[i]), pro)\n                n = a[:]\n                if m != None:\n                    if mx == None:\n                        mx = int(m)\n                    elif mx < int(m):\n                        mx = int(m)\n            elif not(pro):\n                a.sort(reverse = True)\n                a = list(map(str, a))\n                return ans +''.join(a)\n            else:\n                break\n        return mx            \n    else:\n        return ans\na = input()\nb = input()\nl = len(a)\nif len(a) != len(b):\n    a = list(a)\n    a.sort()\n    print(''.join(a[::-1]))\nelse:    \n    a = list(map(int, a))\n    b = list(map(int, b))\n    a.sort()\n    n = a[:]\n    mx = 0\n    prosh = -1\n    for i in range(l):\n        if a[i] == prosh:\n            continue\n        elif a[i] != 0 and a[i] <= b[0]:\n            n.pop(i)\n            prosh = a[i]\n            pro = False\n            if a[i] == b[0]:\n                pro = True\n            m = c(n, b[1:], l-1, str(a[i]), pro)\n            n = a[:]\n            if m != None:\n                if mx < int(m):\n                    mx = int(m)\n        elif a[i] > b[0]:\n            break\n    print(mx)", "complexity": "cubic"}
{"src": "from sys import stdin\n\nrstr = lambda: stdin.readline().strip()\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\nn, m, k = rints()\na = [rstr() for _ in range(n)]\nmem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)]\n\nfor i in range(n):\n    ixs = []\n    for j in range(m):\n        if a[i][j] == '1':\n            ixs.append(j)\n\n    for j in range(k + 1):\n        tem = 0\n        if j < len(ixs):\n            tem, c = float('inf'), 0\n            for j1 in range(len(ixs) - j - 1, len(ixs)):\n                tem = min(tem, ixs[j1] - ixs[c] + 1)\n                c += 1\n\n        for j1 in range(k + 1 - j):\n            mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem)\n\nprint(mem[n][k])\n# print(mem)\n", "complexity": "cubic"}
{"src": "# from itertools import combinations\n\nCANDNUM = 5\n\nI = lambda: [int(x) for x in raw_input().split()]\nT = lambda x1, y1, x2, y2: (x1-x2)**2+(y1-y2)**2\n\t\t\t\ndef getCandidates(tsLst, curN, notSeen):\n\tr = []\n\tcurD = {}\n\tk = 0\n\tcand = None\n\tcurSet = set()\n\tfor x in tsLst:\n\t\ti, j = x\n\t\tcurSet.add(i)\n\t\tif len(curSet) == curN-1:\n\t\t\tcand = list(notSeen - curSet)[0]\n\t\t\tbreak\n\t\tcurSet.add(j)\n\t\tif len(curSet) == curN-1:\n\t\t\tcand = list(notSeen - curSet)[0]\n\t\t\tbreak\n\ti = 0\n\tfor x in tsLst:\n\t\tif cand in x:\n\t\t\tr.append(x)\n\t\t\ti += 1\n\t\t\tif i == CANDNUM:\n\t\t\t\tbreak\n\treturn r\n\ndef solve(xs, ys, n, oLst):\n\tdef solveEven(seen):\n\t\tdef solveEvenRec(notSeen, tsLst):\n\t\t\tif len(notSeen) == 0:\n\t\t\t\treturn 0, []\n\t\t\tns = tuple(notSeen)\n\t\t\tif ns in solveEvenRec.d:\n\t\t\t\treturn solveEvenRec.d[ns]\n\t\t\tminLst = []\n\t\t\tminT = 10000000\n\n\t\t\tcands = getCandidates(tsLst, len(notSeen), notSeen)\n\t\t\tfor x in cands:\n\t\t\t\ti, j = x\n\t\t\t\tnewNotSeen = notSeen.copy()\n\t\t\t\tif i in newNotSeen:\n\t\t\t\t\tnewNotSeen.remove(i)\n\t\t\t\tif j in newNotSeen:\n\t\t\t\t\tnewNotSeen.remove(j)\n\t\t\t\tnewTsLst = []\n\t\t\t\tfor x1 in tsLst:\n\t\t\t\t\ti1, j1 = x1\n\t\t\t\t\tif i1 in newNotSeen and j1 in newNotSeen:\n\t\t\t\t\t\tnewTsLst.append(x1)\n\t\t\t\trT, rLst = solveEvenRec(newNotSeen, newTsLst)\n\t\t\t\trT += ts[x]\n\t\t\t\tif rT < minT:\n\t\t\t\t\tminT = rT\n\t\t\t\t\tminLst = [x] + rLst\n\t\t\tr = minT, minLst\n\t\t\tsolveEvenRec.d[ns] = r\n\t\t\treturn r\n\t\tsolveEvenRec.d = {}\n\t\t\t\n\t\tnewLst = []\n\t\tfor i in range(n):\n\t\t\tif i not in seen:\n\t\t\t\tnewLst.append(i)\n\t\tnewN = n - len(seen)\n\t\tif newN == 2:\n\t\t\tminT = 10000000\n\t\t\tminLst = []\n\t\t\tfor a in ts:\n\t\t\t\tif ts[a] < minT:\n\t\t\t\t\tminT = ts[a]\n\t\t\t\t\tminLst = [a]\n\t\t\trT = minT\n\t\t\trLst = minLst\n\t\telse:\n\t\t\tnewTsLst = []\n\t\t\tfor x in tsLst:\n\t\t\t\ta, _ = x\n\t\t\t\ti, j = a\n\t\t\t\tif i not in seen and j not in seen:\n\t\t\t\t\tnewTsLst.append(a)\n\t\t\tnotSeen = set(range(n)) - set(seen)\n\t\t\trT, rLst = solveEvenRec(notSeen, newTsLst)\n\t\treturn rT, rLst\n\tts = {}\n\ttss = {}\n\tfor i in range(n-1):\n\t\tx1, y1 = oLst[i]\n\t\tfor j in range(i+1, n):\n\t\t\tx2, y2 = oLst[j]\n\t\t\tt = T(x1, y1, x2, y2)\n\t\t\tt1 = T(x1, y1, xs, ys)\n\t\t\tt2 = T(xs, ys, x2, y2)\n\t\t\tif t1+t2 >= t:\n\t\t\t\tts[(i, j)] = t\n\t\t\t\ttss[(i, j)] = True\n\t\t\telse:\n\t\t\t\tts[(i, j)] = t1+t2\n\t\t\t\ttss[(i, j)] = False\n\ttsLst = []\n\tfor x in ts:\n\t\ttsLst.append((x, ts[x]))\n\ttsLst.sort(key=lambda x:x[1])\n\tif n%2:\n\t\tif n > 1:\n\t\t\tresT = 10000000\n\t\t\tresLst = []\n\t\t\tfor i in range(n):\n\t\t\t\tx, y = oLst[i]\n\t\t\t\tt = 2*T(x, y, xs, ys)\n\t\t\t\trT, rLst = solveEven([i])\n\t\t\t\tfor a in rLst:\n\t\t\t\t\ti1, i2 = a\n\t\t\t\t\tx1, y1 = oLst[i1]\n\t\t\t\t\tx2, y2 = oLst[i2]\n\t\t\t\t\trT += T(xs, ys, x1, y1)\n\t\t\t\t\trT += T(xs, ys, x2, y2)\n\t\t\t\trT += t\n\t\t\t\tif rT < resT:\n\t\t\t\t\tresT = rT\n\t\t\t\t\tnewRLst = ['0']\n\t\t\t\t\tfor a in rLst:\n\t\t\t\t\t\tw, v = a\n\t\t\t\t\t\tif tss[(w, v)]:\n\t\t\t\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\tnewRLst.append(str(i+1))\n\t\t\t\t\tnewRLst.append('0')\n\t\t\t\t\tresLst = newRLst\n\t\telse:\n\t\t\tx, y = oLst[0]\n\t\t\tresT = 2*T(x, y, xs, ys)\n\t\t\tresLst = ['0', '1', '0']\n\telse:\n\t\tresT, rLst = solveEven([])\n\t\tfor a in rLst:\n\t\t\ti1, i2 = a\n\t\t\tx1, y1 = oLst[i1]\n\t\t\tx2, y2 = oLst[i2]\n\t\t\tresT += T(xs, ys, x1, y1)\n\t\t\tresT += T(xs, ys, x2, y2)\n\t\tnewRLst = ['0']\n\t\tfor a in rLst:\n\t\t\tw, v = a\n\t\t\tif tss[(w, v)]:\n\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\tnewRLst.append('0')\n\t\t\telse:\n\t\t\t\tnewRLst.append(str(w+1))\n\t\t\t\tnewRLst.append('0')\n\t\t\t\tnewRLst.append(str(v+1))\n\t\t\t\tnewRLst.append('0')\n\t\tresLst = newRLst\n\treturn resT, resLst\n\nxs, ys = I()\nn = input()\noLst = []\nfor _ in range(n):\n\tx, y = I()\n\toLst.append((x, y))\nresT, resLst = solve(xs, ys, n, oLst)\nprint(resT)\nprint(' '.join(resLst))\t", "complexity": "exponential"}
{"src": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0.0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nget_bit = lambda x, i: (x >> i) & 1\n\nn = int(input())\na, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1\n\nif n == 1:\n    exit(print(1))\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        masks[big ^ (1 << j)] += a[i][j]\n        masks[big ^ (1 << i)] += a[j][i]\n\nfor _ in range(2, n):\n    tem = dict()\n    for msk in masks:\n        for bit in range(18):\n            if get_bit(msk, bit):\n                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]\n    masks = tem\n\nsu = sum(masks.values())\nprint(*[masks[1 << i] / su for i in range(n)])\n", "complexity": "exponential"}
{"src": "s1 = input()\ns2 = input()\n\nobjetivo = s1.count(\"+\") - s1.count(\"-\")\ninicio = s2.count(\"+\") - s2.count(\"-\")\nincognitos = s2.count(\"?\")\ndistancia = objetivo - inicio\n\ndef factorial(n):\n    total = 1\n    for i in range(int(n)):\n        total *= (i + 1)\n    return total\n\nif abs(distancia) > incognitos or distancia % 2 != incognitos % 2:\n    print(0)\nelse:\n    mas = (distancia + incognitos) / 2\n    menos = (incognitos - distancia) / 2\n    print((factorial(incognitos)/(factorial(mas)*factorial(menos)))/2**incognitos)\n", "complexity": "exponential"}
{"src": "\"\"\"\n\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\n\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551    \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551\u255a\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2550\u2550\u2550\u2588\u2588\u2551\n\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n\u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d\n\"\"\"\nfrom math import factorial as f\nn = input()\ns = input()\nquest = s.count(\"?\")\nplusn = n.count(\"+\")\nplus = s.count(\"+\")\ntry:\n\tcomb = f(quest)/(f(plusn - plus) * f(quest - (plusn - plus)))\n\tprint(\"%.12f\" %(comb/2 ** quest))\nexcept:\n\tprint(\"%.12f\" %0)\n", "complexity": "exponential"}
{"src": "from math import factorial\nf=lambda:input()\na=f()\nb=f()\ns=0\ns1=0\nc=0\nfor i in a:\n    if i=='+':\n       s+=1\n    else:\n       s-=1\nfor i in b:\n    if i=='+':\n       s1+=1\n    elif i=='-':\n       s1-=1\n    else:\n       c+=1\nif c==0:\n    if s==s1:\n        print(c+1)\n    else:\n        print(c)\nelse:\n    l=[]\n    k=c\n    i=c\n    j=0\n    while i>=0:\n        l.append(k)\n        i-=1\n        j+=1\n        k=0\n        k+=i\n        k-=j\n    if s1!=0:\n        for i in range(len(l)):\n            l[i]+=s1\n    try:\n        c1=l.index(s)\n        k=factorial(c)/(factorial(c-c1)*factorial(c1))\n        print(k/pow(2,c))\n    except:\n        print(0.0)", "complexity": "exponential"}
{"src": "import math\n\nsent = input()\nreceived = input()\n\nsp = sent.count('+')\nsm = sent.count('-')\nrp = received.count('+')\nrm = received.count('-')\nquest = received.count('?')\n# Then deal with the ? message\ndist = sp - rp\n\nif dist < 0 or dist > quest:\n    print(0)\nelif dist == 0 and quest == 0:\n    print(1)\nelse:\n    total = 2 ** quest\n    possible = math.factorial(quest) / math.factorial(dist) / math.factorial(quest-dist)\n    print(possible/total)\n", "complexity": "exponential"}
{"src": "import math\ns1 = input().strip()\ns2 = input().strip()\nps1 = 0\nms1 = 0\nps2 = 0\nms2 = 0\nqs2 = 0\nfor i in s1:\n    if i=='+':\n        ps1+=1\n    if i=='-':\n        ms1+=1\nfor i in s2:\n    if i=='+':\n        ps2+=1\n    if i=='-':\n        ms2+=1\n    if i == '?':\n        qs2+=1\nif ps2<=ps1 and ms2<=ms1:\n    print(math.factorial(qs2)/math.factorial(ps1-ps2)/math.factorial(ms1-ms2)*(0.5**qs2))\nelse:\n    print(0.00000000)", "complexity": "exponential"}
{"src": "import math\ns1=input()\ns2=input()\nif(s2.count('?')==0):\n    if(s1.count('+')==s2.count('+') and s1.count('-')==s2.count('-')):\n        p=1\n    else:\n        p=0\nelse:\n    if((s1.count('+')< s2.count('+')!=0) or (s1.count('-')==0<s2.count('-')!=0)):\n        p=0\n    else:\n        pl=s1.count('+')-s2.count('+')\n        mi=s1.count('-')-s2.count('-')\n        p=(math.factorial((pl+mi))/math.factorial(pl)/math.factorial(mi))/2**(pl+mi)\nprint('%1.9f'%p)", "complexity": "exponential"}
{"src": "import sys\nimport math\ninput=sys.stdin.readline\na=list(input())\nb=list(input())\nx=a.count('+')-b.count('+')\ny=a.count('-')-b.count('-')\nif x<0 or y<0:\n    print(0)\nelse:\n    fact=math.factorial(x+y)/(math.factorial(x)*math.factorial(y))\n    total=2**(x+y)\n    print(fact/total)\n\n\t\t\t \t    \t  \t  \t\t    \t   \t \t  \t", "complexity": "exponential"}
{"src": "n = int(input())\nt = [0 for i in range(2000)]\nc = [0 for i in range(2000)]\nfor i in range(n) :\n    x = int(input())\n    r = 0\n    ok = False\n    for j in range(2000) :\n        if x >> j & 1 :\n            if t[j] != 0 :\n                x ^= t[j]\n                r ^= c[j]\n            else :\n                t[j] = x\n                c[j] = r ^ (1 << i)\n                ok = True\n                break\n    if ok :\n        print(0)\n        continue\n    a = []\n    for j in range(2000) :\n        if r >> j & 1 :\n            a.append(j)\n    print(len(a))\n    for y in a :\n        print(y)\n                ", "complexity": "exponential"}
{"src": "import sys, os\n\nnumbs = [int(x) for x in sys.stdin.buffer.read().split()]\nn = numbs.pop(0)\n\nbase = []\nout = []\n\nfor i in range(n):\n    x = numbs[i]\n    how = 0\n    \n    for b,rep in base:\n        if x.bit_length() == b.bit_length():\n            x ^= b\n            how ^= rep\n    \n    if x:\n        how |= 1 << i\n\n        a = 0\n        b = len(base)\n        while a < b:\n            c = a + b >> 1\n            if base[c][0] > x:\n                a = c + 1\n            else:\n                b = c\n        base.insert(a, (x, how))\n    \n        out.append(0)\n    else:\n        outind = len(out)\n        out.append(-1)\n        \n        y = bin(how).encode('ascii')\n        ylen = len(y)\n        for i in range(2,len(y)):\n            if y[i] == 49:\n                out.append(ylen - 1 - i)\n        out[outind] = len(out) - 1 - outind\n\nos.write(1, b'\\n'.join(str(x).encode('ascii') for x in out))\n", "complexity": "exponential"}
{"src": "import sys, os\n \nnumbs = [int(x) for x in sys.stdin.buffer.read().split()]\nn = numbs.pop(0)\n \nbase = []\nout = []\n \nfor i in range(n):\n    x = numbs[i]\n    how = 0\n    \n    for b,rep in base:\n        if x.bit_length() == b.bit_length():\n            x ^= b\n            how ^= rep\n    \n    if x:\n        how |= 1 << i\n \n        a = 0\n        b = len(base)\n        while a < b:\n            c = a + b >> 1\n            if base[c][0] > x:\n                a = c + 1\n            else:\n                b = c\n        base.insert(a, (x, how))\n    \n        out.append(0)\n    else:\n        outind = len(out)\n        out.append(-1)\n        \n        y = bin(how).encode('ascii')\n        ylen = len(y)\n        for i in range(2,len(y)):\n            if y[i] == 49:\n                out.append(ylen - 1 - i)\n        out[outind] = len(out) - 1 - outind\n \nos.write(1, b'\\n'.join(str(x).encode('ascii') for x in out))", "complexity": "exponential"}
{"src": "import sys\nfrom math import gcd\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\nn=int(input())\nl=list(map(int,input().split()))\nc=list(map(int,input().split()))\ndp=dict()\nfor i in range(n):\n    if dp.get(l[i]):\n        dp[l[i]]=min(dp[l[i]],c[i])\n    else:\n        dp[l[i]]=c[i]\nfor ll in l:\n    keys=list(dp.keys())\n    for j in keys:\n        g=gcd(j,ll)\n        if dp.get(g):\n            dp[g]=min(dp[g],dp[ll]+dp[j])\n        else:\n            dp[g]=dp[ll]+dp[j]\nif 1 in dp:\n    print(dp[1])\nelse:\n    print(-1)", "complexity": "exponential"}
{"src": "from collections import defaultdict\nfrom math import gcd\nn = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndp = defaultdict(lambda: float(\"inf\"))\nfor a, b in zip(A, B):\n    dp[a] = min(dp[a], b)\n    for d in dp.copy():\n        cur = gcd(a, d)\n        dp[cur] = min(dp[cur], dp[a] + dp[d])\nif 1 not in dp:\n    print(-1)\nelse:\n    print(dp[1])", "complexity": "exponential"}
{"src": "def main():\n    input()\n    acc = {0: 0}\n    for p, c in zip(list(map(int, input().split())),\n                    list(map(int, input().split()))):\n        adds = []\n        for b, u in acc.items():\n            a = p\n            while b:\n                a, b = b, a % b\n            adds.append((a, u + c))\n        for a, u in adds:\n            acc[a] = min(u, acc.get(a, 1000000000))\n    print(acc.get(1, -1))\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n# Made By Mostafa_Khaled", "complexity": "exponential"}
{"src": "# from math import *\nfrom itertools import combinations\nfrom sys import stdin\ninput = stdin.readline\nintin = lambda: map(int, input().split())\n\nn, l, r, x = intin()\n*a, = intin()\nprint(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))", "complexity": "exponential"}
{"src": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun May 26 12:02:26 2019\n\n@author: avina\n\"\"\"\n\nN,L,H,d = map(int, input().split())\n\nl = list(map(int, input().split()))\ne = 0\nfor i in range(1 << N ):\n    k = []\n    for j in range(N):\n        if i >> j & 1:\n            k.append(l[j])\n    if len(k)>0:\n        maz = max(k)\n        mins = min(k)\n        sums = sum(k)\n        if sums >= L and sums <=H:\n            if maz - mins >=d:\n                e+=1\nprint(e)", "complexity": "exponential"}
{"src": "kk=lambda:map(int, input().split())\nll=lambda:list(kk())\nn,l,r,d=kk()\np,t=ll(),0\nfor v in range(2**n):\n\ts = []\n\tfor i in range(n):\n\t\tif v&(2**i):\n\t\t\ts.append(p[i])\n\tif l <= sum(s)<=r and max(s)-min(s) >= d: t+=1\nprint(t)", "complexity": "exponential"}
{"src": "from itertools import combinations\n \nn,l,r,x = map(int,input().split())\na=list(map(int,input().split()))\n \nc=[]\nfor i in range(2,n+1):\n\tc+=list(combinations(a,i))\n \ncnt=0\n \nfor t in c:\n\tm=min(t)\n\tM=max(t)\n\ts=sum(t)\n\tif M-m >=x and (s>=l and s<=r):\n\t\tcnt+=1\n \nprint(cnt)", "complexity": "exponential"}
{"src": "'''\n    Author: Ken\n    Date: 2020-02-06\n    Problems: 550B\n'''\nimport sys\n\nn, l, r, x = map(int, input().split())\ntemp = []\ntemp = list(map(int, input().split()))\n\ntemp.sort()\nans = 0\n\nfor i in range(1 << n):\n    score = 0\n    _min = sys.maxsize\n    _max = -sys.maxsize\n    for j in range(n):\n        if i & (1 << j) > 0:\n            _min = min(_min, temp[j])\n            _max = max(_max, temp[j])\n            score += temp[j]\n    if score >= l and score <= r and _max-_min >= x:\n        ans += 1\n\nprint(ans)\n", "complexity": "exponential"}
{"src": "n, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\n\nfrom itertools import combinations\nways_to_choose = 0\nfor length in range(2, n + 1):\n    for p in combinations(c, length):\n        problemset = sorted(p)\n        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:\n            ways_to_choose += 1\n\nprint(ways_to_choose)\n", "complexity": "exponential"}
{"src": "from itertools import combinations as cmb\nn ,l ,r ,x = map(int , input().split())\n*a , = map(int ,input().split())\nb = []\na.sort()\nfor i in range(2 ,n+1):\n    b.extend(cmb(a ,i))\nans = 0\nfor i in b:\n    # i1 = sorted(i)\n    if(sum(i) >= l and sum(i) <= r):\n        if(i[-1]-i[0] >= x):\n            # print(i)\n            ans+=1\n            \nprint(ans)", "complexity": "exponential"}
{"src": "n,l,r,x = map(int,input().split())\nA = list(map(int,input().split()))\ncount = 0\nfor i in range(1<<n):\n    total = 0\n    mn = 1e6\n    mx = -1e6\n    for k in range(n):\n        if (i & (1<<k)):\n            total += A[k]\n            mn = min(A[k],mn)\n            mx = max(A[k],mx)\n    if total<=r and total>=l and mx-mn>=x:\n        count += 1\nprint(count)", "complexity": "exponential"}
{"src": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\ndef ok(a,b,c):\n\n    # print(a[0],b,c)\n\n    n = a[0][-1]\n    ans = []\n    for i in range(a[0][0]): ans.append([a[1]]*n)\n\n    l = n\n    r = n - a[0][0]\n\n    for i in range(2):\n        for j in range(2):\n\n            l1,r1 = b[0]\n            l2,r2 = c[0]\n\n            if(i): l1,r1 = r1,l1\n            if(j): l2,r2 = r2,l2\n\n            if(l1 == l):\n                if(l2 != l or r1 + r2 != r): continue\n\n                for k in range(r1): ans.append([b[1]]*n)\n                for k in range(r2): ans.append([c[1]]*n)\n                return ans\n\n\n            if(l1 == r):\n                if(l2 != r or r1 + r2 != l): continue\n\n                for k in range(r): ans.append( [b[1]]*r1 + [c[1]]*r2)\n                return ans\n\n    return False\n\n\nl1,r1,l2,r2,l3,r3 = value()\n\na = [sorted((l1,r1)),'A']\nb = [sorted((l2,r2)),'B']\nc = [sorted((l3,r3)),'C']\n\nA = ok(a,b,c)\nB = ok(b,a,c)\nC = ok(c,a,b)\n\nif(A):\n    print(len(A))\n    for i in A: print(*i,sep=\"\")\nelif(B): \n    print(len(B))\n    for i in B: print(*i,sep=\"\")\nelif(C):\n    print(len(C))\n    for i in C: print(*i,sep=\"\")\nelse: \n    print(-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "complexity": "exponential"}
{"src": "import math\ntemp=list(map(int,input().split()))\nN,q=temp[0],temp[1]\nfor j in range(0,q):\n    u=int(input())\n    S=input()\n    k=(N+1)//2\n    n=int(math.log((N+1),10)/math.log(2,10))-1\n    dup_n=n\n    store=[k]\n    while u!=k:\n        n-=1\n        if u>k:\n            k+=2**(n)\n        else:\n            k-=2**(n)\n        store.append(k)\n    for i in range(0,len(S)):\n        if S[i]=='R':\n            n-=1\n            if n==-1:\n                n=0\n                continue\n            k+=2**(n)\n        elif S[i]=='L':\n            n-=1\n            if n==-1:\n                n=0\n                continue\n            k-=2**(n)\n        else:\n            if n==dup_n:\n                continue\n            store.pop()\n            k=store[len(store)-1]\n            n+=1\n            continue\n        store.append(k)\n            \n    print(k)", "complexity": "exponential"}
{"src": "# Code by Sounak, IIESTS\n# ------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n# sys.setrecursionlimit(300000)\n# threading.stack_size(10**8)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------------------------------------------------------------\n# mod = 9223372036854775807\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\nclass SegmentTree1:\n    def __init__(self, data, default=10 ** 6, func=lambda a, b: min(a, b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\nMOD = 10 ** 9 + 7\n\n\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\nmod = 10 ** 9 + 7\nomod = 998244353\n# -------------------------------------------------------------------------\nprime = [True for i in range(10)]\npp = [0] * 10\n\n\ndef SieveOfEratosthenes(n=10):\n    p = 2\n    c = 0\n    while (p * p <= n):\n\n        if (prime[p] == True):\n            c += 1\n            for i in range(p, n + 1, p):\n                pp[i] += 1\n                prime[i] = False\n        p += 1\n\n\n# ---------------------------------Binary Search------------------------------------------\ndef binarySearch(arr, n, key):\n    left = 0\n    right = n - 1\n    res = -1\n    while (left <= right):\n        mid = (right + left) // 2\n        if (arr[mid] >= key):\n            res = arr[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    return res\ndef binarySearch1(arr, n, key):\n    left = 0\n    right = n - 1\n    res = -1\n    while (left <= right):\n        mid = (right + left) // 2\n        if (arr[mid]>=key):\n            right = mid - 1\n        else:\n            res = arr[mid]\n            left = mid + 1\n    return res\n\n\n# ---------------------------------running code------------------------------------------\nn,k=map(int,input().split())\nprev=defaultdict(int)\nfor ik in range(k):\n    cur=int(input())\n    s=list(input())\n    t=2\n    while(cur%t==0):\n        t*=2\n    t//=4\n    for i in range(len(s)):\n        if cur==(n+1)//2:\n            if s[i]=='U':\n                continue\n            else:\n                if s[i]=='L':\n                    cur-=t\n                else:\n                    cur+=t\n                t//=2\n        elif cur%2==1:\n            if s[i]==\"U\":\n                if cur&2==0:\n                    cur+=1\n                else:\n                    cur-=1\n                t=1\n        else:\n            if s[i] == 'L':\n                cur-=t\n                t//=2\n            elif s[i]==\"U\":\n                if cur&t*4==0:\n                    cur+=t*2\n                else:\n                    cur-=t*2\n                t*=2\n            else:\n                cur+=t\n                t//=2\n    print(cur)\n\n\n", "complexity": "exponential"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nmod = pow(10, 9) + 7\na = list(map(int, input().split()))\nl = 100000\ncnt = [0] * (l + 1)\nfor i in a:\n    cnt[i] += 1\npow2 = [1]\nfor _ in range(l):\n    pow2.append(2 * pow2[-1] % mod)\nans = pow2[n] - 1\nx = [-1] * (l + 1)\nfor i in range(2, l + 1):\n    c = cnt[i]\n    xi = x[i]\n    for j in range(2 * i, l + 1, i):\n        c += cnt[j]\n        x[j] -= xi\n    ans += xi * (pow2[c] - 1) % mod\n    ans %= mod\nprint(ans)", "complexity": "exponential"}
{"src": "n=input()\nL=list(map(int,raw_input().split(' ')))\nD=[0]*101000\nmod=10**9+7\nitt=[0]*101000\np=[0]*100010\nD[0]=1\nfor i in range(100010):\n  D[i+1]=(D[i]*2)%mod\nfor i in range(n):\n  itt[L[i]]+=1 \nfor i in range(1,100001):\n  for j in range(i*2,100001,i):\n    itt[i]+=itt[j]\n  p[i]=(D[itt[i]]+mod-1)%mod\ni=100000\nwhile i>=1:\n  for j in range(i*2,100001,i):\n    p[i]-=p[j]\n  p[i]=(p[i]%mod+mod)%mod\n  i-=1\nprint(p[1])", "complexity": "exponential"}
{"src": "def main():\n    n, k = map(int, input().split(' '))\n\n    if(k > 2*n): \n        return(0)\n    if(k == 2*n or k==1): \n        return(2)\n\n    iguales = [0]*(k+1)\n    diferentes = [0]*(k+1)\n\n    iguales[1] = 2\n    diferentes[2] = 2\n\n    modulo = 998244353\n\n    for i in range(1, n):\n        auxigual, auxdiff = [0]*(k+1), [0]*(k+1)\n        for j in range(k):\n            auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo\n            if(j >= 1):\n                auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo\n        \n        iguales = auxigual\n        diferentes = auxdiff\n\n    return((iguales[-1] + diferentes[-1]) % modulo)\n\nprint(main())", "complexity": "exponential"}
{"src": "n,k = [int(x) for x in input().split()]\ndp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)]\ndp[1][2][0] = 1\ndp[1][2][1] = 1\ndp[1][1][2] = 1\ndp[1][1][3] = 1\n\n\n\nfor n1 in range(1,n):\n    for k1 in range(1,k+1):\n        \n        dp[0][k1][0] = dp[1][k1][0]\n        dp[0][k1][1] = dp[1][k1][1]\n        dp[0][k1][2] = dp[1][k1][2]\n        dp[0][k1][3] = dp[1][k1][3]\n        \n        dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353 \n        \n        dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353 \ntotal = 0\n#print(dp)\nfor i in range(4):\n    total += dp[1][k][i] % 998244353 \n#print(dp)\nprint(total% 998244353 )\n        \n        \n                        \n", "complexity": "exponential"}
{"src": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nfrom collections import defaultdict\nfrom itertools import permutations\n \n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now-----------------------------------------------------\nn,k=map(int,sys.stdin.readline().split())\n \nmod=998244353\ndp=[[0,0,0,0] for x in range(k+3)]\ndp[1][0]=1\ndp[1][1]=1\ndp[2][2]=1\ndp[2][3]=1\nnewdp=[[0,0,0,0] for x in range(k+3)]\nfor i in range(n-1):\n    \n    for j in range(k+1):\n        newdp[j+1][1]+=dp[j][0]\n        newdp[j+1][3]+=dp[j][0]\n        newdp[j+1][2]+=dp[j][0]\n        newdp[j][0]+=dp[j][0]\n        newdp[j][1]+=dp[j][1]\n        newdp[j+1][3]+=dp[j][1]\n        newdp[j+1][2]+=dp[j][1]\n        newdp[j+1][0]+=dp[j][1]\n        newdp[j][1]+=dp[j][2]\n        newdp[j+2][3]+=dp[j][2]\n        newdp[j][2]+=dp[j][2]\n        newdp[j][0]+=dp[j][2]\n        newdp[j][1]+=dp[j][3]\n        newdp[j][3]+=dp[j][3]\n        newdp[j+2][2]+=dp[j][3]\n        newdp[j][0]+=dp[j][3]\n        \n        for a in range(3):\n            for b in range(4):\n                newdp[a+j][b]%=mod\n    for a in range(k+3):\n        for b in range(4):\n            dp[a][b]=newdp[a][b]\n            newdp[a][b]=0\nans=sum(dp[k])\nans%=mod\nprint(ans)", "complexity": "exponential"}
{"src": "from sys import stdin\n\nadd = lambda a, b: (a + b) % mod\nmod, bits = 998244353, ['00', '01', '10', '11']\npat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]\n\nn, k = map(int, stdin.readline().split())\nmem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]\n\nfor i in range(4):\n    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)\n    if val <= k:\n        mem[0][val][i] = 1\n\nfor i in range(1, n):\n    for j in range(1, k + 1):\n        for k1 in range(4):\n            for k2 in range(4):\n                val = j + pat[k1][k2]\n                if val <= k:\n                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])\n\nprint(sum(mem[-1][k]) % mod)\n", "complexity": "exponential"}
{"src": "import sys\nfrom array import array  # noqa: F401\nfrom typing import List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef solve(i, n, delta, delta2):\n    inf = 2 * 10**9\n    dp = [[-1] * n for _ in range(1 << n)]\n    dp[(1 << i)][i] = inf\n    stack = [(1 << i, i)]\n\n    for t in range(1, n + 1):\n        next_s = []\n        for bit, v in stack:\n            for dest in range(n):\n                if (1 << dest) & bit:\n                    continue\n                if dp[bit | (1 << dest)][dest] == -1:\n                    next_s.append((bit | (1 << dest), dest))\n                dp[bit | (1 << dest)][dest] = max(dp[bit | (1 << dest)][dest], min(dp[bit][v], delta[v][dest]))\n\n        stack = next_s\n\n    return max(min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j)\n\n\ndef main():\n    n, m = map(int, input().split())\n    matrix = [tuple(map(int, input().split())) for _ in range(n)]\n\n    if n == 1:\n        print(min(abs(x - y) for x, y in zip(matrix[0], matrix[0][1:])))\n        exit()\n\n    delta = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            delta[i][j] = delta[j][i] = min(abs(x - y) for x, y in zip(matrix[i], matrix[j]))\n    delta2 = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            delta2[i][j] = min((abs(x - y) for x, y in zip(matrix[i], matrix[j][1:])), default=2 * 10**9)\n\n    print(max(solve(i, n, delta, delta2) for i in range(n)))\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "exponential"}
{"src": "def popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\nN, T = map(int, input().split())\nTG = [list(map(int, input().split())) for _ in range(N)]\nmod = 10**9+7\n\n\ndp = [[0]*(2**N) for _ in range(4)]\nfor i in range(1, 4):\n    dp[i][0] = 1\n\nfor S in range(2**N):\n    if popcount(S) == 1:\n        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1\n    for i in range(1, 4):\n        for j in range(N):\n            if S & (2**j) or i == TG[j][1]:\n                continue\n            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod\n\ntable = [0]*(2**N)\nfor S in range(2**N):\n    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)\n    \nans = 0\nfor S in range(2**N):\n    if table[S] == T:\n        for i in range(1, 4):\n            ans = (ans + dp[i][S]) % mod\n\nprint(ans)", "complexity": "exponential"}
{"src": "from itertools import combinations\n\ndef findsum(comb):\n    sum = 0\n    for song in comb:\n        sum += song[0]\n    return sum\n\ndef finda(a,b,c):\n    if a == 0:\n        return 0\n    if a == 1 and b == 0 and c == 0:\n        return 1\n    else:\n        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))\n\ndef findb(a,b,c):\n    if b == 0:\n        return 0\n    if b == 1 and a == 0 and c == 0:\n        return 1\n    else:\n        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))\n\ndef findc(a,b,c):\n    if c == 0:\n        return 0\n    if c == 1 and a == 0 and b == 0:\n        return 1\n    else:\n        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))\n\n\n\nn, T = map(int,input().split())\nsongs = []\ntotal_combinations = 0\nfor i in range(n):\n    t, g = map(int,input().split())\n    songs.append([t,g])\n\nfor i in range(1, n+1):\n    allcomb = list(combinations(songs,i))\n    for comb in allcomb:\n        sum = findsum(comb)\n\n        if sum == T:\n            a = 0\n            b = 0\n            c = 0\n            for song in comb:\n                if song[1] == 1:\n                    a += 1\n                elif song[1] == 2:\n                    b += 1\n                else:\n                    c += 1\n            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)\ntotal_combinations = total_combinations%1000000007\nprint(total_combinations)", "complexity": "exponential"}
{"src": "rnd_mod = 1234567890133\nrnd_x = 987654321098\ndef rnd():\n    global rnd_x\n    rnd_x = rnd_x**2 % rnd_mod\n    return (rnd_x>>5) % (1<<20)\ndef randrange(a):\n    return rnd() % a\n\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    X = []\n    for __ in range(N):\n        X.append([int(a) for a in input().split()])\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    for t in range(577):\n        for i in range(M):\n            a = randrange(N)\n            Y[i] = [Y[i][j-a] for j in range(N)]\n        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))\n    print(ma)\n", "complexity": "exponential"}
{"src": "for _ in range(int(input())):\n    N, M = map(int, input().split())\n    X = [[int(a) for a in input().split()] for _ in range(N)]\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    dp = [[0] * (1<<N) for _ in range(M+1)]\n    for j in range(M):\n        for mask in range(1<<N):\n            maskpre = mask\n            while maskpre >= 0:\n                maskpre &= mask\n                ma = 0\n                for k in range(N):\n                    s = 0\n                    for i in range(N):\n                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:\n                            s += X[i-k][j]\n                    ma = max(ma, s)\n                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)\n                \n                maskpre -= 1\n    print(dp[-1][-1])\n    ", "complexity": "exponential"}
{"src": "MAX=10**9 #O((n*m+(2**m)**2)*log(MAX))\ndef main():\n    \n    n,m=readIntArr()\n    arrs=[]\n    for _ in range(n):\n        arrs.append(readIntArr())\n    \n    def checkPossible(minB):\n        binRepresentations=set()\n        for arr in arrs:\n            binRepresentations.add(convertToBinary(arr,minB))\n        binList=list(binRepresentations)\n        ii=jj=-1\n        n=len(binList)\n        for i in range(n):\n            for j in range(i,n):\n                if binList[i]|binList[j]==(1<<m)-1: #ok\n                    ii=binList[i]\n                    jj=binList[j]\n        if ii!=-1: #ok\n            ansi=ansj=-1\n            for i in range(len(arrs)):\n                b=convertToBinary(arrs[i],minB)\n                if b==ii:\n                    ansi=i\n                if b==jj:\n                    ansj=i\n            # print('ii:{} jj:{}'.format(ii,jj))\n            # print('ok minB:{} ansi:{} ansj:{}'.format(minB,ansi,ansj))\n            return (ansi,ansj)\n        else:\n            return None\n                    \n    def convertToBinary(arr,minB):\n        b=0\n        for i in range(m):\n            if arr[i]>=minB:\n                b|=(1<<i)\n        return b\n    \n    minB=-1\n    i=j=-1\n    b=MAX\n    while b>0:\n        temp=checkPossible(minB+b)\n        if temp==None: #cannot\n            b//=2\n        else: #can\n            minB+=b\n            i,j=temp\n    i+=1;j+=1\n    print('{} {}'.format(i,j))\n    \n    return\n    \nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(*args):\n    \"\"\"\n    *args : (default value, dimension 1, dimension 2,...)\n    \n    Returns : arr[dim1][dim2]... filled with default value\n    \"\"\"\n    assert len(args) >= 2, \"makeArr args should be (default value, dimension 1, dimension 2,...\"\n    if len(args) == 2:\n        return [args[0] for _ in range(args[1])]\n    else:\n        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]\n \ndef queryInteractive(x,y):\n    print('? {} {}'.format(x,y))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n \nfor _abc in range(1):\n    main()", "complexity": "exponential"}
{"src": "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nmask = (1 << m) - 1\n\nl = []\nfor i in range(n):\n    l.append(list(map(int,input().split())))\n\nlo = -1 #Possible\nhi = 10 ** 9 + 1 #Impossible\nwhile hi - lo > 1:\n    test = (hi + lo) // 2\n\n    things = dict()\n    for i in range(n):\n        curr = 0\n        for v in l[i]:\n            curr *= 2\n            if v >= test:\n                curr += 1\n        things[curr] = i\n\n    works = False\n    for v1 in things:\n        for v2 in things:\n            if v1 | v2 == mask:\n                outi = things[v1]\n                outj = things[v2]\n                works = True\n                break\n        if works:\n            break\n\n    if works:\n        lo = test\n    else:\n        hi = test\n\nprint(outi + 1, outj + 1)\n", "complexity": "exponential"}
{"src": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef bisearch_max(mn, mx, func):\n\n    ok = mn\n    ng = mx\n    while ok+1 < ng:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef check(m):\n    ok = [0] * N\n    S = set()\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] >= m:\n                ok[i] |= 1<<j\n        S.add(ok[i])\n    full = (1<<M) - 1\n    for bit1 in range(1<<M):\n        for bit2 in range(bit1, 1<<M):\n            if bit1 in S and bit2 in S:\n                if bit1 | bit2 == full:\n                    return True\n    return False\n\nN, M = MAP()\nA = [None] * N\nfor i in range(N):\n    A[i] = LIST()\n\nres = bisearch_max(0, 10**9+1, check)\nok = [0] * N\nS = set()\nD = {}\nfor i in range(N):\n    for j in range(M):\n        if A[i][j] >= res:\n            ok[i] |= 1<<j\n    S.add(ok[i])\n    D[ok[i]] = i + 1\nfull = (1<<M) - 1\nfor bit1 in range(1<<M):\n    for bit2 in range(bit1, 1<<M):\n        if bit1 in S and bit2 in S:\n            if bit1 | bit2 == full:\n                print(D[bit1], D[bit2])\n                exit()\n", "complexity": "exponential"}
{"src": "import os, sys, atexit\nfrom io import BytesIO, StringIO\n \ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n_OUTPUT_BUFFER = StringIO()\nsys.stdout = _OUTPUT_BUFFER\n \n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nn, m = map(int, input().split())\narr = [0] * n\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    arr[i] = temp\nx = 1\nN = 2 ** m - 1\nlo = 1\nhi = 1000000009\nind = [0, 0]\nwhile 1:\n    l = {}\n    freq = [0] * (2 ** m)\n    for i in range(n):\n        an = 0\n        for j in range(m):\n            if arr[i][j] >= x: an += 2 ** (m - j - 1)\n        if freq[an] == 0:\n            l[i] = an\n        freq[an] = 1\n    # print(l)\n    ch = 0\n    for k1, v1 in l.items():\n        for k2, v2 in l.items():\n            # if v1 == v2: continue\n            if v1 | v2 == N:\n                ch = 1\n                ind[0] = k1 + 1\n                ind[1] = k2 + 1\n                # print(x)\n                break\n        if ch: break\n    if ch:\n        lo = x\n        x = x * 2\n    else:\n        hi = x\n        break\nans = lo\nwhile hi - lo > 1:\n    x = (lo + hi) // 2\n    l = {}\n    freq = [0] * (2 ** m)\n    for i in range(n):\n        an = 0\n        for j in range(m):\n            if arr[i][j] >= x: an += 2 ** (m - j - 1)\n        if freq[an] == 0:\n            l[i] = an\n        freq[an] = 1\n    # print(l)\n    ch = 0\n    for k1, v1 in l.items():\n        for k2, v2 in l.items():\n            # if v1 == v2: continue\n            if v1 | v2 == N:\n                ch = 1\n                ind[0] = k1 + 1\n                ind[1] = k2 + 1\n                # print(x)\n                break\n        if ch: break\n    if ch:\n        lo = x\n    else:\n        hi = x\nans = lo\n# print(ans)\nif ind[0] == 0: print(\"1 1\")\nelse: print(*ind)", "complexity": "exponential"}
{"src": "# based on solution by @conqueror_of_tourist\nimport sys\n\nreader = (map(int, line.split()) for line in sys.stdin)\ninput = reader.__next__\n\nn, m = input()\narrays = []\nfor i in range(n):\n    arrays.append(list(input()))\n\nfull = (1 << m) - 1\nL = -1\nR = 10 ** 9 + 1\nwhile L + 1 < R:\n    check = (L + R) >> 1\n    \n    masks = {}\n    for i, arr in enumerate(arrays):\n        curr = 0\n        for val in arr:\n            curr <<= 1\n            if val >= check:\n                curr |= 1\n        masks[curr] = i\n    \n    isValid = False\n    for k1 in masks:\n        for k2 in masks:\n            if k1 | k2 == full:\n                ans0 = masks[k1]\n                ans1 = masks[k2]\n                isValid = True\n                break\n        if isValid:\n            break\n    \n    if isValid:\n        L = check\n    else:\n        R = check\n\nprint(ans0 + 1, ans1 + 1)\n", "complexity": "exponential"}
{"src": "def get_ans(x, a, n, m):\n\n    lim = 1<<m\n    match = lim-1\n    track = [-1 for i in range(lim)]\n\n    for i in range(n):\n        mask = 0\n        for j in range(m):\n            if(a[i][j] >= x):\n                mask |= 1 << j\n        track[mask] = i\n\n    for i in range(lim):\n        for j in range(lim):\n            if(i|j == match and track[i] != -1 and track[j] != -1):\n                return track[i], track[j]\n    \n    return -1, -1\n\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\nlo = 0\nhi = 1000000000\nwhile(lo < hi-1):\n    mid = (lo+hi)/2\n    i, j = get_ans(mid,a,n,m)\n    if(i == -1):\n        hi = mid-1\n    else:\n        lo = mid\n\ni,j = get_ans(hi,a,n,m)\nif(i != -1):\n    print(\"{} {}\".format(i+1,j+1))\nelse:\n    i,j = get_ans(lo,a,n,m)\n    print(\"{} {}\".format(i+1,j+1))\n", "complexity": "exponential"}
{"src": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\n#threading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#sys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\n# -----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b:a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] > k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n    def getNode(self):\n        return TrieNode()\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n        return pCrawl != None and pCrawl.isEndOfWord\n#-----------------------------------------trie---------------------------------\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.count=0\n        self.left = None  # left node for 0\n        self.right = None  # right node for 1\nclass BinaryTrie:\n    def __init__(self):\n        self.root = Node(0)\n    def insert(self, pre_xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = pre_xor & (1 << i)\n            if val:\n                if not self.temp.right:\n                    self.temp.right = Node(0)\n                self.temp = self.temp.right\n                self.temp.count+=1\n            if not val:\n                if not self.temp.left:\n                    self.temp.left = Node(0)\n                self.temp = self.temp.left\n                self.temp.count += 1\n        self.temp.data = pre_xor\n    def query(self, xor):\n        self.temp = self.root\n        for i in range(31, -1, -1):\n            val = xor & (1 << i)\n            if not val:\n                if self.temp.left and self.temp.left.count>0:\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.count>0:\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n            self.temp.count-=1\n        return xor ^ self.temp.data\n#-------------------------bin trie-------------------------------------------\nn,m=map(int,input().split())\nl=[]\npm=2**m-1\nfor i in range(n):\n    l.append(list(map(int,input().split())))\ndef find (x):\n    s=set()\n    d=defaultdict(int)\n    for i in range(n):\n        a=\"\"\n        for j in range(m):\n            if l[i][j]>=x:\n                a+='1'\n            else:\n                a+='0'\n        d[int(a,2)]=i\n        s.add(int(a,2))\n    s=list(s)\n    #print(s)\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            if s[i]|s[j]==pm:\n                return [d[s[i]]+1,d[s[j]]+1]\n    return [-1,-1]\nst=0\nend=10**9\nans=(0,0)\nwhile(st<=end):\n    mid=(st+end)//2\n    s=find(mid)\n    if s[0]!=-1:\n        ans=s\n        st=mid+1\n    else:\n        end=mid-1\nprint(*ans)", "complexity": "exponential"}
{"src": "import sys\nfrom array import array  # noqa: F401\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401\n\n\ndef input():\n    return sys.stdin.buffer.readline().decode('utf-8')\n\n\ndef main():\n    n, m = map(int, input().split())\n    mat = [array('i', map(int, input().split())) for _ in range(n)]\n    bit = [1 << i for i in range(m)]\n    fullbit = (1 << m) - 1\n\n    def solve(x: int) -> Tuple[int, int]:\n        dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)}\n        keys = tuple(dp.keys())\n\n        for i in range(len(keys)):\n            for j in range(i, len(keys)):\n                if keys[i] | keys[j] == fullbit:\n                    return dp[keys[i]], dp[keys[j]]\n\n        return -1, -1\n\n    ok, ng = 0, 10**9 + 1\n    ans_i, ans_j = 1, 1\n\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) >> 1\n        x, y = solve(mid)\n        if x == -1:\n            ng = mid\n        else:\n            ok = mid\n            ans_i, ans_j = x + 1, y + 1\n\n    print(ans_i, ans_j)\n\n\nif __name__ == '__main__':\n    main()\n", "complexity": "exponential"}
{"src": "import math\ndef f(n,s):\n    d=[-n,-n];d[s]=0\n    for i in range(y//g):\n\t    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]\n    return d[s]\nn,x,y=map(int,input().split());\ng,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));\ny+=x;\nprint(n%g*h(n//g+1)+(g-n%g)*h(n//g))\n", "complexity": "exponential"}
{"src": "import sys\ninput = sys.stdin.readline\n\n\ndef topological_sorted(digraph):\n    n = len(digraph)\n    indegree = [0] * n\n    for v in range(n):\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] += 1\n\n    tp_order = [i for i in range(n) if indegree[i] == 0]\n    stack = tp_order[:]\n    while stack:\n        v = stack.pop()\n        for nxt_v in digraph[v]:\n            indegree[nxt_v] -= 1\n            if indegree[nxt_v] == 0:\n                stack.append(nxt_v)\n                tp_order.append(nxt_v)\n\n    return len(tp_order) == n, tp_order\n\n\nn, m, k = map(int, input().split())\np = [input()[:-1] for i in range(n)]\ns = [list(input().split()) for i in range(m)]\n\n\nmemo = {}\nfor idx, ptn in enumerate(p):\n    val = 0\n    for i in range(k):\n        if ptn[i] == \"_\":\n            continue\n        val += (ord(ptn[i]) - 96) * (27 ** i)\n    memo[val] = idx\n\nfor i, (string, idx) in enumerate(s):\n    s[i] = tuple(map(ord, string)), int(idx)\n\ngraph = [[] for i in range(n)]\nfor string, idx in s:\n    idxs = []\n    idx -= 1\n    for bit_state in range(1 << k):\n        val = 0\n        for i in range(k):\n            if (bit_state >> i) & 1:\n                continue\n            val += (string[i] - 96) * (27 ** i)\n        if val in memo:\n            idxs.append(memo[val])\n    if idx not in idxs:\n        print(\"NO\")\n        exit()\n\n    for idx_to in idxs:\n        if idx == idx_to:\n            continue\n        graph[idx].append(idx_to)\n\nflag, res = topological_sorted(graph)\nif flag:\n    print(\"YES\")\n    print(*[i + 1 for i in res])\nelse:\n    print(\"NO\")", "complexity": "exponential"}
{"src": "#CF-E-00\nimport sys\nfrom collections import deque, defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\ndef topological_sort(In, Out):\n    dq, L = deque(), []\n    for i, I in enumerate(In):\n        if not I:\n            dq.append(i)\n    while dq:\n        v = dq.popleft()\n        L.append(v)\n        for w in Out[v]:\n            In[w].remove(v)\n            if not In[w]:\n                dq.append(w)\n    if len(L) < len(In):\n        return False\n    return L\n\ndef main():\n    n, m, k = map(int,input().split())  #k: length of following inputs\n\n    def edges(s):\n        Ans = set()\n        for i in range(2**k):\n            ans = [s[j] if i>>j&1 else '_' for j in range(k)]\n            Ans.add(''.join(ans))\n        return Ans\n\n    D = defaultdict(lambda : -1)\n    for i in range(n):\n        D[input()] = i\n\n    flag = 1\n    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]\n    for _ in range(m):\n        S, t = input().split()\n        t = int(t)\n\n        for e in edges(S):\n            if D[e]+1:\n                Out[t-1].add(D[e])\n                In[D[e]].add(t-1)\n        if t-1 not in Out[t-1]:\n            flag = 0\n            break\n        else:\n            Out[t-1].remove(t-1)\n            In[t-1].remove(t-1)\n\n    T = topological_sort(In, Out)\n    if flag and T:\n        print('YES')\n        print(*[t+1 for t in T], sep = ' ')\n    else:\n        print('NO')\n        \nmain()", "complexity": "exponential"}
{"src": "#   Author: yumtam\n#   Created at: 2021-03-06 23:41\n\ndef parse():\n    s, i = input().split()\n    i = int(i) - 1\n    return s, i\n\ndef match(p, s):\n    for a, b in zip(p, s):\n        if a != '_' and a != b:\n            return False\n    return True\n\ndef main():\n    from itertools import product\n\n    n, m, k = [int(t) for t in input().split()]\n    P = [input() for _ in range(n)]\n    S = [parse() for _ in range(m)]\n\n    index_of = dict()\n    for i, p in enumerate(P):\n        index_of[p] = i\n\n    G = [[] for _ in range(n)]\n    for s, i in S:\n        if not match(P[i], s):\n            print(\"NO\")\n            return\n\n        for mask in product(range(2), repeat=k):\n            sp = ['_' if bit else c for bit, c in zip(mask, s)]\n            sp = ''.join(sp)\n\n            try:\n                j = index_of[sp]\n                if i != j:\n                    G[i].append(j)\n            except:\n                pass\n\n    tp = toposort(G)\n    if tp is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*[x+1 for x in tp])\n\n\ndef toposort(graph):\n    res, found = [], [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    # cycle check\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\nimport sys, os, io\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nstdout = io.BytesIO()\nsys.stdout.write = lambda s: stdout.write(s.encode(\"ascii\"))\n\nmain()\n\nos.write(1, stdout.getvalue())\n", "complexity": "exponential"}
{"src": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, K = map(int, input().split())\nS = [-1 if a == \"?\" else ord(a) - 97 for a in input()]\nII = {1 << i: i for i in range(20)}\ndef calc(mmm):\n    inf = 300000\n    X = [[0] * N for _ in range(K)]\n    for k in range(K):\n        Xk = X[k]\n        mi = inf\n        r = 0\n        for i in range(N)[::-1]:\n            if S[i] < 0 or S[i] == k:\n                r += 1\n            else:\n                r = 0\n            if r >= mmm:\n                mi = min(mi, i + mmm)\n            Xk[i] = mi\n\n    Y = [0] * (1 << K)\n    for i in range(1, 1 << K):\n        mi = inf\n        for j in range(K):\n            if i >> j & 1:\n                ii = i ^ (1 << j)\n                if Y[ii] < N:\n                    mi = min(mi, X[j][Y[ii]])\n        Y[i] = mi\n    return 1 if Y[-1] < inf else 0\n    \nl, r = 0, N // K + 1\nwhile r - l > 1:\n    m = l + r >> 1\n    if calc(m):\n        l = m\n    else:\n        r = m\nprint(l)\n\n", "complexity": "exponential"}
{"src": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n\n    \n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n   \n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n            effect[j][i] = min(effect[j][i],inf)\n\n\n   \n#    print(effect)                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n//k+1\n \nwhile front < rear:\n    mid = (front+rear)//2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)\n", "complexity": "exponential"}
